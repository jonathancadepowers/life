<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="csrf-token" content="{{ csrf_token }}">
    <title>Tasks</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <link href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.1/font/bootstrap-icons.css" rel="stylesheet">
    <style>
        * {
            box-sizing: border-box;
        }

        body {
            background-color: #f8f9fa;
            min-height: 100vh;
            padding-bottom: 2rem;
        }

        .container {
            max-width: 700px;
            padding: 1.5rem;
        }

        .page-header {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 2rem;
        }

        .page-icon {
            font-size: 1.75rem;
            color: #333;
        }

        .page-title {
            font-size: 1.75rem;
            font-weight: 300;
            color: #333;
            margin: 0;
        }

        /* Task Input */
        .task-input-container {
            margin-bottom: 0.15rem;
        }

        #new-task-input {
            width: 100%;
            font-size: 1.5rem;
            padding: 1rem;
            border: none;
            border-bottom: 2px solid #dee2e6;
            background: transparent;
            outline: none;
            transition: border-color 0.2s;
        }

        #new-task-input:focus {
            border-bottom-color: #0d6efd;
        }

        #new-task-input::placeholder {
            color: #adb5bd;
        }

        /* Task List */
        .task-list {
            list-style: none;
            padding: 0;
            margin: 0;
        }

        .task-item {
            display: flex;
            align-items: flex-start;
            padding: 1rem 0;
            border-bottom: 1px solid #e9ecef;
            cursor: pointer;
            transition: background-color 0.15s;
            margin: 0 -0.5rem;
            padding-left: 0.5rem;
            padding-right: 0.5rem;
            border-radius: 6px;
        }

        .task-item:hover {
            background-color: #f1f3f4;
        }

        .task-item.critical .task-title {
            color: #dc3545;
            font-weight: 500;
        }

        .task-checkbox {
            width: 22px;
            height: 22px;
            border: 2px solid #adb5bd;
            border-radius: 50%;
            margin-right: 1rem;
            flex-shrink: 0;
            cursor: pointer;
            transition: all 0.15s;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-top: 2px;
        }

        .task-checkbox:hover {
            border-color: #0d6efd;
            background-color: rgba(13, 110, 253, 0.1);
        }

        .task-content {
            flex: 1;
            min-width: 0;
        }

        .task-title {
            font-size: 1.1rem;
            color: #212529;
            word-wrap: break-word;
        }

        .task-details-preview {
            font-size: 0.875rem;
            color: #6c757d;
            margin-top: 0.25rem;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .task-critical-indicator {
            color: #dc3545;
            margin-left: 0.5rem;
            font-size: 0.75rem;
        }

        /* Slide-out Panel */
        .panel-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(0, 0, 0, 0.3);
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s, visibility 0.3s;
            z-index: 1000;
        }

        .panel-overlay.active {
            opacity: 1;
            visibility: visible;
        }

        .slide-panel {
            position: fixed;
            top: 0;
            right: 0;
            width: 100%;
            max-width: 400px;
            height: 100%;
            background: white;
            box-shadow: -4px 0 20px rgba(0, 0, 0, 0.15);
            transform: translateX(100%);
            transition: transform 0.3s ease;
            z-index: 1001;
            display: flex;
            flex-direction: column;
        }

        .slide-panel.active {
            transform: translateX(0);
        }

        .panel-header {
            padding: 1.25rem;
            border-bottom: 1px solid #e9ecef;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .panel-close {
            background: none;
            border: none;
            font-size: 1.5rem;
            color: #6c757d;
            cursor: pointer;
            padding: 0;
            line-height: 1;
        }

        .panel-close:hover {
            color: #212529;
        }

        .panel-body {
            flex: 1;
            padding: 1.25rem;
            overflow-y: auto;
        }

        .panel-title-input {
            width: 100%;
            font-size: 1.25rem;
            font-weight: 500;
            border: none;
            padding: 0.5rem 0;
            margin-bottom: 1rem;
            outline: none;
            border-bottom: 1px solid transparent;
        }

        .panel-title-input:focus {
            border-bottom-color: #0d6efd;
        }

        .panel-details-label {
            font-size: 0.875rem;
            color: #6c757d;
            margin-bottom: 0.5rem;
        }

        .panel-details-input {
            width: 100%;
            min-height: 150px;
            border: 1px solid #dee2e6;
            border-radius: 8px;
            padding: 0.75rem;
            font-size: 1rem;
            resize: vertical;
            outline: none;
        }

        .panel-details-input:focus {
            border-color: #0d6efd;
        }

        .panel-footer {
            padding: 1rem 1.25rem;
            border-top: 1px solid #e9ecef;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .critical-toggle {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            cursor: pointer;
            user-select: none;
        }

        .critical-toggle input {
            width: 18px;
            height: 18px;
            cursor: pointer;
        }

        .critical-toggle label {
            cursor: pointer;
            color: #dc3545;
            font-weight: 500;
        }

        .delete-btn {
            background: none;
            border: none;
            color: #6c757d;
            cursor: pointer;
            padding: 0.5rem;
            font-size: 1.25rem;
        }

        .delete-btn:hover {
            color: #dc3545;
        }

        /* Empty state */
        .empty-state {
            text-align: center;
            padding: 3rem 1rem;
            color: #6c757d;
        }

        .empty-state i {
            font-size: 3rem;
            margin-bottom: 1rem;
            opacity: 0.5;
        }

        /* Sidebar icons */
        .sidebar-icons {
            position: fixed;
            top: 1.5rem;
            left: 1.5rem;
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
            z-index: 100;
        }

        .sidebar-icon {
            color: #adb5bd;
            cursor: pointer;
            font-size: 1.25rem;
            transition: color 0.2s;
        }

        .sidebar-icon:hover {
            color: #6c757d;
        }

        .sidebar-icon.active {
            color: #6B9080;
        }

        /* Filter dropdown */
        .filter-dropdown {
            position: fixed;
            top: 1.5rem;
            left: 3.5rem;
            background: white;
            border-radius: 8px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.15);
            padding: 1rem;
            min-width: 220px;
            z-index: 1100;
            display: none;
        }

        .filter-dropdown.active {
            display: block;
        }

        .filter-section {
            margin-bottom: 1rem;
        }

        .filter-section:last-child {
            margin-bottom: 0;
        }

        .filter-section-title {
            font-size: 0.75rem;
            font-weight: 600;
            color: #6c757d;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            margin-bottom: 0.5rem;
        }

        .filter-option {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.35rem 0;
            cursor: pointer;
            font-size: 0.9rem;
            color: #333;
        }

        .filter-option:hover {
            color: #6B9080;
        }

        .filter-option input[type="checkbox"] {
            width: 16px;
            height: 16px;
            cursor: pointer;
            accent-color: #6B9080;
        }

        .filter-option .context-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            flex-shrink: 0;
        }

        .filter-clear {
            width: 100%;
            padding: 0.5rem;
            margin-top: 0.5rem;
            border: 1px solid #dee2e6;
            background: white;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.8rem;
            color: #6c757d;
            transition: all 0.15s;
        }

        .filter-clear:hover {
            background: #f8f9fa;
            border-color: #6B9080;
            color: #6B9080;
        }

        .filter-badge {
            position: absolute;
            top: -4px;
            right: -4px;
            background: #6B9080;
            color: white;
            font-size: 0.65rem;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        /* Left slide-out panel for contexts */
        .context-panel {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            max-width: 320px;
            height: 100%;
            background: white;
            box-shadow: 4px 0 20px rgba(0, 0, 0, 0.15);
            transform: translateX(-100%);
            transition: transform 0.3s ease;
            z-index: 1001;
            display: flex;
            flex-direction: column;
        }

        .context-panel.active {
            transform: translateX(0);
        }

        .context-list {
            list-style: none;
            padding: 0;
            margin: 0;
        }

        .context-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0.75rem 1.25rem;
            border-bottom: 1px solid #e9ecef;
        }

        .context-item:hover {
            background-color: #f8f9fa;
        }

        .context-name {
            font-size: 1rem;
            cursor: pointer;
            padding: 0.125rem 0.25rem;
            border-radius: 4px;
            transition: background 0.15s;
        }

        .context-name:hover {
            background: #e9ecef;
        }

        .context-name-input {
            font-size: 1rem;
            padding: 0.125rem 0.25rem;
            border: 1px solid #6B9080;
            border-radius: 4px;
            outline: none;
            width: 120px;
        }

        .context-delete {
            background: none;
            border: none;
            color: #adb5bd;
            cursor: pointer;
            padding: 0.25rem;
            font-size: 1rem;
            opacity: 0;
            transition: opacity 0.15s, color 0.15s;
        }

        .context-item:hover .context-delete {
            opacity: 1;
        }

        .context-delete:hover {
            color: #dc3545;
        }

        .context-input-container {
            padding: 1rem 1.25rem;
            border-bottom: 1px solid #e9ecef;
        }

        #new-context-input {
            width: 100%;
            padding: 0.5rem 0.75rem;
            border: 1px solid #dee2e6;
            border-radius: 6px;
            font-size: 0.95rem;
            outline: none;
        }

        #new-context-input:focus {
            border-color: #0d6efd;
        }

        /* Context dropdown in task panel */
        .panel-context-label {
            font-size: 0.875rem;
            color: #6c757d;
            margin-top: 1rem;
            margin-bottom: 0.5rem;
        }

        #panel-context {
            width: 100%;
            padding: 0.5rem 0.75rem;
            border: 1px solid #dee2e6;
            border-radius: 6px;
            font-size: 1rem;
            background: white;
            outline: none;
        }

        #panel-context:focus {
            border-color: #0d6efd;
        }

        /* Context badge on task item */
        .task-context-badge {
            font-size: 0.75rem;
            color: white;
            background: #6c757d;
            padding: 0.125rem 0.5rem;
            border-radius: 4px;
            margin-left: 0.5rem;
        }

        /* Context color indicator */
        .context-color-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 0.5rem;
            flex-shrink: 0;
        }

        .context-item-left {
            display: flex;
            align-items: center;
        }

        /* Settings section headers */
        .settings-section-header {
            font-size: 0.75rem;
            font-weight: 600;
            color: #6c757d;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            padding: 1rem 1.25rem 0.5rem;
            background: #f8f9fa;
        }

        .settings-section {
            border-bottom: 1px solid #e9ecef;
        }

        .settings-section:last-child {
            border-bottom: none;
        }

        /* State list styles */
        .state-list {
            list-style: none;
            padding: 0;
            margin: 0;
        }

        .state-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0.75rem 1.25rem;
            border-bottom: 1px solid #e9ecef;
        }

        .state-item:last-child {
            border-bottom: none;
        }

        .state-item:hover {
            background-color: #f8f9fa;
        }

        .state-name {
            font-size: 1rem;
            cursor: pointer;
            padding: 0.125rem 0.25rem;
            border-radius: 4px;
            transition: background 0.15s;
        }

        .state-name:hover {
            background: #e9ecef;
        }

        .state-name.no-edit {
            cursor: default;
        }

        .state-name.no-edit:hover {
            background: transparent;
        }

        .state-name-input {
            font-size: 1rem;
            padding: 0.125rem 0.25rem;
            border: 1px solid #6B9080;
            border-radius: 4px;
            outline: none;
            width: 100px;
        }

        .state-delete {
            background: none;
            border: none;
            color: #adb5bd;
            cursor: pointer;
            padding: 0.25rem;
            font-size: 1rem;
            opacity: 0;
            transition: opacity 0.15s, color 0.15s;
        }

        .state-item:hover .state-delete {
            opacity: 1;
        }

        .state-delete:hover {
            color: #dc3545;
        }

        .state-icon-btn {
            background: none;
            border: 1px solid #dee2e6;
            border-radius: 4px;
            color: #6c757d;
            cursor: pointer;
            padding: 0.25rem 0.4rem;
            font-size: 0.875rem;
            transition: all 0.15s;
        }

        .state-icon-btn:hover {
            border-color: #6B9080;
            color: #6B9080;
        }

        .state-icon-btn i.bi-plus-circle-dotted {
            opacity: 0.5;
        }

        .icon-picker-popup {
            position: fixed;
            background: white;
            border-radius: 8px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.2);
            padding: 0.75rem;
            z-index: 1200;
            max-width: 280px;
            max-height: 300px;
            overflow-y: auto;
        }

        .icon-picker-grid {
            display: grid;
            grid-template-columns: repeat(6, 1fr);
            gap: 0.25rem;
        }

        .icon-picker-item {
            width: 36px;
            height: 36px;
            display: flex;
            align-items: center;
            justify-content: center;
            border: none;
            background: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 1.1rem;
            color: #333;
            transition: background 0.15s;
        }

        .icon-picker-item:hover {
            background: #e9ecef;
        }

        .icon-picker-item.selected {
            background: #6B9080;
            color: white;
        }

        .icon-picker-clear {
            width: 100%;
            padding: 0.5rem;
            margin-top: 0.5rem;
            border: 1px solid #dee2e6;
            background: white;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.8rem;
            color: #6c757d;
        }

        .icon-picker-clear:hover {
            background: #f8f9fa;
        }

        .icon-picker-custom {
            display: flex;
            gap: 0.5rem;
            margin-bottom: 0.75rem;
            padding-bottom: 0.75rem;
            border-bottom: 1px solid #e9ecef;
        }

        .icon-picker-custom input {
            flex: 1;
            padding: 0.4rem 0.6rem;
            border: 1px solid #dee2e6;
            border-radius: 4px;
            font-size: 0.85rem;
            outline: none;
        }

        .icon-picker-custom input:focus {
            border-color: #6B9080;
        }

        .icon-picker-custom button {
            padding: 0.4rem 0.75rem;
            background: #6B9080;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.85rem;
        }

        .icon-picker-custom button:hover {
            background: #5a7a6c;
        }

        .state-input-container {
            padding: 0.75rem 1.25rem;
        }

        #new-state-input {
            width: 100%;
            padding: 0.5rem 0.75rem;
            border: 1px solid #dee2e6;
            border-radius: 6px;
            font-size: 0.95rem;
            outline: none;
        }

        #new-state-input:focus {
            border-color: #0d6efd;
        }

        .state-item-left {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .state-item-right {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .state-drag-handle {
            cursor: grab;
            color: #adb5bd;
            padding: 0.25rem;
            margin-right: 0.25rem;
        }

        .state-drag-handle:hover {
            color: #6c757d;
        }

        .state-item.dragging {
            opacity: 0.5;
            background: #e9ecef;
        }

        .state-item.drag-over {
            border-top: 2px solid #6B9080;
        }

        .state-item.terminal-state .state-drag-handle,
        .state-item.inbox-state .state-drag-handle {
            opacity: 0.3;
            cursor: not-allowed;
        }

        .state-item.terminal-state {
            /* Removed background and border for uniform appearance */
        }

        .state-item.inbox-state {
            /* Removed background for uniform appearance */
        }

        .state-terminal-checkbox-wrapper.disabled-inbox {
            cursor: not-allowed;
        }

        .state-terminal-checkbox-wrapper.disabled-inbox .state-terminal-checkbox {
            cursor: not-allowed;
            opacity: 0.5;
        }

        .state-terminal-checkbox {
            width: 16px;
            height: 16px;
            cursor: pointer;
            accent-color: #6B9080;
        }

        .state-terminal-checkbox:disabled {
            cursor: not-allowed;
            opacity: 0.5;
        }

        .state-terminal-checkbox-wrapper {
            position: relative;
            display: inline-flex;
            align-items: center;
        }

        .state-terminal-checkbox-wrapper.disabled-terminal {
            cursor: help;
        }

        .state-terminal-checkbox-wrapper.disabled-terminal::after {
            content: attr(data-tooltip);
            position: absolute;
            left: 100%;
            top: 50%;
            transform: translateY(-50%);
            background: #333;
            color: white;
            padding: 0.4rem 0.6rem;
            border-radius: 4px;
            font-size: 0.75rem;
            white-space: nowrap;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.2s, visibility 0.2s;
            z-index: 1200;
            margin-left: 8px;
        }

        .state-terminal-checkbox-wrapper.disabled-terminal:hover::after {
            opacity: 1;
            visibility: visible;
        }

        /* Mobile adjustments */
        @media (max-width: 576px) {
            .container {
                padding: 1rem;
            }

            h1 {
                font-size: 1.5rem;
                margin-bottom: 1.5rem;
            }

            #new-task-input {
                font-size: 1.25rem;
                padding: 0.75rem 0;
            }

            .slide-panel {
                max-width: 100%;
            }

            .context-panel {
                max-width: 100%;
            }

            .settings-gear {
                top: 1rem;
                left: 1rem;
            }

            .task-title {
                font-size: 1rem;
            }

            .kanban-board {
                flex-direction: column;
                gap: 1rem;
            }

            .kanban-column {
                min-width: 100%;
                max-height: 300px;
            }
        }

        /* Section Headers */
        .section-container {
            max-width: 1800px;
            margin: 0.25rem auto;
        }

        .section-container:first-of-type {
            margin-top: 2rem;
        }

        .section-header {
            padding: 0 3rem 0.5rem;
        }

        .section-title {
            font-size: 1.5rem;
            font-weight: 600;
            color: #2c3e50;
            margin: 0;
            letter-spacing: -0.5px;
        }

        /* Kanban Board */
        .kanban-container {
            max-width: 1800px;
            margin: 0 auto;
            padding: 0 3rem 0.5rem;
        }

        .kanban-board {
            display: flex;
            gap: 1.25rem;
            overflow-x: auto;
            padding-bottom: 0.5rem;
        }

        .kanban-column {
            flex: 1;
            min-width: 200px;
            background: #fff;
            border-radius: 8px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            display: flex;
            flex-direction: column;
        }

        .kanban-column-header {
            padding: 0.75rem 1rem;
            font-weight: 500;
            font-size: 0.875rem;
            color: #333;
            border-bottom: 1px solid #e9ecef;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .kanban-column-count {
            background: #e9ecef;
            color: #6c757d;
            font-size: 0.75rem;
            padding: 0.125rem 0.5rem;
            border-radius: 10px;
        }

        .kanban-column-body {
            padding: 0.5rem;
            flex: 1;
            overflow-y: auto;
            min-height: 100px;
            max-height: 190px;
        }

        .kanban-column-body.drag-over {
            background: #f0f7f4;
        }

        .kanban-card {
            background: #f8f9fa;
            border: 1px solid #e9ecef;
            border-radius: 6px;
            padding: 0.625rem 0.75rem;
            margin-bottom: 0.5rem;
            cursor: grab;
            transition: box-shadow 0.15s, transform 0.15s;
            position: relative;
            height: 50px;
            display: flex;
            flex-direction: column;
            justify-content: center;
        }

        .kanban-card:hover {
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .kanban-card.dragging {
            opacity: 0.5;
            transform: rotate(2deg);
        }

        .kanban-card-title {
            font-size: 0.9rem;
            color: #212529;
            margin-bottom: 0;
            padding-right: 1.5rem;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .kanban-card-critical-icon {
            position: absolute;
            bottom: 0.25rem;
            right: 0.5rem;
            color: #6c757d;
            font-size: 1.4rem;
            opacity: 0.5;
        }

        .kanban-card-meta {
            display: none;
        }

        .kanban-card-context {
            font-size: 0.7rem;
            color: white;
            padding: 0.1rem 0.4rem;
            border-radius: 3px;
        }

        .kanban-empty {
            color: #adb5bd;
            font-size: 0.8rem;
            text-align: center;
            padding: 1rem;
            font-style: italic;
        }

        /* Calendar (Today View) */
        .calendar-container {
            max-width: 1800px;
            margin: 0 auto;
            padding: 0 3rem 1rem;
        }

        .calendar-board {
            display: flex;
            gap: 1rem;
        }

        .calendar-box {
            flex: 1;
            min-width: 200px;
            background: #fff;
            border-radius: 8px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            display: flex;
            flex-direction: column;
        }


        .calendar-box-header {
            padding: 0.75rem 1rem;
            font-weight: 500;
            font-size: 0.875rem;
            color: #333;
            border-bottom: 1px solid #e9ecef;
        }

        .calendar-box-title {
            font-weight: 500;
            font-size: 0.875rem;
            color: #333;
        }

        .calendar-box-body {
            flex: 1;
            overflow-y: auto;
            min-height: 100px;
            max-height: 400px;
            display: flex;
            flex-direction: row;
        }

        .calendar-label-column {
            background: #f8f9fa;
            min-width: 56px;
            display: flex;
            flex-direction: column;
            flex-shrink: 0;
        }

        .calendar-label-column .calendar-time-label {
            font-size: 0.75rem;
            color: #6c757d;
            text-align: left;
            padding: 1.25rem 0.5rem;
            border-bottom: 1px solid #e0e0e0;
            flex: 1;
            display: flex;
            align-items: center;
        }

        .calendar-label-column .calendar-time-label:last-child {
            border-bottom: none;
        }

        .calendar-content-column {
            flex: 1;
            display: flex;
            flex-direction: column;
        }

        .calendar-content-column .calendar-section {
            padding: 0.5rem;
            border-bottom: 1px solid #e9ecef;
            min-height: 60px;
            flex: 1;
            display: flex;
            align-items: center;
        }

        .calendar-content-column .calendar-section:last-child {
            border-bottom: none;
        }

        .calendar-section-content {
            width: 100%;
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
            align-items: center;
        }

        .calendar-task-count {
            background: #f8f9fa;
            border: 1px solid #e9ecef;
            border-radius: 6px;
            padding: 0.625rem 0.75rem;
            cursor: pointer;
            transition: box-shadow 0.15s;
            height: 50px;
            display: flex;
            align-items: center;
            font-size: 0.9rem;
            color: #495057;
        }

        .calendar-task-count:hover {
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .calendar-section-content .kanban-card {
            margin-bottom: 0;
        }

        /* Right slide-out panel for time slot tasks */
        .timeslot-panel {
            position: fixed;
            top: 0;
            right: 0;
            width: 100%;
            max-width: 400px;
            height: 100%;
            background: white;
            box-shadow: -4px 0 20px rgba(0, 0, 0, 0.15);
            transform: translateX(100%);
            transition: transform 0.3s ease;
            z-index: 1001;
            display: flex;
            flex-direction: column;
        }

        .timeslot-panel.active {
            transform: translateX(0);
        }

        .timeslot-panel-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s ease, visibility 0.3s ease;
            z-index: 1000;
        }

        .timeslot-panel-overlay.active {
            opacity: 1;
            visibility: visible;
        }

        .timeslot-task-list {
            flex: 1;
            overflow-y: auto;
            padding: 1rem;
        }

        .timeslot-task-item {
            background: #f8f9fa;
            border: 1px solid #e9ecef;
            border-radius: 6px;
            padding: 0.75rem;
            margin-bottom: 0.75rem;
            cursor: grab;
            transition: box-shadow 0.15s;
            position: relative;
        }

        .timeslot-task-item:active {
            cursor: grabbing;
        }

        .timeslot-task-item:hover {
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .timeslot-task-item.dragging {
            opacity: 0.5;
        }

        .timeslot-task-title {
            font-size: 0.95rem;
            color: #212529;
            margin-bottom: 0.25rem;
        }

        .timeslot-task-meta {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .timeslot-task-context {
            font-size: 0.7rem;
            color: white;
            padding: 0.1rem 0.4rem;
            border-radius: 3px;
        }

        .calendar-content-column .calendar-section.drag-over {
            background: #f0f7f4;
        }

        /* ========== Two-Panel Layout ========== */
        .two-panel-container {
            max-width: 1800px;
            margin: 0 auto;
            padding: 0 2rem 2rem;
        }

        .panels-wrapper {
            display: flex;
            gap: 1rem;
            height: 870px;
        }

        .panel {
            background: white;
            border: 1px solid #dee2e6;
            border-radius: 8px;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            transition: flex 0.3s ease, min-width 0.3s ease, opacity 0.3s ease;
            position: relative;
        }

        .panel.tasks-panel {
            flex: 1;
            min-width: 300px;
        }

        .panel.calendar-panel {
            flex: 1;
            min-width: 300px;
        }

        .panel.collapsed {
            flex: 0 0 48px;
            min-width: 48px;
            max-width: 48px;
        }

        .panel.collapsed .panel-content {
            display: none;
        }

        .panel.collapsed .panel-header-title {
            display: none;
        }

        .panel-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0.75rem 1rem;
            border-bottom: 1px solid #e9ecef;
            background: #fafafa;
            min-height: 48px;
        }

        .panel-header-left {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .panel-header-title {
            font-weight: 600;
            font-size: 0.8rem;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            color: #495057;
        }

        .panel-collapse-btn {
            background: none;
            border: none;
            color: #6c757d;
            cursor: pointer;
            padding: 0.25rem;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: color 0.15s, transform 0.3s;
            font-size: 1rem;
        }

        .panel-collapse-btn:hover {
            color: #495057;
        }

        .panel.tasks-panel.collapsed .panel-collapse-btn {
            transform: rotate(180deg);
        }

        .panel.calendar-panel.collapsed .panel-collapse-btn {
            transform: rotate(180deg);
        }

        .panel-content {
            flex: 1;
            overflow-y: auto;
            padding: 1rem;
        }

        /* Collapsed panel vertical text */
        .panel-header-vertical {
            writing-mode: vertical-rl;
            text-orientation: mixed;
            transform: rotate(180deg);
            font-weight: 600;
            font-size: 0.8rem;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            color: #495057;
            display: none;
            position: absolute;
            top: 60px;
            left: 50%;
            transform: translateX(-50%) rotate(180deg);
        }

        .panel.collapsed .panel-header-vertical {
            display: block;
        }

        .panel.collapsed .panel-header {
            border-bottom: none;
        }

        /* Tasks Panel - State Groups */
        .state-group {
            margin-bottom: 1.5rem;
        }

        .state-group:last-child {
            margin-bottom: 0;
        }

        .state-group-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0.75rem 1rem;
            cursor: pointer;
            background: #fafbfc;
            border: 1px solid #e9ecef;
            border-left: 3px solid #6B9080;
            border-radius: 6px;
            transition: all 0.15s;
            user-select: none;
        }

        .state-group-header:hover {
            background: #f5f7f8;
            border-color: #dee2e6;
        }

        .state-group.collapsed .state-group-header {
            background: #fdfdfd;
            border-left-color: #cbd5e0;
        }

        .state-group:not(.collapsed) .state-group-header {
            border-bottom-left-radius: 0;
            border-bottom-right-radius: 0;
        }

        .state-group-left {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .state-group-icon {
            color: #495057;
            font-size: 1rem;
        }

        .state-group-name {
            font-weight: 600;
            font-size: 0.85rem;
            color: #2c3e50;
            text-transform: uppercase;
            letter-spacing: 0.03em;
        }

        .state-group-right {
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }

        .state-group-count {
            background: #e9ecef;
            color: #6c757d;
            font-size: 0.7rem;
            padding: 0.125rem 0.4rem;
            border-radius: 10px;
        }

        .state-group-toggle {
            color: #6c757d;
            font-size: 0.875rem;
            transition: transform 0.2s;
        }

        .state-group.collapsed .state-group-toggle {
            transform: rotate(-90deg);
        }

        .state-group-body {
            padding: 0.9rem 0.5rem;
            background: white;
            border: 1px solid #e9ecef;
            border-top: none;
            border-bottom-left-radius: 6px;
            border-bottom-right-radius: 6px;
            min-height: 40px;
            transition: background 0.15s;
        }

        .state-group-body.drag-over {
            background: #f0f7f4;
        }

        .state-group.collapsed .state-group-body {
            display: none;
        }

        .task-card {
            background: #fafbfc;
            border: 1px solid #eef0f2;
            border-radius: 4px;
            padding: 0.4rem 0.6rem;
            margin-bottom: 0.7rem;
            cursor: grab;
            transition: background 0.15s, box-shadow 0.15s, opacity 0.15s;
        }

        .task-card:last-child {
            margin-bottom: 0;
        }

        .task-card:hover {
            background: #f0f7f4;
            border-color: #d0e0d8;
        }

        .task-card.dragging {
            opacity: 0.5;
            cursor: grabbing;
        }

        .task-card.drag-over {
            border-color: #6B9080;
            box-shadow: 0 0 0 1px #6B9080;
        }
        }

        .task-card:last-child {
            margin-bottom: 0;
        }

        .task-card-title {
            font-size: 0.8rem;
            color: #333;
            margin-bottom: 0;
        }

        .task-card.critical .task-card-title {
            color: #dc3545;
            font-weight: 500;
        }

        .task-card-meta {
            display: none;
        }

        .task-card-context {
            font-size: 0.65rem;
            color: white;
            padding: 0.1rem 0.4rem;
            border-radius: 3px;
        }

        .state-group-empty {
            color: #adb5bd;
            font-size: 0.8rem;
            font-style: italic;
            padding: 0.5rem;
            text-align: center;
        }

        /* Calendar Panel - Hourly View */
        .calendar-date-header {
            display: flex;
            align-items: center;
            justify-content: flex-start;
            padding: 0.5rem 1rem;
            border-bottom: 1px solid #e9ecef;
            background: white;
        }

        .calendar-date-text {
            font-size: 0.9rem;
            font-weight: 500;
            color: #333;
        }

        .hourly-grid {
            flex: 1;
            overflow-y: auto;
        }

        .hour-row {
            display: flex;
            min-height: 60px;
            border-bottom: 1px solid #f0f0f0;
        }

        .hour-row:last-child {
            border-bottom: none;
        }

        .hour-label {
            width: 70px;
            padding: 0.5rem 0.75rem;
            font-size: 0.75rem;
            color: #6c757d;
            text-align: right;
            border-right: 1px solid #e9ecef;
            flex-shrink: 0;
            background: #fafafa;
        }

        .hour-content {
            flex: 1;
            padding: 0.25rem 0.5rem;
            position: relative;
            min-height: 60px;
        }

        .hour-content:hover {
            background: #fafafa;
        }

        .hour-event {
            background: #6B9080;
            color: white;
            font-size: 0.75rem;
            padding: 0.25rem 0.5rem;
            border-radius: 4px;
            margin-bottom: 0.25rem;
            cursor: pointer;
        }

        .hour-event:hover {
            background: #5a7d6e;
        }

        /* Right-click context menu */
        .task-context-menu {
            position: fixed;
            background: white;
            border-radius: 8px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.2);
            padding: 0.5rem 0;
            min-width: 180px;
            z-index: 1300;
        }

        .task-context-menu-item {
            padding: 0.5rem 1rem;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 0.75rem;
            font-size: 0.9rem;
            color: #333;
            transition: background 0.15s;
        }

        .task-context-menu-item:hover {
            background: #f0f7f4;
        }

        .task-context-menu-item i {
            width: 16px;
            text-align: center;
            color: #6c757d;
        }

        .task-context-menu-item.danger {
            color: #dc3545;
        }

        .task-context-menu-item.danger i {
            color: #dc3545;
        }

        .task-context-menu-divider {
            height: 1px;
            background: #e9ecef;
            margin: 0.25rem 0;
        }

        .task-context-menu-submenu {
            position: relative;
        }

        .task-context-menu-submenu-content {
            position: absolute;
            left: 100%;
            top: -0.5rem;
            background: white;
            border-radius: 8px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.2);
            padding: 0.5rem 0;
            min-width: 150px;
            display: none;
        }

        .task-context-menu-submenu:hover .task-context-menu-submenu-content {
            display: block;
        }

        .task-context-menu-item .submenu-arrow {
            margin-left: auto;
            font-size: 0.75rem;
        }

        .context-option {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .context-option-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
        }

        .task-context-menu-item.active {
            background: #f0f7f4;
        }

        .task-context-menu-item.active::before {
            content: 'âœ“';
            position: absolute;
            right: 1rem;
            font-size: 0.75rem;
            color: #6B9080;
        }
    </style>
</head>
<body>
    <!-- Sidebar icons -->
    <div class="sidebar-icons">
        <div style="position: relative;">
            <i class="bi bi-funnel sidebar-icon" id="filter-icon" title="Filter"></i>
            <span class="filter-badge" id="filter-badge" style="display: none;">0</span>
        </div>
        <i class="bi bi-gear sidebar-icon" id="settings-gear" title="Settings"></i>
    </div>

    <!-- Filter dropdown -->
    <div class="filter-dropdown" id="filter-dropdown">
        <div class="filter-section">
            <div class="filter-section-title">Context</div>
            <div id="filter-contexts">
                {% for context in contexts %}
                <label class="filter-option">
                    <input type="checkbox" class="filter-context-checkbox" value="{{ context.id }}" data-color="{{ context.color }}">
                    <span class="context-dot" style="background: {{ context.color }};"></span>
                    {{ context.name }}
                </label>
                {% empty %}
                <div style="color: #adb5bd; font-size: 0.85rem; font-style: italic;">No contexts</div>
                {% endfor %}
            </div>
        </div>
        <div class="filter-section">
            <div class="filter-section-title">Priority</div>
            <label class="filter-option">
                <input type="checkbox" id="filter-critical">
                <i class="bi bi-exclamation-circle" style="color: #dc3545;"></i>
                Critical only
            </label>
        </div>
        <button class="filter-clear" id="filter-clear">Clear Filters</button>
    </div>

    <div class="container">
        <div class="page-header">
            <i class="bi bi-highlights page-icon" id="page-icon"></i>
            <h1 class="page-title">Task Manager</h1>
        </div>

        <div class="task-input-container">
            <input type="text"
                   id="new-task-input"
                   placeholder="Add a new task..."
                   autocomplete="off">
        </div>
    </div>

    <!-- Two-Panel Layout -->
    <div class="two-panel-container">
        <div class="panels-wrapper">
            <!-- Tasks Panel -->
            <div class="panel tasks-panel" id="tasks-panel">
                <div class="panel-header">
                    <div class="panel-header-left">
                        <span class="panel-header-title">Tasks</span>
                    </div>
                    <button class="panel-collapse-btn" id="tasks-collapse-btn" title="Collapse Tasks">
                        <i class="bi bi-chevron-left"></i>
                    </button>
                </div>
                <span class="panel-header-vertical">Tasks</span>
                <div class="panel-content" id="tasks-content">
                    {% for state in states %}
                    {% if not state.is_terminal %}
                    <div class="state-group collapsed" data-state-id="{{ state.id }}">
                        <div class="state-group-header" onclick="toggleStateGroup(this)">
                            <div class="state-group-left">
                                {% if state.bootstrap_icon %}<i class="bi {{ state.bootstrap_icon }} state-group-icon"></i>{% endif %}
                                <span class="state-group-name">{{ state.name }}</span>
                            </div>
                            <div class="state-group-right">
                                <span class="state-group-count" id="panel-count-{{ state.id }}">0</span>
                                <i class="bi bi-chevron-down state-group-toggle"></i>
                            </div>
                        </div>
                        <div class="state-group-body" data-state-id="{{ state.id }}">
                            {% for task in tasks %}
                            {% if task.state == state %}
                            <div class="task-card{% if task.critical %} critical{% endif %}" data-task-id="{{ task.id }}" data-context-id="{% if task.context %}{{ task.context.id }}{% endif %}" draggable="true">
                                <div class="task-card-title">{{ task.title }}</div>
                                <div class="task-card-meta">
                                    {% if task.context %}<span class="task-card-context" style="background: {{ task.context.color }};">{{ task.context.name }}</span>{% endif %}
                                </div>
                            </div>
                            {% endif %}
                            {% endfor %}
                        </div>
                    </div>
                    {% endif %}
                    {% endfor %}
                </div>
            </div>

            <!-- Calendar Panel -->
            <div class="panel calendar-panel" id="calendar-panel">
                <div class="panel-header">
                    <button class="panel-collapse-btn" id="calendar-collapse-btn" title="Collapse Calendar">
                        <i class="bi bi-chevron-right"></i>
                    </button>
                    <div class="panel-header-left">
                        <span class="panel-header-title">Calendar</span>
                    </div>
                </div>
                <span class="panel-header-vertical">Calendar</span>
                <div class="panel-content">
                    <div class="calendar-date-header">
                        <span class="calendar-date-text" id="calendar-date-text">Today</span>
                    </div>
                    <div class="hourly-grid" id="hourly-grid">
                        <!-- Hours 7am to 6pm will be generated by JavaScript -->
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Left slide-out Panel for Settings -->
    <div class="panel-overlay" id="context-panel-overlay"></div>
    <div class="context-panel" id="context-panel">
        <div class="panel-header">
            <span style="font-weight: 500;">Settings</span>
            <button class="panel-close" id="context-panel-close">&times;</button>
        </div>
        <div class="panel-body" style="padding: 0;">
            <!-- Contexts Section -->
            <div class="settings-section">
                <div class="settings-section-header">Contexts</div>
                <div class="context-input-container">
                    <input type="text" id="new-context-input" placeholder="Add new context..." autocomplete="off">
                </div>
                <ul class="context-list" id="context-list">
                    {% for context in contexts %}
                    <li class="context-item" data-context-id="{{ context.id }}" data-context-color="{{ context.color }}">
                        <div class="context-item-left">
                            <div class="context-color-dot" style="background: {{ context.color }};"></div>
                            <span class="context-name" onclick="editContextName({{ context.id }}, this)">{{ context.name }}</span>
                        </div>
                        <button class="context-delete" onclick="deleteContext({{ context.id }}, this)" title="Delete context">
                            <i class="bi bi-x-lg"></i>
                        </button>
                    </li>
                    {% empty %}
                    <li class="context-item" id="no-contexts" style="color: #6c757d; justify-content: center;">
                        No contexts yet
                    </li>
                    {% endfor %}
                </ul>
            </div>

            <!-- States Section -->
            <div class="settings-section">
                <div class="settings-section-header">States</div>
                <div class="state-input-container">
                    <input type="text" id="new-state-input" placeholder="Add new state..." autocomplete="off">
                </div>
                <ul class="state-list" id="state-list">
                    {% for state in states %}
                    {% if not state.is_terminal %}
                    <li class="state-item{% if state.name == 'Inbox' %} inbox-state{% endif %}" data-state-id="{{ state.id }}" data-state-name="{{ state.name }}" data-is-terminal="false" data-order="{{ state.order }}" data-icon="{{ state.bootstrap_icon }}" draggable="{% if state.name == 'Inbox' %}false{% else %}true{% endif %}">
                        <div class="state-item-left">
                            <i class="bi bi-grip-vertical state-drag-handle"></i>
                            <div class="state-terminal-checkbox-wrapper{% if state.name == 'Inbox' %} disabled-inbox{% endif %}">
                                <input type="checkbox"
                                       class="state-terminal-checkbox"
                                       {% if state.name == 'Inbox' %}disabled{% endif %}
                                       onchange="toggleTerminal({{ state.id }}, this)">
                            </div>
                            <span class="state-name{% if state.name == 'Inbox' %} no-edit{% endif %}" {% if state.name != 'Inbox' %}onclick="editStateName({{ state.id }}, this)"{% endif %}>{{ state.name }}</span>
                        </div>
                        <div class="state-item-right">
                            <button class="state-icon-btn" onclick="openIconPicker({{ state.id }}, this)" title="Choose icon">
                                <i class="bi {% if state.bootstrap_icon %}{{ state.bootstrap_icon }}{% else %}bi-plus-circle-dotted{% endif %}"></i>
                            </button>
                            {% if state.name != 'Inbox' %}
                            <button class="state-delete" onclick="deleteState({{ state.id }}, this)" title="Delete state">
                                <i class="bi bi-x-lg"></i>
                            </button>
                            {% else %}
                            <button class="state-delete" style="visibility: hidden; pointer-events: none;">
                                <i class="bi bi-x-lg"></i>
                            </button>
                            {% endif %}
                        </div>
                    </li>
                    {% endif %}
                    {% empty %}
                    <li class="state-item" id="no-states" style="color: #6c757d; justify-content: center;">
                        No states yet
                    </li>
                    {% endfor %}
                    {% for state in states %}
                    {% if state.is_terminal %}
                    <li class="state-item terminal-state" data-state-id="{{ state.id }}" data-state-name="{{ state.name }}" data-is-terminal="true" data-order="9999" data-icon="{{ state.bootstrap_icon }}" draggable="false">
                        <div class="state-item-left">
                            <i class="bi bi-grip-vertical state-drag-handle"></i>
                            <div class="state-terminal-checkbox-wrapper">
                                <input type="checkbox"
                                       class="state-terminal-checkbox"
                                       checked
                                       onchange="toggleTerminal({{ state.id }}, this)">
                            </div>
                            <span class="state-name" onclick="editStateName({{ state.id }}, this)">{{ state.name }}</span>
                        </div>
                        <div class="state-item-right">
                            <button class="state-icon-btn" onclick="openIconPicker({{ state.id }}, this)" title="Choose icon">
                                <i class="bi {% if state.bootstrap_icon %}{{ state.bootstrap_icon }}{% else %}bi-plus-circle-dotted{% endif %}"></i>
                            </button>
                            <button class="state-delete" onclick="deleteState({{ state.id }}, this)" title="Delete state">
                                <i class="bi bi-x-lg"></i>
                            </button>
                        </div>
                    </li>
                    {% endif %}
                    {% endfor %}
                </ul>
            </div>
        </div>
    </div>

    <!-- Right slide-out Panel for Task Details -->
    <div class="panel-overlay" id="panel-overlay"></div>
    <div class="slide-panel" id="slide-panel">
        <div class="panel-header">
            <span style="font-weight: 500;">Edit Task</span>
            <button class="panel-close" id="panel-close">&times;</button>
        </div>
        <div class="panel-body">
            <input type="text" class="panel-title-input" id="panel-title" placeholder="Task title">
            <div class="panel-details-label">Details</div>
            <textarea class="panel-details-input" id="panel-details" placeholder="Add details..."></textarea>
            <div class="panel-context-label">Context</div>
            <select id="panel-context">
                <option value="">No context</option>
                {% for context in contexts %}
                <option value="{{ context.id }}">{{ context.name }}</option>
                {% endfor %}
            </select>
        </div>
        <div class="panel-footer">
            <div class="critical-toggle">
                <input type="checkbox" id="panel-critical">
                <label for="panel-critical">Critical</label>
            </div>
            <button class="delete-btn" id="panel-delete" title="Delete task">
                <i class="bi bi-trash"></i>
            </button>
        </div>
    </div>

    <!-- Right slide-out Panel for Time Slot Tasks -->
    <div class="timeslot-panel-overlay" id="timeslot-panel-overlay"></div>
    <div class="timeslot-panel" id="timeslot-panel">
        <div class="panel-header">
            <span style="font-weight: 500;" id="timeslot-panel-title">Time Slot Tasks</span>
            <button class="panel-close" id="timeslot-panel-close">&times;</button>
        </div>
        <div class="timeslot-task-list" id="timeslot-task-list">
            <!-- Tasks will be populated here -->
        </div>
    </div>

    <script>
        const csrfToken = document.querySelector('meta[name="csrf-token"]').content;
        let currentTaskId = null;
        let saveTimeout = null;

        // Store contexts locally for immediate availability
        let contextsList = [
            {% for context in contexts %}
            { id: {{ context.id }}, name: "{{ context.name|escapejs }}", color: "{{ context.color }}" }{% if not forloop.last %},{% endif %}
            {% endfor %}
        ];

        // Color palette for auto-assignment
        const colorPalette = ['#6B9080', '#D4C4A8', '#C9A227', '#8B7B8B', '#A89090', '#8A9878', '#7B8B98', '#6c757d', '#5D5D5D', '#4A6670'];

        // Get next color for new context (cycles through palette)
        function getNextColor() {
            const usedColors = contextsList.map(c => c.color.toUpperCase());
            // Find first unused color
            for (const color of colorPalette) {
                if (!usedColors.includes(color.toUpperCase())) {
                    return color;
                }
            }
            // If all colors used, cycle based on count
            return colorPalette[contextsList.length % colorPalette.length];
        }

        // Add new task on Enter
        document.getElementById('new-task-input').addEventListener('keypress', async function(e) {
            if (e.key === 'Enter' && this.value.trim()) {
                const title = this.value.trim();
                this.value = '';

                try {
                    const response = await fetch('/tasks/api/create/', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'X-CSRFToken': csrfToken
                        },
                        body: JSON.stringify({ title })
                    });

                    const data = await response.json();
                    if (data.success) {
                        addTaskToKanban(data.task);
                    }
                } catch (error) {
                    console.error('Error creating task:', error);
                }
            }
        });

        function addTaskToKanban(task) {
            // Find the Inbox column (or the column matching the task's state)
            const stateId = task.state_id;
            const columnBody = document.querySelector(`.kanban-column-body[data-state-id="${stateId}"]`);

            if (columnBody) {
                const card = createKanbanCard(task);
                columnBody.insertBefore(card, columnBody.firstChild);
                updateKanbanCounts();
            }
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }


        function closePanel() {
            document.getElementById('panel-overlay').classList.remove('active');
            document.getElementById('slide-panel').classList.remove('active');
            currentTaskId = null;
        }

        document.getElementById('panel-close').addEventListener('click', closePanel);
        document.getElementById('panel-overlay').addEventListener('click', closePanel);

        // Auto-save on changes
        ['panel-title', 'panel-details', 'panel-critical', 'panel-context'].forEach(id => {
            const el = document.getElementById(id);
            const event = (el.type === 'checkbox') ? 'change' : (el.tagName === 'SELECT' ? 'change' : 'input');
            el.addEventListener(event, () => {
                if (saveTimeout) clearTimeout(saveTimeout);
                saveTimeout = setTimeout(saveCurrentTask, 500);
            });
        });

        async function saveCurrentTask() {
            if (!currentTaskId) return;

            const title = document.getElementById('panel-title').value.trim();
            const details = document.getElementById('panel-details').value;
            const critical = document.getElementById('panel-critical').checked;
            const contextId = document.getElementById('panel-context').value || null;

            try {
                const response = await fetch(`/tasks/api/${currentTaskId}/update/`, {
                    method: 'PATCH',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-CSRFToken': csrfToken
                    },
                    body: JSON.stringify({ title, details, critical, context_id: contextId })
                });

                const data = await response.json();
                if (data.success) {
                    handleTaskStateChange(data.task);
                }
            } catch (error) {
                console.error('Error updating task:', error);
            }
        }

        function updateTaskInList(task) {
            const taskItem = document.querySelector(`.task-item[data-task-id="${task.id}"]`);
            if (!taskItem) return;

            taskItem.className = 'task-item' + (task.critical ? ' critical' : '');
            taskItem.dataset.contextId = task.context_id || '';
            taskItem.dataset.contextColor = task.context_color || '';

            const titleEl = taskItem.querySelector('.task-title');
            titleEl.innerHTML = escapeHtml(task.title) +
                (task.critical ? ' <i class="bi bi-exclamation-circle-fill task-critical-indicator"></i>' : '') +
                (task.context_name ? ` <span class="task-context-badge" style="background: ${task.context_color};">${escapeHtml(task.context_name)}</span>` : '');

            let detailsEl = taskItem.querySelector('.task-details-preview');
            if (task.details) {
                if (!detailsEl) {
                    detailsEl = document.createElement('div');
                    detailsEl.className = 'task-details-preview';
                    taskItem.querySelector('.task-content').appendChild(detailsEl);
                }
                detailsEl.textContent = task.details.substring(0, 50) + (task.details.length > 50 ? '...' : '');
            } else if (detailsEl) {
                detailsEl.remove();
            }
        }

        // Delete task
        document.getElementById('panel-delete').addEventListener('click', async () => {
            if (!currentTaskId || !confirm('Delete this task?')) return;
            await deleteTask(currentTaskId);
            closePanel();
        });

        async function deleteTask(taskId) {
            try {
                const response = await fetch(`/tasks/api/${taskId}/delete/`, {
                    method: 'DELETE',
                    headers: {
                        'X-CSRFToken': csrfToken
                    }
                });

                const data = await response.json();
                if (data.success) {
                    // Remove from kanban
                    const kanbanCard = document.querySelector(`.kanban-card[data-task-id="${taskId}"]`);
                    if (kanbanCard) {
                        kanbanCard.style.opacity = '0';
                        kanbanCard.style.transform = 'translateX(20px)';
                        kanbanCard.style.transition = 'all 0.3s';
                        setTimeout(() => {
                            kanbanCard.remove();
                            updateKanbanCounts();
                        }, 300);
                    }
                }
            } catch (error) {
                console.error('Error deleting task:', error);
            }
        }

        // ========== Context Panel ==========

        // Open context panel
        document.getElementById('settings-gear').addEventListener('click', () => {
            document.getElementById('context-panel-overlay').classList.add('active');
            document.getElementById('context-panel').classList.add('active');
        });

        function closeContextPanel() {
            document.getElementById('context-panel-overlay').classList.remove('active');
            document.getElementById('context-panel').classList.remove('active');
        }

        document.getElementById('context-panel-close').addEventListener('click', closeContextPanel);
        document.getElementById('context-panel-overlay').addEventListener('click', closeContextPanel);

        // Add new context on Enter
        document.getElementById('new-context-input').addEventListener('keypress', async function(e) {
            if (e.key === 'Enter' && this.value.trim()) {
                const name = this.value.trim();
                this.value = '';
                const autoColor = getNextColor();

                try {
                    const response = await fetch('/tasks/api/contexts/create/', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'X-CSRFToken': csrfToken
                        },
                        body: JSON.stringify({ name, color: autoColor })
                    });

                    const data = await response.json();
                    if (data.success) {
                        addContextToList(data.context);
                        addContextToDropdown(data.context);
                        contextsList.push(data.context);
                    } else {
                        alert(data.error || 'Failed to create context');
                    }
                } catch (error) {
                    console.error('Error creating context:', error);
                }
            }
        });

        function addContextToList(context) {
            // Remove "no contexts" message if present
            const noContexts = document.getElementById('no-contexts');
            if (noContexts) {
                noContexts.remove();
            }

            const li = document.createElement('li');
            li.className = 'context-item';
            li.dataset.contextId = context.id;
            li.dataset.contextColor = context.color;
            li.innerHTML = `
                <div class="context-item-left">
                    <div class="context-color-dot" style="background: ${context.color};" onclick="event.stopPropagation(); openColorPicker(${context.id}, this)"></div>
                    <span class="context-name" onclick="editContextName(${context.id}, this)">${escapeHtml(context.name)}</span>
                </div>
                <button class="context-delete" onclick="deleteContext(${context.id}, this)" title="Delete context">
                    <i class="bi bi-x-lg"></i>
                </button>
            `;

            document.getElementById('context-list').appendChild(li);
        }

        function addContextToDropdown(context) {
            const select = document.getElementById('panel-context');
            const option = document.createElement('option');
            option.value = context.id;
            option.textContent = context.name;
            select.appendChild(option);
        }

        async function deleteContext(contextId, button) {
            if (!confirm('Delete this context? Tasks with this context will become unassigned.')) return;

            try {
                const response = await fetch(`/tasks/api/contexts/${contextId}/delete/`, {
                    method: 'DELETE',
                    headers: {
                        'X-CSRFToken': csrfToken
                    }
                });

                const data = await response.json();
                if (data.success) {
                    // Remove from context list
                    const contextItem = button.closest('.context-item');
                    contextItem.remove();

                    // Remove from dropdown
                    const option = document.querySelector(`#panel-context option[value="${contextId}"]`);
                    if (option) option.remove();

                    // Update local list
                    contextsList = contextsList.filter(c => c.id !== contextId);

                    // Remove context badge from any tasks with this context
                    document.querySelectorAll(`.task-item[data-context-id="${contextId}"]`).forEach(task => {
                        task.dataset.contextId = '';
                        task.dataset.contextColor = '';
                        const badge = task.querySelector('.task-context-badge');
                        if (badge) badge.remove();
                    });

                    // Check if context list is now empty
                    const contextList = document.getElementById('context-list');
                    if (!contextList.querySelector('.context-item')) {
                        contextList.innerHTML = `
                            <li class="context-item" id="no-contexts" style="color: #6c757d; justify-content: center;">
                                No contexts yet
                            </li>
                        `;
                    }
                }
            } catch (error) {
                console.error('Error deleting context:', error);
            }
        }

        // Color picker for existing contexts
        let colorPickerContextId = null;
        let colorPickerElement = null;

        function openColorPicker(contextId, dotElement) {
            // Create color picker dropdown
            const existingPicker = document.getElementById('context-color-picker');
            if (existingPicker) existingPicker.remove();

            colorPickerContextId = contextId;
            colorPickerElement = dotElement;

            const picker = document.createElement('div');
            picker.id = 'context-color-picker';
            picker.style.cssText = `
                position: absolute;
                background: white;
                border-radius: 8px;
                box-shadow: 0 4px 12px rgba(0,0,0,0.15);
                padding: 0.5rem;
                display: flex;
                gap: 0.35rem;
                flex-wrap: wrap;
                width: 180px;
                z-index: 1100;
            `;

            const colors = ['#6B9080', '#D4C4A8', '#C9A227', '#8B7B8B', '#A89090', '#8A9878', '#7B8B98', '#6c757d', '#5D5D5D', '#4A6670'];
            colors.forEach(color => {
                const swatch = document.createElement('div');
                swatch.style.cssText = `
                    width: 24px;
                    height: 24px;
                    border-radius: 50%;
                    background: ${color};
                    cursor: pointer;
                    transition: transform 0.15s;
                `;
                swatch.addEventListener('mouseenter', () => swatch.style.transform = 'scale(1.15)');
                swatch.addEventListener('mouseleave', () => swatch.style.transform = 'scale(1)');
                swatch.addEventListener('click', () => updateContextColor(contextId, color));
                picker.appendChild(swatch);
            });

            // Position near the dot
            const rect = dotElement.getBoundingClientRect();
            picker.style.left = (rect.left + 20) + 'px';
            picker.style.top = (rect.top - 5) + 'px';

            document.body.appendChild(picker);

            // Close on outside click
            setTimeout(() => {
                document.addEventListener('click', closeColorPicker);
            }, 0);
        }

        function closeColorPicker(e) {
            const picker = document.getElementById('context-color-picker');
            if (picker && !picker.contains(e?.target)) {
                picker.remove();
                document.removeEventListener('click', closeColorPicker);
                colorPickerContextId = null;
                colorPickerElement = null;
            }
        }

        async function updateContextColor(contextId, color) {
            try {
                const response = await fetch(`/tasks/api/contexts/${contextId}/update/`, {
                    method: 'PATCH',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-CSRFToken': csrfToken
                    },
                    body: JSON.stringify({ color })
                });

                const data = await response.json();
                if (data.success) {
                    // Update the color dot
                    if (colorPickerElement) {
                        colorPickerElement.style.background = color;
                    }

                    // Update the context item data
                    const contextItem = document.querySelector(`.context-item[data-context-id="${contextId}"]`);
                    if (contextItem) {
                        contextItem.dataset.contextColor = color;
                    }

                    // Update local list
                    const ctx = contextsList.find(c => c.id === contextId);
                    if (ctx) ctx.color = color;

                    // Update all task badges with this context
                    document.querySelectorAll(`.task-item[data-context-id="${contextId}"]`).forEach(task => {
                        task.dataset.contextColor = color;
                        const badge = task.querySelector('.task-context-badge');
                        if (badge) badge.style.background = color;
                    });

                    // Close the picker
                    const picker = document.getElementById('context-color-picker');
                    if (picker) picker.remove();
                    document.removeEventListener('click', closeColorPicker);
                }
            } catch (error) {
                console.error('Error updating context color:', error);
            }
        }

        // Make existing color dots clickable
        document.querySelectorAll('.context-color-dot').forEach(dot => {
            const contextItem = dot.closest('.context-item');
            if (contextItem) {
                const contextId = contextItem.dataset.contextId;
                dot.style.cursor = 'pointer';
                dot.addEventListener('click', function(e) {
                    e.stopPropagation();
                    openColorPicker(parseInt(contextId), this);
                });
            }
        });

        // Edit context name inline
        function editContextName(contextId, spanElement) {
            const currentName = spanElement.textContent.trim();
            const input = document.createElement('input');
            input.type = 'text';
            input.className = 'context-name-input';
            input.value = currentName;

            spanElement.replaceWith(input);
            input.focus();
            input.select();

            async function saveContextName() {
                const newName = input.value.trim();
                if (newName && newName !== currentName) {
                    try {
                        const response = await fetch(`/tasks/api/contexts/${contextId}/update/`, {
                            method: 'PATCH',
                            headers: {
                                'Content-Type': 'application/json',
                                'X-CSRFToken': csrfToken
                            },
                            body: JSON.stringify({ name: newName })
                        });

                        const data = await response.json();
                        if (data.success) {
                            // Update local list
                            const ctx = contextsList.find(c => c.id === contextId);
                            if (ctx) ctx.name = newName;

                            // Update dropdown
                            const option = document.querySelector(`#panel-context option[value="${contextId}"]`);
                            if (option) option.textContent = newName;

                            // Update kanban cards with this context
                            document.querySelectorAll('.kanban-card-context').forEach(badge => {
                                const bgColor = badge.style.background;
                                if (ctx && ctx.color.toLowerCase() === bgColor.toLowerCase()) {
                                    badge.textContent = newName;
                                }
                            });

                            restoreContextSpan(newName);
                        } else {
                            alert(data.error || 'Failed to rename context');
                            restoreContextSpan(currentName);
                        }
                    } catch (error) {
                        console.error('Error renaming context:', error);
                        restoreContextSpan(currentName);
                    }
                } else {
                    restoreContextSpan(currentName);
                }
            }

            function restoreContextSpan(name) {
                const span = document.createElement('span');
                span.className = 'context-name';
                span.textContent = name;
                span.onclick = () => editContextName(contextId, span);
                input.replaceWith(span);
            }

            input.addEventListener('blur', saveContextName);
            input.addEventListener('keydown', function(e) {
                if (e.key === 'Enter') {
                    input.blur();
                } else if (e.key === 'Escape') {
                    restoreContextSpan(currentName);
                }
            });
        }

        // Edit state name inline
        function editStateName(stateId, spanElement) {
            const currentName = spanElement.textContent.trim();
            const input = document.createElement('input');
            input.type = 'text';
            input.className = 'state-name-input';
            input.value = currentName;

            spanElement.replaceWith(input);
            input.focus();
            input.select();

            async function saveStateName() {
                const newName = input.value.trim();
                if (newName && newName !== currentName) {
                    try {
                        const response = await fetch(`/tasks/api/states/${stateId}/update/`, {
                            method: 'PATCH',
                            headers: {
                                'Content-Type': 'application/json',
                                'X-CSRFToken': csrfToken
                            },
                            body: JSON.stringify({ name: newName })
                        });

                        const data = await response.json();
                        if (data.success) {
                            // Update local list
                            const state = statesList.find(s => s.id === stateId);
                            if (state) state.name = newName;

                            // Update the state item data attribute
                            const stateItem = input.closest('.state-item');
                            if (stateItem) stateItem.dataset.stateName = newName;

                            // Update kanban column header
                            const kanbanColumn = document.querySelector(`.kanban-column[data-state-id="${stateId}"]`);
                            if (kanbanColumn) {
                                const titleSpan = kanbanColumn.querySelector('.kanban-column-title');
                                const icon = state?.bootstrap_icon;
                                if (icon) {
                                    titleSpan.innerHTML = `<i class="bi ${icon}"></i> ${escapeHtml(newName)}`;
                                } else {
                                    titleSpan.textContent = newName;
                                }
                            }

                            restoreStateSpan(newName);
                        } else {
                            alert(data.error || 'Failed to rename state');
                            restoreStateSpan(currentName);
                        }
                    } catch (error) {
                        console.error('Error renaming state:', error);
                        restoreStateSpan(currentName);
                    }
                } else {
                    restoreStateSpan(currentName);
                }
            }

            function restoreStateSpan(name) {
                const span = document.createElement('span');
                span.className = 'state-name';
                span.textContent = name;
                span.onclick = () => editStateName(stateId, span);
                input.replaceWith(span);
            }

            input.addEventListener('blur', saveStateName);
            input.addEventListener('keydown', function(e) {
                if (e.key === 'Enter') {
                    input.blur();
                } else if (e.key === 'Escape') {
                    restoreStateSpan(currentName);
                }
            });
        }

        // ========== States Management ==========

        // Store states locally
        let statesList = [
            {% for state in states %}
            { id: {{ state.id }}, name: "{{ state.name|escapejs }}", is_terminal: {{ state.is_terminal|yesno:'true,false' }}, order: {{ state.order }}, bootstrap_icon: "{{ state.bootstrap_icon|escapejs }}" }{% if not forloop.last %},{% endif %}
            {% endfor %}
        ];

        // Get current terminal state ID
        function getTerminalStateId() {
            const terminalState = statesList.find(s => s.is_terminal);
            return terminalState ? terminalState.id : null;
        }

        // Update checkbox states based on terminal state
        function updateTerminalCheckboxes() {
            const terminalId = getTerminalStateId();
            document.querySelectorAll('.state-item').forEach(item => {
                const stateId = parseInt(item.dataset.stateId);
                const checkbox = item.querySelector('.state-terminal-checkbox');
                const wrapper = item.querySelector('.state-terminal-checkbox-wrapper');

                if (!checkbox) return;

                if (terminalId && terminalId !== stateId) {
                    checkbox.disabled = true;
                    wrapper.classList.add('disabled-terminal');
                    wrapper.dataset.tooltip = 'Unmark the current terminal state first';
                } else {
                    checkbox.disabled = false;
                    wrapper.classList.remove('disabled-terminal');
                    wrapper.dataset.tooltip = '';
                }
            });
        }

        // Initialize checkbox states
        updateTerminalCheckboxes();

        // Icon picker for states
        const stateIcons = [
            'bi-inbox', 'bi-inbox-fill', 'bi-play-circle', 'bi-play-fill', 'bi-arrow-right-circle',
            'bi-hourglass-split', 'bi-clock', 'bi-clock-fill', 'bi-pause-circle', 'bi-pause-fill',
            'bi-check-circle', 'bi-check-circle-fill', 'bi-check2-circle', 'bi-check-lg',
            'bi-star', 'bi-star-fill', 'bi-flag', 'bi-flag-fill', 'bi-bookmark', 'bi-bookmark-fill',
            'bi-lightning', 'bi-lightning-fill', 'bi-fire', 'bi-rocket', 'bi-bullseye',
            'bi-eye', 'bi-eye-fill', 'bi-search', 'bi-binoculars', 'bi-crosshair',
            'bi-gear', 'bi-gear-fill', 'bi-tools', 'bi-wrench', 'bi-hammer',
            'bi-pencil', 'bi-pencil-fill', 'bi-brush', 'bi-palette', 'bi-vector-pen',
            'bi-chat', 'bi-chat-fill', 'bi-chat-dots', 'bi-chat-dots-fill', 'bi-megaphone',
            'bi-people', 'bi-people-fill', 'bi-person', 'bi-person-fill', 'bi-person-check',
            'bi-folder', 'bi-folder-fill', 'bi-file-earmark', 'bi-file-text', 'bi-journal',
            'bi-calendar', 'bi-calendar-event', 'bi-calendar-check', 'bi-alarm', 'bi-bell',
            'bi-heart', 'bi-heart-fill', 'bi-emoji-smile', 'bi-hand-thumbs-up', 'bi-trophy',
            'bi-shield-check', 'bi-lock', 'bi-unlock', 'bi-key', 'bi-safe',
            'bi-code-slash', 'bi-terminal', 'bi-bug', 'bi-cpu', 'bi-database',
            'bi-cart', 'bi-bag', 'bi-gift', 'bi-currency-dollar', 'bi-credit-card'
        ];

        let currentIconPickerStateId = null;
        let iconPickerElement = null;

        function openIconPicker(stateId, btnElement) {
            closeIconPicker();

            currentIconPickerStateId = stateId;
            const stateItem = btnElement.closest('.state-item');
            const currentIcon = stateItem.dataset.icon || '';

            const picker = document.createElement('div');
            picker.className = 'icon-picker-popup';
            picker.id = 'icon-picker-popup';

            // Custom icon input
            let html = '<div class="icon-picker-custom">';
            html += '<input type="text" id="custom-icon-input" placeholder="bi-icon-name" value="' + escapeHtml(currentIcon) + '">';
            html += '<button onclick="applyCustomIcon()">Apply</button>';
            html += '</div>';

            // Icon grid
            html += '<div class="icon-picker-grid">';
            stateIcons.forEach(icon => {
                const isSelected = icon === currentIcon ? ' selected' : '';
                html += `<button class="icon-picker-item${isSelected}" data-icon="${icon}" onclick="selectStateIcon('${icon}')"><i class="bi ${icon}"></i></button>`;
            });
            html += '</div>';
            html += '<button class="icon-picker-clear" onclick="selectStateIcon(\'\')">Remove icon</button>';

            picker.innerHTML = html;

            // Position near the button
            const rect = btnElement.getBoundingClientRect();
            picker.style.left = Math.min(rect.left, window.innerWidth - 300) + 'px';
            picker.style.top = (rect.bottom + 5) + 'px';

            document.body.appendChild(picker);
            iconPickerElement = picker;

            // Close on outside click
            setTimeout(() => {
                document.addEventListener('click', handleIconPickerOutsideClick);
            }, 0);
        }

        function handleIconPickerOutsideClick(e) {
            const picker = document.getElementById('icon-picker-popup');
            if (picker && !picker.contains(e.target) && !e.target.closest('.state-icon-btn')) {
                closeIconPicker();
            }
        }

        function closeIconPicker() {
            const picker = document.getElementById('icon-picker-popup');
            if (picker) {
                picker.remove();
            }
            document.removeEventListener('click', handleIconPickerOutsideClick);
            currentIconPickerStateId = null;
            iconPickerElement = null;
        }

        function applyCustomIcon() {
            const input = document.getElementById('custom-icon-input');
            if (input) {
                let icon = input.value.trim();
                // Add bi- prefix if not present
                if (icon && !icon.startsWith('bi-')) {
                    icon = 'bi-' + icon;
                }
                selectStateIcon(icon);
            }
        }

        async function selectStateIcon(icon) {
            if (currentIconPickerStateId === null) return;

            const stateId = currentIconPickerStateId;

            try {
                const response = await fetch(`/tasks/api/states/${stateId}/update/`, {
                    method: 'PATCH',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-CSRFToken': csrfToken
                    },
                    body: JSON.stringify({ bootstrap_icon: icon })
                });

                const data = await response.json();
                if (data.success) {
                    // Update the state item in settings
                    const stateItem = document.querySelector(`.state-item[data-state-id="${stateId}"]`);
                    if (stateItem) {
                        stateItem.dataset.icon = icon;
                        const iconBtn = stateItem.querySelector('.state-icon-btn i');
                        iconBtn.className = 'bi ' + (icon || 'bi-plus-circle-dotted');
                        if (!icon) {
                            iconBtn.classList.add('bi-plus-circle-dotted');
                        }
                    }

                    // Update the kanban column header
                    const kanbanColumn = document.querySelector(`.kanban-column[data-state-id="${stateId}"]`);
                    if (kanbanColumn) {
                        kanbanColumn.dataset.icon = icon;
                        const titleSpan = kanbanColumn.querySelector('.kanban-column-title');
                        const stateName = statesList.find(s => s.id === stateId)?.name || '';
                        if (icon) {
                            titleSpan.innerHTML = `<i class="bi ${icon}"></i> ${escapeHtml(stateName)}`;
                        } else {
                            titleSpan.textContent = stateName;
                        }
                    }

                    // Update local states list
                    const state = statesList.find(s => s.id === stateId);
                    if (state) state.bootstrap_icon = icon;

                    closeIconPicker();
                } else {
                    alert(data.error || 'Failed to update icon');
                }
            } catch (error) {
                console.error('Error updating state icon:', error);
            }
        }

        // Toggle terminal state
        async function toggleTerminal(stateId, checkbox) {
            const newValue = checkbox.checked;

            try {
                const response = await fetch(`/tasks/api/states/${stateId}/update/`, {
                    method: 'PATCH',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-CSRFToken': csrfToken
                    },
                    body: JSON.stringify({ is_terminal: newValue })
                });

                const data = await response.json();
                if (data.success) {
                    // Update local list
                    const state = statesList.find(s => s.id === stateId);
                    if (state) state.is_terminal = newValue;

                    // Update data attribute and classes
                    const stateItem = checkbox.closest('.state-item');
                    stateItem.dataset.isTerminal = newValue ? 'true' : 'false';

                    if (newValue) {
                        stateItem.classList.add('terminal-state');
                        stateItem.draggable = false;
                        // Move to bottom of list
                        const stateList = document.getElementById('state-list');
                        stateList.appendChild(stateItem);
                        // Hide the kanban column for this state
                        const kanbanColumn = document.querySelector(`.kanban-column[data-state-id="${stateId}"]`);
                        if (kanbanColumn) {
                            kanbanColumn.style.display = 'none';
                        }
                    } else {
                        stateItem.classList.remove('terminal-state');
                        stateItem.draggable = true;
                        setupDragEvents(stateItem);
                        // Show the kanban column for this state
                        const kanbanColumn = document.querySelector(`.kanban-column[data-state-id="${stateId}"]`);
                        if (kanbanColumn) {
                            kanbanColumn.style.display = '';
                        }
                    }

                    // Update all checkboxes
                    updateTerminalCheckboxes();
                } else {
                    // Revert checkbox
                    checkbox.checked = !newValue;
                    alert(data.error || 'Failed to update state');
                }
            } catch (error) {
                console.error('Error updating state:', error);
                checkbox.checked = !newValue;
            }
        }

        // Add new state on Enter
        document.getElementById('new-state-input').addEventListener('keypress', async function(e) {
            if (e.key === 'Enter' && this.value.trim()) {
                const name = this.value.trim();
                this.value = '';

                try {
                    const response = await fetch('/tasks/api/states/create/', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'X-CSRFToken': csrfToken
                        },
                        body: JSON.stringify({ name })
                    });

                    const data = await response.json();
                    if (data.success) {
                        addStateToList(data.state);
                        statesList.push(data.state);
                        updateTerminalCheckboxes();
                    } else {
                        alert(data.error || 'Failed to create state');
                    }
                } catch (error) {
                    console.error('Error creating state:', error);
                }
            }
        });

        function addStateToList(state) {
            // Remove "no states" message if present
            const noStates = document.getElementById('no-states');
            if (noStates) {
                noStates.remove();
            }

            const li = document.createElement('li');
            li.className = 'state-item' + (state.is_terminal ? ' terminal-state' : '');
            li.dataset.stateId = state.id;
            li.dataset.stateName = state.name;
            li.dataset.isTerminal = state.is_terminal ? 'true' : 'false';
            li.dataset.order = state.order;
            li.dataset.icon = state.bootstrap_icon || '';
            li.draggable = !state.is_terminal;
            li.innerHTML = `
                <div class="state-item-left">
                    <i class="bi bi-grip-vertical state-drag-handle"></i>
                    <div class="state-terminal-checkbox-wrapper">
                        <input type="checkbox"
                               class="state-terminal-checkbox"
                               ${state.is_terminal ? 'checked' : ''}
                               onchange="toggleTerminal(${state.id}, this)">
                    </div>
                    <span class="state-name" onclick="editStateName(${state.id}, this)">${escapeHtml(state.name)}</span>
                </div>
                <div class="state-item-right">
                    <button class="state-icon-btn" onclick="openIconPicker(${state.id}, this)" title="Choose icon">
                        <i class="bi bi-plus-circle-dotted"></i>
                    </button>
                    <button class="state-delete" onclick="deleteState(${state.id}, this)" title="Delete state">
                        <i class="bi bi-x-lg"></i>
                    </button>
                </div>
            `;

            // Insert before terminal state if exists, otherwise append
            const stateList = document.getElementById('state-list');
            const terminalItem = stateList.querySelector('.terminal-state');
            if (terminalItem && !state.is_terminal) {
                stateList.insertBefore(li, terminalItem);
            } else {
                stateList.appendChild(li);
            }

            // Setup drag events for new item
            setupDragEvents(li);
        }

        async function deleteState(stateId, button) {
            if (!confirm('Delete this state? Tasks with this state will become unassigned.')) return;

            try {
                const response = await fetch(`/tasks/api/states/${stateId}/delete/`, {
                    method: 'DELETE',
                    headers: {
                        'X-CSRFToken': csrfToken
                    }
                });

                const data = await response.json();
                if (data.success) {
                    // Remove from state list
                    const stateItem = button.closest('.state-item');
                    stateItem.remove();

                    // Update local list
                    statesList = statesList.filter(s => s.id !== stateId);

                    // Update checkboxes in case the terminal state was deleted
                    updateTerminalCheckboxes();

                    // Check if state list is now empty
                    const stateList = document.getElementById('state-list');
                    if (!stateList.querySelector('.state-item')) {
                        stateList.innerHTML = `
                            <li class="state-item" id="no-states" style="color: #6c757d; justify-content: center;">
                                No states yet
                            </li>
                        `;
                    }
                }
            } catch (error) {
                console.error('Error deleting state:', error);
            }
        }

        // ========== Drag and Drop for States ==========

        let draggedItem = null;

        function setupDragEvents(item) {
            if (item.classList.contains('terminal-state')) return;

            item.addEventListener('dragstart', handleDragStart);
            item.addEventListener('dragend', handleDragEnd);
            item.addEventListener('dragover', handleDragOver);
            item.addEventListener('dragleave', handleDragLeave);
            item.addEventListener('drop', handleDrop);
        }

        function handleDragStart(e) {
            if (this.classList.contains('terminal-state')) {
                e.preventDefault();
                return;
            }
            draggedItem = this;
            this.classList.add('dragging');
            e.dataTransfer.effectAllowed = 'move';
        }

        function handleDragEnd(e) {
            this.classList.remove('dragging');
            document.querySelectorAll('.state-item').forEach(item => {
                item.classList.remove('drag-over');
            });
            draggedItem = null;
        }

        function handleDragOver(e) {
            e.preventDefault();
            if (this.classList.contains('terminal-state')) return;
            if (this !== draggedItem) {
                this.classList.add('drag-over');
            }
        }

        function handleDragLeave(e) {
            this.classList.remove('drag-over');
        }

        function handleDrop(e) {
            e.preventDefault();
            this.classList.remove('drag-over');

            if (this.classList.contains('terminal-state') || this === draggedItem) return;

            const stateList = document.getElementById('state-list');
            const items = [...stateList.querySelectorAll('.state-item:not(.terminal-state)')];
            const draggedIndex = items.indexOf(draggedItem);
            const dropIndex = items.indexOf(this);

            if (draggedIndex < dropIndex) {
                this.parentNode.insertBefore(draggedItem, this.nextSibling);
            } else {
                this.parentNode.insertBefore(draggedItem, this);
            }

            // Save new order
            saveStateOrder();
        }

        async function saveStateOrder() {
            const stateList = document.getElementById('state-list');
            const items = [...stateList.querySelectorAll('.state-item:not(.terminal-state):not(#no-states)')];
            const order = items.map(item => parseInt(item.dataset.stateId));

            try {
                const response = await fetch('/tasks/api/states/reorder/', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-CSRFToken': csrfToken
                    },
                    body: JSON.stringify({ order })
                });

                const data = await response.json();
                if (data.success) {
                    // Update local order values
                    items.forEach((item, index) => {
                        item.dataset.order = index;
                        const state = statesList.find(s => s.id === parseInt(item.dataset.stateId));
                        if (state) state.order = index;
                    });
                }
            } catch (error) {
                console.error('Error saving state order:', error);
            }
        }

        // Initialize drag events for existing items
        document.querySelectorAll('.state-item:not(#no-states)').forEach(item => {
            setupDragEvents(item);
            // Also setup drop zone for terminal state
            if (item.classList.contains('terminal-state')) {
                item.addEventListener('dragover', handleDragOver);
                item.addEventListener('dragleave', handleDragLeave);
            }
        });

        // ========== Kanban Board ==========

        // Update column counts
        function updateKanbanCounts() {
            document.querySelectorAll('.kanban-column-body').forEach(body => {
                const stateId = body.dataset.stateId;
                const count = body.querySelectorAll('.kanban-card').length;
                const countEl = document.getElementById(`count-state-${stateId}`);
                if (countEl) countEl.textContent = count;
            });
        }

        // Initialize counts on load
        updateKanbanCounts();

        // Make kanban cards clickable
        document.querySelectorAll('.kanban-card').forEach(card => {
            card.addEventListener('click', function(e) {
                if (e.target.closest('.kanban-card')) {
                    openKanbanPanel(this.dataset.taskId);
                }
            });
        });

        async function openKanbanPanel(taskId) {
            currentTaskId = taskId;
            const card = document.querySelector(`.kanban-card[data-task-id="${taskId}"]`);
            const title = card.querySelector('.kanban-card-title').textContent.trim();

            document.getElementById('panel-title').value = title;

            // Fetch full task details from server or use cached
            const contextBadge = card.querySelector('.kanban-card-context');
            if (contextBadge) {
                // Try to find context ID by color
                const bgColor = contextBadge.style.background;
                const ctx = contextsList.find(c => c.color.toLowerCase() === bgColor.toLowerCase());
                if (ctx) {
                    document.getElementById('panel-context').value = ctx.id;
                } else {
                    document.getElementById('panel-context').value = '';
                }
            } else {
                document.getElementById('panel-context').value = '';
            }

            document.getElementById('panel-details').value = '';
            document.getElementById('panel-critical').checked = card.classList.contains('critical');

            document.getElementById('panel-overlay').classList.add('active');
            document.getElementById('slide-panel').classList.add('active');
        }

        // Kanban drag and drop
        let draggedKanbanCard = null;
        let dropIndicator = null;

        // Create drop indicator element
        function createDropIndicator() {
            const indicator = document.createElement('div');
            indicator.className = 'kanban-drop-indicator';
            indicator.style.cssText = 'height: 3px; background: #6B9080; border-radius: 2px; margin: 0.25rem 0;';
            return indicator;
        }

        function setupKanbanCardDrag(card) {
            card.addEventListener('dragstart', function(e) {
                draggedKanbanCard = this;
                this.classList.add('dragging');
                e.dataTransfer.effectAllowed = 'move';
                e.dataTransfer.setData('text/plain', this.dataset.taskId);
                // Delay to allow drag image to be captured
                setTimeout(() => {
                    this.style.opacity = '0.4';
                }, 0);
            });

            card.addEventListener('dragend', function(e) {
                this.classList.remove('dragging');
                this.style.opacity = '1';
                document.querySelectorAll('.kanban-column-body').forEach(body => {
                    body.classList.remove('drag-over');
                });
                // Remove any drop indicator
                if (dropIndicator && dropIndicator.parentElement) {
                    dropIndicator.remove();
                }
                dropIndicator = null;
                draggedKanbanCard = null;
            });
        }

        // Get drop position within column
        function getDropPosition(columnBody, y) {
            const cards = [...columnBody.querySelectorAll('.kanban-card:not(.dragging)')];

            for (const card of cards) {
                const rect = card.getBoundingClientRect();
                const midpoint = rect.top + rect.height / 2;
                if (y < midpoint) {
                    return { element: card, position: 'before' };
                }
            }
            return { element: null, position: 'end' };
        }

        // Setup drag events for existing kanban cards
        document.querySelectorAll('.kanban-card').forEach(card => {
            setupKanbanCardDrag(card);
        });

        // Setup drop zones on column bodies
        document.querySelectorAll('.kanban-column-body').forEach(body => {
            body.addEventListener('dragover', function(e) {
                e.preventDefault();
                if (!draggedKanbanCard) return;

                this.classList.add('drag-over');

                // Show drop indicator
                const { element, position } = getDropPosition(this, e.clientY);

                if (!dropIndicator) {
                    dropIndicator = createDropIndicator();
                }

                if (position === 'end') {
                    this.appendChild(dropIndicator);
                } else if (element) {
                    element.parentElement.insertBefore(dropIndicator, element);
                }
            });

            body.addEventListener('dragleave', function(e) {
                if (!this.contains(e.relatedTarget)) {
                    this.classList.remove('drag-over');
                    if (dropIndicator && dropIndicator.parentElement === this) {
                        dropIndicator.remove();
                    }
                }
            });

            body.addEventListener('drop', async function(e) {
                e.preventDefault();
                this.classList.remove('drag-over');

                if (!draggedKanbanCard) return;

                const newStateId = parseInt(this.dataset.stateId);
                const taskId = parseInt(draggedKanbanCard.dataset.taskId);
                const oldBody = draggedKanbanCard.parentElement;
                const changedColumn = (oldBody !== this);

                // Get drop position
                const { element, position } = getDropPosition(this, e.clientY);

                // Remove drop indicator
                if (dropIndicator && dropIndicator.parentElement) {
                    dropIndicator.remove();
                }

                // Move card to new position
                if (position === 'end') {
                    this.appendChild(draggedKanbanCard);
                } else if (element) {
                    element.parentElement.insertBefore(draggedKanbanCard, element);
                }

                updateKanbanCounts();

                // Get new order of all cards in this column
                const cardIds = [...this.querySelectorAll('.kanban-card')].map(c => parseInt(c.dataset.taskId));

                // Update state if changed columns
                if (changedColumn) {
                    try {
                        const response = await fetch(`/tasks/api/${taskId}/update/`, {
                            method: 'PATCH',
                            headers: {
                                'Content-Type': 'application/json',
                                'X-CSRFToken': csrfToken
                            },
                            body: JSON.stringify({ state_id: newStateId })
                        });

                        const data = await response.json();
                        if (!data.success) {
                            console.error('Failed to update task state');
                            oldBody.appendChild(draggedKanbanCard);
                            updateKanbanCounts();
                            return;
                        }
                    } catch (error) {
                        console.error('Error updating task state:', error);
                        oldBody.appendChild(draggedKanbanCard);
                        updateKanbanCounts();
                        return;
                    }
                }

                // Save new order
                try {
                    await fetch('/tasks/api/tasks/reorder/', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'X-CSRFToken': csrfToken
                        },
                        body: JSON.stringify({ task_ids: cardIds })
                    });
                } catch (error) {
                    console.error('Error saving task order:', error);
                }
            });
        });

        function handleTaskStateChange(task) {
            const kanbanCard = document.querySelector(`.kanban-card[data-task-id="${task.id}"]`);

            if (task.state_id) {
                const targetColumn = document.querySelector(`.kanban-column-body[data-state-id="${task.state_id}"]`);
                if (targetColumn) {
                    if (kanbanCard) {
                        // Move to correct column if needed
                        if (kanbanCard.parentElement !== targetColumn) {
                            targetColumn.appendChild(kanbanCard);
                        }
                        // Update card content
                        updateKanbanCard(kanbanCard, task);
                    } else {
                        // Create new kanban card
                        const card = createKanbanCard(task);
                        targetColumn.appendChild(card);
                    }
                }
            }
            updateKanbanCounts();
        }

        function createKanbanCard(task) {
            const card = document.createElement('div');
            card.className = 'kanban-card' + (task.critical ? ' critical' : '');
            card.dataset.taskId = task.id;
            card.dataset.contextId = task.context_id || '';
            card.draggable = true;
            card.innerHTML = `
                <div class="kanban-card-title" title="${escapeHtml(task.title)}">${escapeHtml(task.title)}</div>
                <div class="kanban-card-meta">
                    ${task.context_name ? `<span class="kanban-card-context" style="background: ${task.context_color};">${escapeHtml(task.context_name)}</span>` : ''}
                </div>
                ${task.critical ? '<i class="bi bi-exclamation kanban-card-critical-icon" title="Critical"></i>' : ''}
            `;
            card.addEventListener('click', function() {
                openKanbanPanel(task.id);
            });
            setupKanbanCardDrag(card);
            setupKanbanCardContextMenu(card);
            return card;
        }

        function updateKanbanCard(card, task) {
            card.className = 'kanban-card' + (task.critical ? ' critical' : '');
            card.dataset.contextId = task.context_id || '';

            // Update title
            const title = card.querySelector('.kanban-card-title');
            title.textContent = task.title;
            title.title = task.title;

            // Update meta
            const meta = card.querySelector('.kanban-card-meta');
            if (task.context_name) {
                meta.innerHTML = `<span class="kanban-card-context" style="background: ${task.context_color};">${escapeHtml(task.context_name)}</span>`;
            } else {
                meta.innerHTML = '';
            }

            // Update/add/remove critical icon
            let icon = card.querySelector('.kanban-card-critical-icon');
            if (task.critical) {
                if (!icon) {
                    icon = document.createElement('i');
                    icon.className = 'bi bi-exclamation kanban-card-critical-icon';
                    icon.title = 'Critical';
                    card.appendChild(icon);
                }
            } else {
                if (icon) {
                    icon.remove();
                }
            }
        }

        // ========== Right-Click Context Menu ==========

        let contextMenuTaskId = null;

        function showContextMenu(e, taskId) {
            e.preventDefault();
            contextMenuTaskId = taskId;

            // Remove any existing menu
            closeContextMenu();

            const card = document.querySelector(`.kanban-card[data-task-id="${taskId}"]`);
            const isCritical = card.classList.contains('critical');

            // Get current context
            const contextBadge = card.querySelector('.kanban-card-context');
            let currentContextId = null;
            if (contextBadge) {
                const bgColor = contextBadge.style.background;
                const ctx = contextsList.find(c => c.color.toLowerCase() === bgColor.toLowerCase());
                if (ctx) currentContextId = ctx.id;
            }

            // Build menu HTML
            let menuHtml = `
                <div class="task-context-menu-item" onclick="openKanbanPanel(${taskId}); closeContextMenu();">
                    <i class="bi bi-pencil"></i>
                    Edit Task
                </div>
                <div class="task-context-menu-divider"></div>
                <div class="task-context-menu-submenu">
                    <div class="task-context-menu-item">
                        <i class="bi bi-tag"></i>
                        Set Context
                        <span class="submenu-arrow"><i class="bi bi-chevron-right"></i></span>
                    </div>
                    <div class="task-context-menu-submenu-content">
                        <div class="task-context-menu-item${!currentContextId ? ' active' : ''}" style="position: relative;" onclick="setTaskContext(${taskId}, null)">
                            <span class="context-option">
                                <span class="context-option-dot" style="background: #ccc; border: 1px dashed #999;"></span>
                                No Context
                            </span>
                        </div>
            `;

            contextsList.forEach(ctx => {
                const isActive = currentContextId === ctx.id;
                menuHtml += `
                    <div class="task-context-menu-item${isActive ? ' active' : ''}" style="position: relative;" onclick="setTaskContext(${taskId}, ${ctx.id})">
                        <span class="context-option">
                            <span class="context-option-dot" style="background: ${ctx.color};"></span>
                            ${escapeHtml(ctx.name)}
                        </span>
                    </div>
                `;
            });

            menuHtml += `
                    </div>
                </div>
                <div class="task-context-menu-item" onclick="toggleTaskCritical(${taskId})">
                    <i class="bi bi-exclamation-circle${isCritical ? '-fill' : ''}"></i>
                    ${isCritical ? 'Unmark Critical' : 'Mark Critical'}
                </div>
                <div class="task-context-menu-divider"></div>
                <div class="task-context-menu-item danger" onclick="deleteTaskFromMenu(${taskId})">
                    <i class="bi bi-trash"></i>
                    Delete Task
                </div>
            `;

            const menu = document.createElement('div');
            menu.className = 'task-context-menu';
            menu.id = 'task-context-menu';
            menu.innerHTML = menuHtml;

            // Position the menu
            document.body.appendChild(menu);

            // Adjust position to keep menu in viewport
            const menuRect = menu.getBoundingClientRect();
            let x = e.clientX;
            let y = e.clientY;

            if (x + menuRect.width > window.innerWidth) {
                x = window.innerWidth - menuRect.width - 10;
            }
            if (y + menuRect.height > window.innerHeight) {
                y = window.innerHeight - menuRect.height - 10;
            }

            menu.style.left = x + 'px';
            menu.style.top = y + 'px';

            // Close on outside click
            setTimeout(() => {
                document.addEventListener('click', closeContextMenu);
                document.addEventListener('contextmenu', closeContextMenu);
            }, 0);
        }

        function closeContextMenu() {
            const menu = document.getElementById('task-context-menu');
            if (menu) {
                menu.remove();
            }
            document.removeEventListener('click', closeContextMenu);
            document.removeEventListener('contextmenu', closeContextMenu);
            contextMenuTaskId = null;
        }

        async function setTaskContext(taskId, contextId) {
            closeContextMenu();

            try {
                const response = await fetch(`/tasks/api/${taskId}/update/`, {
                    method: 'PATCH',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-CSRFToken': csrfToken
                    },
                    body: JSON.stringify({ context_id: contextId })
                });

                const data = await response.json();
                if (data.success) {
                    // Update the kanban card
                    const card = document.querySelector(`.kanban-card[data-task-id="${taskId}"]`);
                    if (card) {
                        updateKanbanCard(card, data.task);
                    }
                }
            } catch (error) {
                console.error('Error setting task context:', error);
            }
        }

        async function toggleTaskCritical(taskId) {
            closeContextMenu();

            const card = document.querySelector(`.kanban-card[data-task-id="${taskId}"]`);
            const isCritical = card.classList.contains('critical');

            try {
                const response = await fetch(`/tasks/api/${taskId}/update/`, {
                    method: 'PATCH',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-CSRFToken': csrfToken
                    },
                    body: JSON.stringify({ critical: !isCritical })
                });

                const data = await response.json();
                if (data.success) {
                    // Update the kanban card
                    if (card) {
                        updateKanbanCard(card, data.task);
                    }
                }
            } catch (error) {
                console.error('Error toggling task critical:', error);
            }
        }

        async function deleteTaskFromMenu(taskId) {
            closeContextMenu();
            if (!confirm('Delete this task?')) return;
            await deleteTask(taskId);
        }

        // Add right-click handler to kanban cards
        function setupKanbanCardContextMenu(card) {
            card.addEventListener('contextmenu', function(e) {
                showContextMenu(e, parseInt(this.dataset.taskId));
            });
        }

        // Setup for existing cards
        document.querySelectorAll('.kanban-card').forEach(card => {
            setupKanbanCardContextMenu(card);
        });

        // ========== Filter Functionality ==========

        const filterIcon = document.getElementById('filter-icon');
        const filterDropdown = document.getElementById('filter-dropdown');
        const filterBadge = document.getElementById('filter-badge');
        const filterCritical = document.getElementById('filter-critical');
        const filterClear = document.getElementById('filter-clear');

        let activeFilters = {
            contexts: [],
            critical: false
        };

        // Toggle filter dropdown
        filterIcon.addEventListener('click', function(e) {
            e.stopPropagation();
            filterDropdown.classList.toggle('active');
            filterIcon.classList.toggle('active', filterDropdown.classList.contains('active'));
        });

        // Close filter dropdown on outside click
        document.addEventListener('click', function(e) {
            if (!filterDropdown.contains(e.target) && e.target !== filterIcon) {
                filterDropdown.classList.remove('active');
                filterIcon.classList.remove('active');
            }
        });

        // Handle context filter changes
        document.querySelectorAll('.filter-context-checkbox').forEach(checkbox => {
            checkbox.addEventListener('change', function() {
                const contextId = parseInt(this.value);
                if (this.checked) {
                    if (!activeFilters.contexts.includes(contextId)) {
                        activeFilters.contexts.push(contextId);
                    }
                } else {
                    activeFilters.contexts = activeFilters.contexts.filter(id => id !== contextId);
                }
                applyFilters();
            });
        });

        // Handle critical filter change
        filterCritical.addEventListener('change', function() {
            activeFilters.critical = this.checked;
            applyFilters();
        });

        // Clear all filters
        filterClear.addEventListener('click', function() {
            activeFilters.contexts = [];
            activeFilters.critical = false;
            document.querySelectorAll('.filter-context-checkbox').forEach(cb => cb.checked = false);
            filterCritical.checked = false;
            applyFilters();
        });

        function applyFilters() {
            // Filter both kanban cards and task cards in the new panel layout
            const allCards = document.querySelectorAll('.kanban-card, .task-card');
            let visibleCount = 0;

            allCards.forEach(card => {
                let show = true;

                // Filter by context
                if (activeFilters.contexts.length > 0) {
                    const cardContextId = card.dataset.contextId ? parseInt(card.dataset.contextId) : null;
                    if (!cardContextId || !activeFilters.contexts.includes(cardContextId)) {
                        show = false;
                    }
                }

                // Filter by critical
                if (activeFilters.critical && !card.classList.contains('critical')) {
                    show = false;
                }

                card.style.display = show ? '' : 'none';
                if (show) visibleCount++;
            });

            // Update filter badge
            const filterCount = activeFilters.contexts.length + (activeFilters.critical ? 1 : 0);
            if (filterCount > 0) {
                filterBadge.textContent = filterCount;
                filterBadge.style.display = 'flex';
                filterIcon.classList.add('active');
            } else {
                filterBadge.style.display = 'none';
                if (!filterDropdown.classList.contains('active')) {
                    filterIcon.classList.remove('active');
                }
            }

            // Update counts for both layouts
            updateKanbanCounts();
            if (typeof updatePanelCounts === 'function') {
                updatePanelCounts();
            }
        }

        // Override updateKanbanCounts to respect filters
        const originalUpdateKanbanCounts = updateKanbanCounts;
        updateKanbanCounts = function() {
            document.querySelectorAll('.kanban-column-body').forEach(body => {
                const stateId = body.dataset.stateId;
                const count = body.querySelectorAll('.kanban-card:not([style*="display: none"])').length;
                const countEl = document.getElementById(`count-state-${stateId}`);
                if (countEl) countEl.textContent = count;
            });
        };

        // ========== Two-Panel Layout ==========

        // Panel collapse/expand
        const tasksPanel = document.getElementById('tasks-panel');
        const calendarPanel = document.getElementById('calendar-panel');
        const tasksCollapseBtn = document.getElementById('tasks-collapse-btn');
        const calendarCollapseBtn = document.getElementById('calendar-collapse-btn');

        if (tasksCollapseBtn) {
            tasksCollapseBtn.addEventListener('click', function() {
                tasksPanel.classList.toggle('collapsed');
            });
        }

        if (calendarCollapseBtn) {
            calendarCollapseBtn.addEventListener('click', function() {
                calendarPanel.classList.toggle('collapsed');
            });
        }

        // State group collapse/expand
        function toggleStateGroup(header) {
            const group = header.closest('.state-group');
            group.classList.toggle('collapsed');
        }

        // Generate hourly calendar (7am to 6pm)
        function generateHourlyCalendar() {
            const grid = document.getElementById('hourly-grid');
            if (!grid) return;

            grid.innerHTML = '';

            for (let hour = 7; hour <= 18; hour++) {
                const hourRow = document.createElement('div');
                hourRow.className = 'hour-row';
                hourRow.dataset.hour = hour;

                const ampm = hour >= 12 ? 'PM' : 'AM';
                const displayHour = hour > 12 ? hour - 12 : hour;

                hourRow.innerHTML = `
                    <div class="hour-label">${displayHour}:00 ${ampm}</div>
                    <div class="hour-content" data-hour="${hour}"></div>
                `;

                grid.appendChild(hourRow);
            }
        }

        // Set today's date in calendar header
        function setCalendarDate() {
            const dateEl = document.getElementById('calendar-date-text');
            if (!dateEl) return;

            const today = new Date();
            const options = { weekday: 'long', month: 'long', day: 'numeric' };
            dateEl.textContent = today.toLocaleDateString('en-US', options);
        }

        // Update task counts in the panel layout
        function updatePanelCounts() {
            document.querySelectorAll('.state-group').forEach(group => {
                const stateId = group.dataset.stateId;
                const body = group.querySelector('.state-group-body');
                if (!body) return;

                const visibleCards = body.querySelectorAll('.task-card:not([style*="display: none"])').length;
                const countEl = document.getElementById(`panel-count-${stateId}`);
                if (countEl) countEl.textContent = visibleCards;

                // Show/hide empty message
                let emptyMsg = body.querySelector('.state-group-empty');
                if (visibleCards === 0) {
                    if (!emptyMsg) {
                        emptyMsg = document.createElement('div');
                        emptyMsg.className = 'state-group-empty';
                        emptyMsg.textContent = 'No tasks';
                        body.appendChild(emptyMsg);
                    }
                } else if (emptyMsg) {
                    emptyMsg.remove();
                }
            });
        }

        // ========== Task Card Drag and Drop ==========

        let draggedTaskCard = null;

        // Setup drag events for task cards
        function setupTaskCardDragEvents(card) {
            card.addEventListener('dragstart', function(e) {
                draggedTaskCard = this;
                this.classList.add('dragging');
                e.dataTransfer.effectAllowed = 'move';
                e.dataTransfer.setData('text/plain', this.dataset.taskId);
            });

            card.addEventListener('dragend', function() {
                this.classList.remove('dragging');
                draggedTaskCard = null;
                // Remove all drag-over classes
                document.querySelectorAll('.drag-over').forEach(el => el.classList.remove('drag-over'));
            });

            // Click to open task panel
            card.addEventListener('click', function(e) {
                if (!this.classList.contains('dragging')) {
                    openTaskPanel(parseInt(this.dataset.taskId));
                }
            });
        }

        // Setup drop zones (state-group-body elements)
        function setupDropZones() {
            document.querySelectorAll('.state-group-body').forEach(dropZone => {
                dropZone.addEventListener('dragover', function(e) {
                    e.preventDefault();
                    e.dataTransfer.dropEffect = 'move';
                    this.classList.add('drag-over');
                });

                dropZone.addEventListener('dragleave', function(e) {
                    // Only remove if we're actually leaving the drop zone
                    if (!this.contains(e.relatedTarget)) {
                        this.classList.remove('drag-over');
                    }
                });

                dropZone.addEventListener('drop', async function(e) {
                    e.preventDefault();
                    this.classList.remove('drag-over');

                    if (!draggedTaskCard) return;

                    const taskId = parseInt(draggedTaskCard.dataset.taskId);
                    const newStateId = parseInt(this.dataset.stateId);
                    const oldStateId = parseInt(draggedTaskCard.closest('.state-group').dataset.stateId);

                    // Move the card visually
                    this.appendChild(draggedTaskCard);

                    // If state changed, update on server
                    if (newStateId !== oldStateId) {
                        try {
                            const response = await fetch(`/tasks/api/tasks/${taskId}/update/`, {
                                method: 'PATCH',
                                headers: {
                                    'Content-Type': 'application/json',
                                    'X-CSRFToken': csrfToken
                                },
                                body: JSON.stringify({ state_id: newStateId })
                            });

                            if (!response.ok) {
                                console.error('Failed to update task state');
                                // Revert on failure - would need to track original parent
                            }
                        } catch (error) {
                            console.error('Error updating task state:', error);
                        }
                    }

                    // Update counts
                    updatePanelCounts();
                });
            });
        }

        // Initialize drag and drop for existing cards
        document.querySelectorAll('.task-card').forEach(card => {
            setupTaskCardDragEvents(card);
        });
        setupDropZones();

        // Initialize two-panel layout
        generateHourlyCalendar();
        setCalendarDate();
        updatePanelCounts();

        // Subtle icon color animation
        (function() {
            const icon = document.getElementById('page-icon');
            const baseColor = { r: 51, g: 51, b: 51 }; // #333
            const accentColor = { r: 107, g: 144, b: 128 }; // #6B9080 (Sage)
            let animationFrame;
            let startTime;
            let duration;
            let direction = 1; // 1 = to accent, -1 = to base

            function lerp(a, b, t) {
                return a + (b - a) * t;
            }

            function getRandomDuration() {
                return 3000 + Math.random() * 4000; // 3-7 seconds
            }

            function animate(timestamp) {
                if (!startTime) {
                    startTime = timestamp;
                    duration = getRandomDuration();
                }

                const elapsed = timestamp - startTime;
                const progress = Math.min(elapsed / duration, 1);

                // Ease in-out
                const eased = progress < 0.5
                    ? 2 * progress * progress
                    : 1 - Math.pow(-2 * progress + 2, 2) / 2;

                const t = direction === 1 ? eased : 1 - eased;

                const r = Math.round(lerp(baseColor.r, accentColor.r, t));
                const g = Math.round(lerp(baseColor.g, accentColor.g, t));
                const b = Math.round(lerp(baseColor.b, accentColor.b, t));

                icon.style.color = `rgb(${r}, ${g}, ${b})`;

                if (progress >= 1) {
                    direction *= -1;
                    startTime = null;
                }

                animationFrame = requestAnimationFrame(animate);
            }

            animationFrame = requestAnimationFrame(animate);
        })();

        // ========== Calendar Drag and Drop ==========

        // Setup calendar sections as drop zones
        document.querySelectorAll('.calendar-section').forEach(section => {
            section.addEventListener('dragover', function(e) {
                e.preventDefault();
                if (!draggedKanbanCard) return;
                this.classList.add('drag-over');
            });

            section.addEventListener('dragleave', function(e) {
                this.classList.remove('drag-over');
            });

            section.addEventListener('drop', async function(e) {
                e.preventDefault();
                this.classList.remove('drag-over');

                if (!draggedKanbanCard) return;

                const taskId = parseInt(draggedKanbanCard.dataset.taskId);

                // Get time period from parent calendar box
                const calendarBox = this.closest('.calendar-box');
                const timePeriod = calendarBox.dataset.timePeriod;
                const sectionNumber = parseInt(this.dataset.section);

                // Check if card is already in a calendar section
                const wasInCalendar = draggedKanbanCard.closest('.calendar-section');

                // Get the content div to append to
                const contentDiv = this.querySelector('.calendar-section-content');

                let cardToAdd;
                if (wasInCalendar) {
                    // Move the card from one calendar section to another
                    cardToAdd = draggedKanbanCard;
                    cardToAdd.classList.remove('dragging');
                    cardToAdd.style.opacity = '1';
                    cardToAdd.style.display = 'flex';
                    contentDiv.appendChild(cardToAdd);
                } else {
                    // Clone the card from kanban board
                    cardToAdd = draggedKanbanCard.cloneNode(true);
                    cardToAdd.draggable = true;
                    cardToAdd.classList.remove('dragging');
                    cardToAdd.style.opacity = '1';
                    cardToAdd.style.display = 'flex';
                    contentDiv.appendChild(cardToAdd);

                    // Setup drag for cloned card
                    setupCalendarCardDrag(cardToAdd);
                }

                // Update today field to true with time_period and section_number
                try {
                    await fetch(`/tasks/api/tasks/${taskId}/set-today/`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'X-CSRFToken': csrfToken
                        },
                        body: JSON.stringify({
                            today: true,
                            time_period: timePeriod,
                            section_number: sectionNumber
                        })
                    });
                } catch (error) {
                    console.error('Error updating today field:', error);
                }

                // Update calendar display after DOM updates
                setTimeout(() => {
                    processCalendarSections();
                }, 0);

                draggedKanbanCard = null;
            });
        });

        // Setup drag for calendar cards (to drag back to kanban)
        function setupCalendarCardDrag(card) {
            card.addEventListener('dragstart', function(e) {
                draggedKanbanCard = this;
                this.classList.add('dragging');
                e.dataTransfer.effectAllowed = 'move';
                e.dataTransfer.setData('text/plain', this.dataset.taskId);
                setTimeout(() => {
                    this.style.opacity = '0.4';
                }, 0);
            });

            card.addEventListener('dragend', function(e) {
                this.classList.remove('dragging');
                this.style.opacity = '1';
                draggedKanbanCard = null;
            });

            // Add click handler
            card.addEventListener('click', function() {
                openKanbanPanel(parseInt(this.dataset.taskId));
            });

            // Add context menu
            setupKanbanCardContextMenu(card);
        }

        // Setup drag for existing calendar cards
        document.querySelectorAll('.calendar-section .kanban-card').forEach(card => {
            setupCalendarCardDrag(card);
        });

        // Enhance kanban column drop to remove from calendar when dropped back
        const originalKanbanDropHandler = document.querySelectorAll('.kanban-column-body');
        originalKanbanDropHandler.forEach(body => {
            body.addEventListener('drop', async function(e) {
                if (!draggedKanbanCard) return;

                const taskId = parseInt(draggedKanbanCard.dataset.taskId);
                const wasInCalendar = draggedKanbanCard.closest('.calendar-section');

                if (wasInCalendar) {
                    // Remove from calendar
                    draggedKanbanCard.remove();

                    // Update today field to false
                    try {
                        await fetch(`/tasks/api/tasks/${taskId}/set-today/`, {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                                'X-CSRFToken': csrfToken
                            },
                            body: JSON.stringify({ today: false })
                        });
                    } catch (error) {
                        console.error('Error updating today field:', error);
                    }

                    // Update calendar display after DOM updates
                    setTimeout(() => {
                        processCalendarSections();
                    }, 0);
                }
            });
        });

        // ===== TIME SLOT PANEL FUNCTIONALITY =====

        let currentTimeslotSection = null;
        let draggedTimeslotTask = null;

        // Process calendar sections to show task counts
        function processCalendarSections() {
            document.querySelectorAll('.calendar-section').forEach(section => {
                const content = section.querySelector('.calendar-section-content');
                if (!content) return;

                const tasks = content.querySelectorAll('.kanban-card');
                const taskCount = tasks.length;

                // Remove any existing count display
                const existingCount = content.querySelector('.calendar-task-count');
                if (existingCount) {
                    existingCount.remove();
                }

                if (taskCount > 1) {
                    // Hide individual tasks
                    tasks.forEach(task => task.style.display = 'none');

                    // Create and show count summary
                    const countDiv = document.createElement('div');
                    countDiv.className = 'calendar-task-count';
                    countDiv.textContent = `${taskCount} tasks`;
                    countDiv.dataset.sectionId = section.dataset.section;

                    const calendarBox = section.closest('.calendar-box');
                    if (calendarBox) {
                        countDiv.dataset.timePeriod = calendarBox.dataset.timePeriod;
                    }

                    countDiv.addEventListener('click', function() {
                        openTimeslotPanel(section);
                    });

                    content.appendChild(countDiv);
                } else if (taskCount === 1) {
                    // Show single task normally
                    tasks[0].style.display = 'flex';
                }
            });
        }

        // Open time slot panel
        function openTimeslotPanel(section) {
            currentTimeslotSection = section;
            const content = section.querySelector('.calendar-section-content');
            if (!content) return;

            const tasks = Array.from(content.querySelectorAll('.kanban-card'));
            const calendarBox = section.closest('.calendar-box');
            if (!calendarBox) return;

            // Find the time label by section number
            const sectionNumber = parseInt(section.dataset.section);
            const labelColumn = calendarBox.querySelector('.calendar-label-column');
            if (!labelColumn) return;

            const timeLabels = labelColumn.querySelectorAll('.calendar-time-label');
            const timeLabelEl = timeLabels[sectionNumber - 1]; // section numbers are 1-indexed
            if (!timeLabelEl) return;

            const timeLabel = timeLabelEl.textContent;
            const timePeriod = calendarBox.dataset.timePeriod;

            // Set panel title
            document.getElementById('timeslot-panel-title').textContent =
                `${timePeriod.charAt(0).toUpperCase() + timePeriod.slice(1)} - ${timeLabel}`;

            // Populate task list
            const taskList = document.getElementById('timeslot-task-list');
            taskList.innerHTML = '';

            tasks.forEach(task => {
                const taskItem = createTimeslotTaskItem(task);
                taskList.appendChild(taskItem);
            });

            // Setup drag and drop for reordering
            setupTimeslotDragAndDrop();

            // Show panel
            document.getElementById('timeslot-panel-overlay').classList.add('active');
            document.getElementById('timeslot-panel').classList.add('active');
        }

        // Create task item for timeslot panel
        function createTimeslotTaskItem(task) {
            const item = document.createElement('div');
            item.className = 'timeslot-task-item';
            item.draggable = true;
            item.dataset.taskId = task.dataset.taskId;

            const title = document.createElement('div');
            title.className = 'timeslot-task-title';
            title.textContent = task.querySelector('.kanban-card-title').textContent;

            const meta = document.createElement('div');
            meta.className = 'timeslot-task-meta';

            const contextBadge = task.querySelector('.kanban-card-context');
            if (contextBadge) {
                const badge = document.createElement('span');
                badge.className = 'timeslot-task-context';
                badge.textContent = contextBadge.textContent;
                badge.style.background = contextBadge.style.background;
                meta.appendChild(badge);
            }

            item.appendChild(title);
            item.appendChild(meta);

            return item;
        }

        // Setup drag and drop for timeslot panel
        function setupTimeslotDragAndDrop() {
            const items = document.querySelectorAll('.timeslot-task-item');

            items.forEach(item => {
                item.addEventListener('dragstart', function(e) {
                    draggedTimeslotTask = this;
                    this.classList.add('dragging');
                    e.dataTransfer.effectAllowed = 'move';
                });

                item.addEventListener('dragend', function() {
                    this.classList.remove('dragging');
                    draggedTimeslotTask = null;
                });

                item.addEventListener('dragover', function(e) {
                    e.preventDefault();
                    if (draggedTimeslotTask === this) return;

                    const rect = this.getBoundingClientRect();
                    const midpoint = rect.top + rect.height / 2;

                    if (e.clientY < midpoint) {
                        this.parentNode.insertBefore(draggedTimeslotTask, this);
                    } else {
                        this.parentNode.insertBefore(draggedTimeslotTask, this.nextSibling);
                    }
                });
            });

            // Save order on drop
            document.getElementById('timeslot-task-list').addEventListener('drop', async function() {
                await saveTimeslotTaskOrder();
            });
        }

        // Save task order
        async function saveTimeslotTaskOrder() {
            const taskList = document.getElementById('timeslot-task-list');
            const taskIds = Array.from(taskList.querySelectorAll('.timeslot-task-item'))
                .map(item => parseInt(item.dataset.taskId));

            try {
                const response = await fetch('/tasks/api/tasks/reorder/', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-CSRFToken': csrfToken
                    },
                    body: JSON.stringify({ task_ids: taskIds })
                });

                if (response.ok) {
                    // Update order in the calendar section
                    if (currentTimeslotSection) {
                        const content = currentTimeslotSection.querySelector('.calendar-section-content');
                        const tasks = Array.from(content.querySelectorAll('.kanban-card'));

                        taskIds.forEach((taskId, index) => {
                            const task = tasks.find(t => parseInt(t.dataset.taskId) === taskId);
                            if (task) {
                                task.style.order = index;
                            }
                        });
                    }
                }
            } catch (error) {
                console.error('Error saving task order:', error);
            }
        }

        // Close timeslot panel
        function closeTimeslotPanel() {
            document.getElementById('timeslot-panel-overlay').classList.remove('active');
            document.getElementById('timeslot-panel').classList.remove('active');
            currentTimeslotSection = null;
        }

        // Event listeners for timeslot panel
        document.getElementById('timeslot-panel-close').addEventListener('click', closeTimeslotPanel);
        document.getElementById('timeslot-panel-overlay').addEventListener('click', closeTimeslotPanel);

        // Process calendar sections on page load
        processCalendarSections();

        // Also process after a task is moved to/from calendar
        const originalDropHandler = document.querySelectorAll('.calendar-section');
        originalDropHandler.forEach(section => {
            section.addEventListener('drop', function() {
                setTimeout(processCalendarSections, 100);
            });
        });

    </script>
</body>
</html>
