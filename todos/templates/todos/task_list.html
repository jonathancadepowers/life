<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="csrf-token" content="{{ csrf_token }}">
    <meta name="description" content="Task management and to-do list">
    <meta name="keywords" content="tasks, todos, productivity">
    <title>Tasks</title>
    <script>
        // Read cookie immediately to prevent flash of rollup metrics
        (function() {
            try {
                var cookies = document.cookie.split(';');
                for (var i = 0; i < cookies.length; i++) {
                    var cookie = cookies[i].trim();
                    if (cookie.indexOf('taskFilterSettings=') === 0) {
                        var value = decodeURIComponent(cookie.substring('taskFilterSettings='.length));
                        var settings = JSON.parse(value);
                        if (settings.hideRollups) {
                            document.documentElement.classList.add('hide-rollups-initial');
                        }
                        break;
                    }
                }
            } catch(e) {}
        })();
    </script>
    <style>
        /* Hide rollups immediately if setting is enabled (prevents flash) */
        .hide-rollups-initial .panel-collapsed-metrics { display: none; }
    </style>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <link href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.1/font/bootstrap-icons.css" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <style>
        * {
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            background-color: #f8f9fa;
            min-height: 100vh;
            padding-bottom: 2rem;
        }

        .container {
            max-width: 700px;
            padding: 1.5rem;
        }

        .page-header {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 2rem;
        }

        .page-icon {
            font-size: 1.75rem;
            color: #333;
        }

        .page-title {
            font-size: 1.75rem;
            font-weight: 300;
            color: #333;
            margin: 0;
            flex: 1;
        }

        .layout-btn {
            position: fixed;
            top: 1.5rem;
            right: 1.5rem;
            z-index: 10000;
            background: transparent;
            border: none;
            padding: 0;
            font-size: 1.25rem;
            color: #adb5bd;
            cursor: pointer;
            transition: color 0.2s;
        }

        .layout-btn:hover {
            color: #6c757d;
        }

        /* Layout Modal */
        .layout-modal {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            z-index: 10000;
        }

        .layout-modal-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.5);
        }

        .layout-modal-content {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: white;
            border-radius: 16px;
            padding: 2.5rem;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.08);
            min-width: 380px;
        }

        .layout-modal-title {
            font-size: 1.5rem;
            font-weight: 500;
            margin: 0 0 0.5rem 0;
            color: #333;
        }

        .layout-modal-subtitle {
            font-size: 0.95rem;
            color: #666;
            margin: 0 0 1.5rem 0;
        }

        .layout-mode-options {
            display: flex;
            gap: 0.75rem;
        }

        .layout-mode-card {
            flex: 1;
            padding: 1.75rem 1rem;
            background: white;
            border: 1px solid #e9ecef;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.15s ease;
            text-align: center;
        }

        .layout-mode-card:hover {
            background: #f8f9fa;
            border-color: #6B9080;
            box-shadow: 0 2px 8px rgba(107, 144, 128, 0.1);
        }

        .layout-mode-card i {
            font-size: 2rem;
            color: #6B9080;
            display: block;
            margin-bottom: 0.65rem;
        }

        .layout-mode-name {
            font-size: 0.85rem;
            font-weight: 600;
            color: #495057;
            letter-spacing: 0.03em;
        }

        .layout-mode-desc {
            font-size: 0.85rem;
            color: #666;
        }

        .layout-panel-options {
            display: flex;
            gap: 0.75rem;
        }

        .layout-panel-card {
            flex: 1;
            padding: 1.5rem 1rem;
            background: white;
            border: 1px solid #e9ecef;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.15s ease;
            text-align: center;
        }

        .layout-panel-card:hover {
            background: #f8f9fa;
            border-color: #6B9080;
            box-shadow: 0 2px 8px rgba(107, 144, 128, 0.1);
        }

        .layout-panel-card.selected {
            background: #f0f7f4;
            border-color: #6B9080;
        }

        .layout-panel-card i {
            font-size: 1.75rem;
            color: #6B9080;
            display: block;
            margin-bottom: 0.5rem;
        }

        .layout-panel-name {
            font-size: 0.85rem;
            font-weight: 500;
            color: #495057;
        }

        .layout-panel-checkboxes {
            display: flex;
            flex-direction: column;
            gap: 0.6rem;
        }

        .layout-panel-checkbox {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            padding: 0.85rem 1rem;
            background: white;
            border: 1px solid #e9ecef;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.15s ease;
        }

        .layout-panel-checkbox:hover {
            background: #f8f9fa;
            border-color: #6B9080;
        }

        .layout-panel-checkbox input[type="checkbox"] {
            width: 18px;
            height: 18px;
            cursor: pointer;
        }

        .layout-panel-checkbox input[type="checkbox"]:checked {
            accent-color: #6B9080;
        }

        .layout-panel-checkbox i {
            font-size: 1.25rem;
            color: #6B9080;
        }

        .layout-panel-checkbox span {
            font-size: 0.9rem;
            font-weight: 500;
            color: #495057;
        }

        .layout-modal-actions {
            display: flex;
            justify-content: flex-end;
            gap: 0.75rem;
            margin-top: 1.5rem;
        }

        .layout-modal-btn {
            padding: 0.5rem 1.5rem;
            border-radius: 6px;
            font-size: 0.95rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
            border: none;
        }

        .layout-modal-btn-secondary {
            background: #f8f9fa;
            color: #666;
            border: 1px solid #dee2e6;
        }

        .layout-modal-btn-secondary:hover {
            background: #e9ecef;
        }

        .layout-modal-btn-primary {
            background: #0d6efd;
            color: white;
        }

        .layout-modal-btn-primary:hover:not(:disabled) {
            background: #0b5ed7;
        }

        .layout-modal-btn-primary:disabled {
            background: #adb5bd;
            cursor: not-allowed;
        }

        /* Task Input */
        .task-input-container {
            margin-bottom: 2rem;
        }

        #new-task-input {
            width: 100%;
            font-size: 1.5rem;
            padding: 1rem;
            border: none;
            border-bottom: 2px solid #dee2e6;
            background: transparent;
            outline: none;
            transition: border-color 0.2s;
        }

        #new-task-input:focus {
            border-bottom-color: #0d6efd;
        }

        #new-task-input::placeholder {
            color: #adb5bd;
        }

        .task-input-container {
            position: relative;
        }

        .animated-placeholder {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            padding: 1rem;
            font-size: 1.5rem;
            color: #adb5bd;
            pointer-events: none;
            white-space: nowrap;
            overflow: hidden;
        }

        .animated-placeholder.hidden {
            display: none;
        }

        .animated-placeholder .char {
            display: inline-block;
            opacity: 1;
            transition: opacity 0.6s ease-out;
        }

        .animated-placeholder .char.fade-out {
            opacity: 0;
        }

        .animated-placeholder .char.fade-in {
            animation: fadeIn 0.6s ease-out forwards;
        }

        @keyframes fadeIn {
            0% {
                opacity: 0;
            }
            100% {
                opacity: 1;
            }
        }

        /* Task List */
        .task-list {
            list-style: none;
            padding: 0;
            margin: 0;
        }

        .task-item {
            display: flex;
            align-items: flex-start;
            padding: 1rem 0;
            border-bottom: 1px solid #e9ecef;
            cursor: pointer;
            transition: background-color 0.15s;
            margin: 0 -0.5rem;
            padding-left: 0.5rem;
            padding-right: 0.5rem;
            border-radius: 6px;
        }

        .task-item:hover {
            background-color: #e8f5e9;
        }

        .task-item.critical .task-title {
            color: #dc3545;
            font-weight: 500;
        }

        .task-checkbox {
            width: 22px;
            height: 22px;
            border: 2px solid #adb5bd;
            border-radius: 50%;
            margin-right: 1rem;
            flex-shrink: 0;
            cursor: pointer;
            transition: all 0.15s;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-top: 2px;
        }

        .task-checkbox:hover {
            border-color: #0d6efd;
            background-color: rgba(13, 110, 253, 0.1);
        }

        .task-content {
            flex: 1;
            min-width: 0;
        }

        .task-title {
            font-size: 1.1rem;
            color: #212529;
            word-wrap: break-word;
        }

        .task-details-preview {
            font-size: 0.875rem;
            color: #6c757d;
            margin-top: 0.25rem;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }


        /* Slide-out Panel */
        .panel-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(0, 0, 0, 0.3);
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s, visibility 0.3s;
            z-index: 1000;
        }

        .panel-overlay.active {
            opacity: 1;
            visibility: visible;
        }

        /* Modal styles */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            z-index: 2000;
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.2s, visibility 0.2s;
        }

        .modal-overlay.active {
            opacity: 1;
            visibility: visible;
        }

        .modal-content {
            background: white;
            border-radius: 12px;
            padding: 1.5rem;
            max-width: 400px;
            width: 90%;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.2);
        }

        .modal-content-wide {
            max-width: 500px;
        }

        .warnings-modal-list {
            max-height: 400px;
            overflow-y: auto;
        }

        .warnings-modal-list .deadline-task-item {
            cursor: pointer;
        }

        .warnings-modal-list .deadline-task-item:hover {
            background: #e9ecef;
        }

        .modal-title {
            font-size: 1.1rem;
            font-weight: 600;
            margin-bottom: 0.75rem;
            color: #333;
        }

        .modal-body {
            font-size: 0.9rem;
            color: #555;
            margin-bottom: 1rem;
        }

        .modal-select {
            width: 100%;
            padding: 0.5rem;
            border: 1px solid #ddd;
            border-radius: 6px;
            font-size: 0.9rem;
            margin-bottom: 1rem;
        }

        .modal-input {
            width: 100%;
            padding: 0.5rem;
            border: 1px solid #ddd;
            border-radius: 6px;
            font-size: 0.9rem;
            margin-bottom: 1rem;
            box-sizing: border-box;
        }

        .modal-input:focus {
            outline: none;
            border-color: #6B9080;
            box-shadow: 0 0 0 2px rgba(107, 144, 128, 0.2);
        }

        .modal-buttons {
            display: flex;
            justify-content: flex-end;
            gap: 0.5rem;
        }

        .modal-btn {
            padding: 0.5rem 1rem;
            border: none;
            border-radius: 6px;
            font-size: 0.85rem;
            cursor: pointer;
            transition: background 0.15s;
        }

        .modal-btn-cancel {
            background: #e9ecef;
            color: #333;
        }

        .modal-btn-cancel:hover {
            background: #dde0e3;
        }

        .modal-btn-danger {
            background: #dc3545;
            color: white;
        }

        .modal-btn-danger:hover {
            background: #c82333;
        }

        .modal-btn-primary {
            background: #6B9080;
            color: white;
        }

        .modal-btn-primary:hover {
            background: #5a7d6e;
        }

        .modal-btn-ok {
            background: #c8e6c9;
            color: #4a7c4e;
            cursor: not-allowed;
        }

        .modal-btn-ok:disabled {
            background: #c8e6c9;
            color: #8cb590;
            cursor: not-allowed;
        }

        .modal-btn-ok:not(:disabled) {
            background: #4caf50;
            color: white;
            cursor: pointer;
        }

        .modal-btn-ok:not(:disabled):hover {
            background: #43a047;
        }

        .modal-textarea {
            width: 100%;
            padding: 0.5rem;
            border: 1px solid #ddd;
            border-radius: 6px;
            font-size: 0.85rem;
            font-family: monospace;
            resize: vertical;
            box-sizing: border-box;
        }

        .modal-textarea:focus {
            outline: none;
            border-color: #6B9080;
            box-shadow: 0 0 0 2px rgba(107, 144, 128, 0.2);
        }

        .template-default-toggle {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-size: 0.85rem;
            color: #555;
        }

        .template-default-toggle input[type="checkbox"] {
            accent-color: #6B9080;
        }

        /* Template list in settings */
        .template-list {
            display: flex;
            flex-direction: column;
            gap: 0.25rem;
            padding: 0 0.75rem;
            margin-bottom: 0.5rem;
        }

        .template-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 0.5rem;
            padding: 0.4rem 0.5rem;
            background: #f8f9fa;
            border-radius: 5px;
            font-size: 0.8rem;
            border: 1px solid transparent;
            transition: all 0.15s;
        }

        .template-item:hover {
            background: #e8f0ed;
            border-color: #6B9080;
        }

        .template-item-left {
            display: flex;
            align-items: center;
            gap: 0.4rem;
            flex: 1;
            min-width: 0;
        }

        .template-item-left i {
            color: #6B9080;
            font-size: 0.85rem;
        }

        .template-item-name {
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            color: #495057;
        }

        .template-default-badge {
            font-size: 0.55rem;
            background: #6B9080;
            color: white;
            padding: 0.1rem 0.35rem;
            border-radius: 3px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            flex-shrink: 0;
        }

        .template-item-actions {
            display: flex;
            gap: 0.3rem;
            flex-shrink: 0;
            opacity: 0;
            transition: opacity 0.15s;
        }

        .template-item:hover .template-item-actions {
            opacity: 1;
        }

        .template-item-btn {
            background: white;
            border: 1px solid #e9ecef;
            color: #6c757d;
            cursor: pointer;
            padding: 0.2rem 0.35rem;
            border-radius: 3px;
            transition: all 0.15s;
            font-size: 0.75rem;
        }

        .template-item-btn:hover {
            background: #e8f0ed;
            border-color: #6B9080;
            color: #6B9080;
        }

        .template-item-btn.delete:hover {
            background: #f8d7da;
            border-color: #dc3545;
            color: #dc3545;
        }

        .add-template-btn {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.25rem;
            margin: 0 0.75rem;
            padding: 0.4rem;
            background: white;
            border: 1px dashed #d0d0d0;
            border-radius: 5px;
            color: #6c757d;
            font-size: 0.75rem;
            cursor: pointer;
            transition: all 0.15s;
        }

        .add-template-btn:hover {
            background: #e8f0ed;
            border-color: #6B9080;
            color: #6B9080;
        }

        /* Template dropdown in task panel */
        .panel-details-actions {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .template-dropdown {
            position: relative;
        }

        .template-dropdown-btn {
            display: flex;
            align-items: center;
            gap: 0.25rem;
            padding: 0.25rem 0.5rem;
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 4px;
            color: #495057;
            font-size: 0.75rem;
            cursor: pointer;
            transition: all 0.15s;
        }

        .template-dropdown-btn:hover {
            background: #e9ecef;
            border-color: #adb5bd;
        }

        .template-dropdown-btn i:last-child {
            font-size: 0.6rem;
            margin-left: 0.15rem;
        }

        .template-dropdown-menu {
            display: none;
            position: absolute;
            top: 100%;
            right: 0;
            min-width: 180px;
            max-width: 250px;
            background: white;
            border: 1px solid #dee2e6;
            border-radius: 4px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            z-index: 100;
            margin-top: 2px;
        }

        .template-dropdown-menu.show {
            display: block;
        }

        .template-dropdown-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0.5rem 0.75rem;
            font-size: 0.8rem;
            color: #333;
            cursor: pointer;
            transition: background 0.15s;
            border: none;
            background: none;
            width: 100%;
            text-align: left;
        }

        .template-dropdown-item:hover {
            background: #f8f9fa;
        }

        .template-dropdown-item:last-child {
            border-radius: 0 0 3px 3px;
        }

        .template-dropdown-item .default-indicator {
            font-size: 0.65rem;
            color: #6B9080;
            font-weight: 500;
        }

        .template-dropdown-header {
            padding: 0.5rem 0.75rem;
            font-size: 0.7rem;
            font-weight: 600;
            color: #6B9080;
            text-transform: uppercase;
            letter-spacing: 0.03em;
            border-bottom: 1px solid #f0f0f0;
        }

        .template-dropdown-empty {
            padding: 0.75rem;
            font-size: 0.8rem;
            color: #6c757d;
            text-align: center;
        }

        .time-slot-buttons {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
        }

        .time-slot-btn {
            padding: 0.5rem 1rem;
            border: none;
            border-radius: 4px;
            background: #6B9080;
            color: white;
            font-size: 0.85rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.15s;
        }

        .time-slot-btn:hover {
            background: #5a7d6e;
        }

        .time-slot-btn.selected {
            background: #4caf50;
            box-shadow: 0 0 0 2px #fff, 0 0 0 4px #4caf50;
        }

        .slide-panel {
            position: fixed;
            top: 0;
            right: 0;
            width: 100%;
            max-width: 400px;
            height: 100%;
            background: white;
            box-shadow: -4px 0 20px rgba(0, 0, 0, 0.15);
            transform: translateX(100%);
            transition: transform 0.3s ease;
            z-index: 1001;
            display: flex;
            flex-direction: column;
            overscroll-behavior: contain;
        }

        .slide-panel.active {
            transform: translateX(0);
        }

        .panel-header {
            padding: 1.25rem;
            border-bottom: 1px solid #e9ecef;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .filter-summary {
            padding: 0.4rem 1.25rem;
            background: #f8f9fa;
            border-bottom: 1px solid #e9ecef;
            font-size: 0.75rem;
            color: #6c757d;
            display: none;
        }

        .filter-summary.active {
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        /* Hide filter summary when panel is collapsed */
        .panel.collapsed .filter-summary {
            display: none !important;
        }

        .filter-summary-text {
            flex: 1;
            font-weight: 400;
        }

        .filter-summary .clear-filters-link {
            color: #6c757d;
            text-decoration: none;
            cursor: pointer;
            font-weight: 400;
            margin-left: 0.5rem;
            font-size: 0.75rem;
        }

        .filter-summary .clear-filters-link:hover {
            text-decoration: underline;
        }

        .filter-info-wrapper {
            position: relative;
            display: inline-block;
        }

        .filter-info-tooltip {
            visibility: hidden;
            position: fixed;
            bottom: auto;
            top: auto;
            left: 50%;
            transform: translateX(-50%);
            background: #333;
            color: white;
            padding: 0.5rem 0.75rem;
            border-radius: 4px;
            font-size: 0.7rem;
            white-space: nowrap;
            z-index: 10000;
            opacity: 0;
            transition: opacity 0.2s;
            margin-top: 0.5rem;
        }

        .filter-info-tooltip::before {
            content: "";
            position: absolute;
            bottom: 100%;
            left: 50%;
            margin-left: -5px;
            border-width: 5px;
            border-style: solid;
            border-color: transparent transparent #333 transparent;
        }

        .filter-info-wrapper:hover .filter-info-tooltip {
            visibility: visible;
            opacity: 1;
        }

        /* General tooltip system */
        .has-tooltip {
            position: relative;
            cursor: help;
        }

        .has-tooltip .custom-tooltip {
            visibility: hidden;
            position: absolute;
            top: 100%;
            left: 50%;
            transform: translateX(-50%);
            margin-top: 5px;
            padding: 0.4rem 0.6rem;
            background: #333;
            color: white;
            font-size: 0.7rem;
            white-space: nowrap;
            border-radius: 4px;
            z-index: 10000;
            opacity: 0;
            transition: opacity 0.2s;
            pointer-events: none;
            text-transform: none;
        }

        .has-tooltip .custom-tooltip::after {
            content: "";
            position: absolute;
            bottom: 100%;
            left: 50%;
            margin-left: -5px;
            border-width: 5px;
            border-style: solid;
            border-color: transparent transparent #333 transparent;
        }

        .has-tooltip:hover .custom-tooltip {
            visibility: visible;
            opacity: 1;
        }

        /* Position tooltips below icons in wider dropdowns */
        .settings-section-header .has-tooltip .custom-tooltip,
        .filter-section-title .has-tooltip .custom-tooltip {
            position: fixed;
            left: auto;
            top: auto;
            transform: none;
            margin-top: 0;
            margin-left: 0;
            white-space: nowrap;
            max-width: none;
            z-index: 99999;
        }

        .settings-section-header .has-tooltip .custom-tooltip::after,
        .filter-section-title .has-tooltip .custom-tooltip::after {
            left: 10px;
            right: auto;
            top: auto;
            bottom: 100%;
            transform: none;
            margin-top: 0;
            margin-bottom: -5px;
            border-color: transparent transparent #333 transparent;
        }

        /* Auto-Abandon tooltip styling */
        .auto-abandon-tooltip {
            white-space: nowrap !important;
        }

        .panel-close {
            background: none;
            border: none;
            font-size: 1.5rem;
            color: #6c757d;
            cursor: pointer;
            padding: 0;
            line-height: 1;
        }

        .panel-close:hover {
            color: #212529;
        }

        .panel-body {
            flex: 1;
            padding: 1.25rem;
            overflow-y: auto;
        }

        .panel-title-input {
            width: 100%;
            font-size: 1.25rem;
            font-weight: 500;
            border: none;
            padding: 0.5rem 0;
            margin-bottom: 0.25rem;
            outline: none;
            border-bottom: 1px solid #e9ecef;
            resize: none;
            overflow: hidden;
            min-height: 2rem;
            font-family: inherit;
            line-height: 1.4;
            transition: border-color 0.15s;
        }

        .panel-title-input:hover {
            border-bottom-color: #adb5bd;
        }

        .panel-title-input:focus {
            border-bottom-color: #0d6efd;
        }

        .panel-details-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 0.5rem;
        }

        .panel-details-label {
            font-size: 0.875rem;
            color: #6c757d;
            display: flex;
            align-items: center;
            gap: 0.4rem;
        }

        .markdown-help-icon {
            color: #adb5bd;
            cursor: help;
            font-size: 0.8rem;
            position: relative;
        }

        .markdown-help-icon:hover {
            color: #6c757d;
        }

        .markdown-help-tooltip {
            display: none;
            position: absolute;
            top: calc(100% + 8px);
            left: 0;
            background: #fff;
            color: #666;
            padding: 0.6rem 0.75rem;
            border-radius: 4px;
            font-size: 0.7rem;
            line-height: 1.6;
            white-space: nowrap;
            z-index: 1000;
            box-shadow: 0 2px 8px rgba(0,0,0,0.12);
            border: 1px solid #e9ecef;
        }

        .markdown-help-tooltip::before {
            content: '';
            position: absolute;
            bottom: 100%;
            left: 12px;
            border: 6px solid transparent;
            border-bottom-color: #e9ecef;
        }

        .markdown-help-tooltip::after {
            content: '';
            position: absolute;
            bottom: 100%;
            left: 13px;
            border: 5px solid transparent;
            border-bottom-color: #fff;
        }

        .markdown-help-icon:hover .markdown-help-tooltip {
            display: block;
        }

        .markdown-help-tooltip strong {
            color: #495057;
            font-weight: 600;
        }

        .markdown-help-tooltip code {
            background: #f5f5f5;
            color: #6B9080;
            padding: 0 0.2rem;
            border-radius: 2px;
            font-family: monospace;
            font-size: 0.65rem;
        }

        .markdown-mode-toggle {
            display: flex;
            background: #e9ecef;
            border-radius: 4px;
            overflow: hidden;
            font-size: 0.75rem;
        }

        .markdown-mode-btn {
            padding: 0.25rem 0.5rem;
            border: none;
            background: transparent;
            cursor: pointer;
            color: #6c757d;
            transition: all 0.2s;
        }

        .markdown-mode-btn.active {
            background: #0d6efd;
            color: white;
        }

        .markdown-mode-btn:hover:not(.active) {
            background: #dee2e6;
        }

        .panel-details-container {
            position: relative;
        }

        .panel-details-input {
            width: 100%;
            min-height: 450px;
            border: 1px solid #dee2e6;
            border-radius: 8px;
            padding: 0.75rem;
            font-size: 1rem;
            resize: vertical;
            outline: none;
            font-family: inherit;
        }

        .panel-details-input:focus {
            border-color: #0d6efd;
        }

        .panel-details-preview {
            width: 100%;
            min-height: 450px;
            border: 1px solid #dee2e6;
            border-radius: 8px;
            padding: 0.75rem;
            font-size: 1rem;
            background: #fafbfc;
            cursor: text;
            overflow-y: auto;
        }

        .panel-details-preview:empty::before {
            content: 'Add details...';
            color: #6c757d;
        }

        .panel-details-preview h1,
        .panel-details-preview h2,
        .panel-details-preview h3 {
            margin-top: 0.5rem;
            margin-bottom: 0.5rem;
        }

        .panel-details-preview h1 { font-size: 1.5rem; }
        .panel-details-preview h2 { font-size: 1.25rem; }
        .panel-details-preview h3 { font-size: 1.1rem; }

        .panel-details-preview p {
            margin-bottom: 0.5rem;
        }

        .panel-details-preview ul,
        .panel-details-preview ol {
            margin-bottom: 0.5rem;
            padding-left: 1.5rem;
        }

        .panel-details-preview code {
            background: #e9ecef;
            padding: 0.1rem 0.3rem;
            border-radius: 3px;
            font-size: 0.9em;
        }

        .panel-details-preview pre {
            background: #e9ecef;
            padding: 0.75rem;
            border-radius: 6px;
            overflow-x: auto;
        }

        .panel-details-preview pre code {
            background: none;
            padding: 0;
        }

        .panel-details-preview blockquote {
            border-left: 3px solid #dee2e6;
            padding-left: 0.75rem;
            margin-left: 0;
            color: #6c757d;
        }

        .panel-details-preview a {
            color: #0d6efd;
        }

        .panel-footer {
            padding: 1rem 1.25rem;
            border-top: 1px solid #e9ecef;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .panel-footer-left {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .save-close-btn {
            background: #495057;
            color: white;
            border: none;
            padding: 0.4rem 0.75rem;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.85rem;
            font-weight: 500;
            display: flex;
            align-items: center;
            gap: 0.35rem;
            transition: background 0.15s;
        }

        .save-close-btn:hover {
            background: #343a40;
        }

        .critical-toggle {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            cursor: pointer;
            user-select: none;
        }

        .critical-toggle input {
            width: 18px;
            height: 18px;
            cursor: pointer;
        }

        .critical-toggle label {
            cursor: pointer;
            font-weight: 500;
        }

        .mark-done-btn {
            background: #28a745;
            color: white;
            border: none;
            padding: 0.4rem 0.75rem;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.85rem;
            font-weight: 500;
            display: flex;
            align-items: center;
            gap: 0.35rem;
        }

        .mark-done-btn:hover {
            background: #218838;
        }

        .mark-done-btn.is-done {
            background: #6c757d;
        }

        .mark-done-btn.is-done:hover {
            background: #5a6268;
        }

        .delete-btn {
            background: none;
            border: none;
            color: #6c757d;
            cursor: pointer;
            padding: 0.5rem;
            font-size: 1.25rem;
        }

        .delete-btn:hover {
            color: #dc3545;
        }

        /* Task Panel Sections */
        .task-panel-section {
            border-bottom: 1px solid #f0f0f0;
        }

        .task-panel-section:last-child {
            border-bottom: none;
        }

        .task-panel-section-header {
            font-size: 0.7rem;
            font-weight: 600;
            color: #6B9080;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            padding: 0.75rem 1rem 0.5rem;
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 0.5rem;
        }

        .task-panel-section-header > span {
            display: flex;
            align-items: center;
            gap: 0.4rem;
        }

        .task-panel-section-actions {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .task-panel-section-content {
            padding: 0 1rem 0.75rem;
        }

        /* Task Properties Grid */
        .task-properties-grid {
            display: flex;
            flex-direction: column;
            gap: 0;
            padding-top: 7px;
        }

        .task-property-row {
            display: flex;
            align-items: center;
            gap: 1rem;
            padding: 0.85rem 0;
            border-bottom: 1px solid #f0f0f0;
        }

        .task-property-row:last-child {
            border-bottom: none;
            padding-bottom: 0;
        }

        .task-property-row:first-child {
            padding-top: 0;
        }

        .task-property-label {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            color: #6c757d;
            font-size: 0.85rem;
            width: 140px;
            flex-shrink: 0;
            font-weight: 500;
        }

        .task-property-label i {
            font-size: 0.9rem;
            color: #adb5bd;
        }

        .task-property-value {
            flex: 1;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .task-property-tags {
            align-items: flex-start;
        }

        .task-property-deadline {
            align-items: flex-start;
        }

        .task-property-deadline .task-property-label {
            padding-top: 0.05rem;
        }

        .task-property-deadline .task-property-value {
            flex-direction: column;
            align-items: stretch;
            gap: 0.5rem;
            width: 100%;
        }

        .task-property-scheduled {
            align-items: flex-start;
        }

        .task-property-scheduled .task-property-label {
            padding-top: 0.05rem;
        }

        .task-property-scheduled .task-property-value {
            align-items: stretch;
            flex-direction: column;
            gap: 0.5rem;
            width: 100%;
        }


        /* New Property Card Design */
        .property-card {
            background: #f8f9fa;
            border-radius: 8px;
            padding: 1rem;
            border: 1px solid #e9ecef;
        }

        .property-card-header {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-weight: 600;
            font-size: 0.9rem;
            color: #495057;
            margin-bottom: 0.75rem;
        }

        .property-card-header i {
            font-size: 1rem;
            color: #6c757d;
        }

        .property-card-body {
            display: flex;
            flex-direction: column;
        }

        /* Scheduled Dates (read-only) */
        .scheduled-container {
            display: flex;
            flex-wrap: wrap;
            gap: 0.35rem;
        }

        .scheduled-date-chip {
            display: inline-flex;
            align-items: center;
            padding: 0.35rem 0.65rem;
            background: #f0f0f0;
            color: #000;
            border-radius: 12px;
            font-size: 0.8rem;
            font-weight: 500;
        }

        .scheduled-date-chip.is-today {
            background: #f0f0f0;
            color: #000;
        }

        /* Ensure scheduled section aligns with other controls */
        #panel-scheduled-section .deadline-presets {
            margin-left: 0;
            padding-left: 0;
        }

        #panel-scheduled-dates {
            display: flex;
            gap: 0.35rem;
            flex-wrap: wrap;
        }

        .deadline-presets {
            display: flex;
            gap: 0.35rem;
            flex-wrap: wrap;
        }

        .panel-no-scheduled-dates {
            color: #9e9e9e;
            font-size: 0.85rem;
            font-style: italic;
        }

        /* Toggle Switch */
        .task-toggle {
            position: relative;
            display: inline-block;
            width: 40px;
            height: 22px;
        }

        .task-toggle input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .task-toggle-slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            transition: 0.3s;
            border-radius: 22px;
        }

        .task-toggle-slider:before {
            position: absolute;
            content: "";
            height: 16px;
            width: 16px;
            left: 3px;
            bottom: 3px;
            background-color: white;
            transition: 0.3s;
            border-radius: 50%;
        }

        .task-toggle input:checked + .task-toggle-slider {
            background-color: #dc3545;
        }

        .task-toggle input:checked + .task-toggle-slider:before {
            transform: translateX(18px);
        }

        /* Updated panel title input for new layout */
        .task-panel-section .panel-title-input {
            font-size: 1.1rem;
            border: 1px solid #e9ecef;
            border-radius: 6px;
            padding: 0.5rem 0.75rem;
            margin-bottom: 0;
            background: #fafbfc;
        }

        .task-panel-section .panel-title-input:focus {
            background: white;
            border-color: #6B9080;
        }

        /* Updated details container for new layout */
        .task-panel-section .panel-details-container {
            border: 1px solid #e9ecef;
            border-radius: 6px;
            background: #fafbfc;
            overflow: hidden;
        }

        .task-panel-section .panel-details-input {
            border: none;
            background: transparent;
            min-height: 150px;
            padding: 0.75rem;
        }

        .task-panel-section .panel-details-input:focus {
            background: white;
        }

        .task-panel-section .panel-details-preview {
            padding: 0.75rem;
            background: white;
        }

        /* Deadline presets in properties */
        .task-property-deadline .deadline-presets {
            gap: 0.5rem;
        }

        /* Compact template button */
        .task-panel-section .template-dropdown-btn {
            padding: 0.2rem 0.4rem;
            font-size: 0.75rem;
        }

        .task-panel-section .template-dropdown-btn span,
        .task-panel-section .template-dropdown-btn .bi-chevron-down {
            display: none;
        }

        /* Empty state */
        .empty-state {
            text-align: center;
            padding: 3rem 1rem;
            color: #6c757d;
        }

        .empty-state i {
            font-size: 3rem;
            margin-bottom: 1rem;
            opacity: 0.5;
        }

        /* Sidebar icons */
        div.sidebar-icons {
            position: fixed !important;
            top: 1.5rem !important;
            left: 1.5rem !important;
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
            z-index: 10000 !important;
        }

        .sidebar-icon {
            color: #adb5bd;
            cursor: pointer;
            font-size: 1.25rem;
            transition: color 0.2s;
        }

        .sidebar-icon:hover {
            color: #6c757d;
        }

        .sidebar-icon.active {
            color: #6B9080;
        }

        /* Deadline Warning Icon */
        .deadline-warning-icon {
            color: #adb5bd;
            cursor: pointer;
            font-size: 1.25rem;
            transition: color 0.2s;
        }

        .deadline-warning-icon:hover {
            color: #6c757d;
        }

        .deadline-warning-icon.has-warnings {
            animation: fadeToYellow 2s ease-in-out infinite;
        }

        .deadline-warning-icon.has-overdue {
            animation: fadeToRed 2s ease-in-out infinite;
        }

        @keyframes fadeToRed {
            0%, 100% {
                color: #adb5bd;
            }
            50% {
                color: #dc3545;
            }
        }

        @keyframes fadeToYellow {
            0%, 100% {
                color: #adb5bd;
            }
            50% {
                color: #ffc107;
            }
        }

        .deadline-warning-icon.has-near-abandoned {
            animation: fadeToOrange 2s ease-in-out infinite;
        }

        @keyframes fadeToOrange {
            0%, 100% {
                color: #adb5bd;
            }
            50% {
                color: #fd7e14;
            }
        }

        /* Deadline Warning Dropdown */
        .deadline-dropdown {
            position: fixed;
            top: 1.5rem;
            left: 3.5rem;
            background: white;
            border-radius: 10px;
            box-shadow: 0 4px 24px rgba(0,0,0,0.12);
            padding: 0;
            min-width: 320px;
            max-width: 360px;
            z-index: 1100;
            display: none;
        }

        .deadline-dropdown.active {
            display: block;
        }

        .deadline-dropdown-header {
            background: linear-gradient(135deg, #6B9080 0%, #5a7a6a 100%);
            color: white;
            padding: 0.75rem 1rem;
            font-weight: 600;
            font-size: 0.9rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            border-radius: 10px 10px 0 0;
        }

        .deadline-dropdown-body {
            padding: 0.75rem 1rem;
            max-height: 50vh;
            overflow-y: auto;
            scrollbar-width: thin;
        }

        .deadline-dropdown-body::-webkit-scrollbar {
            width: 6px;
        }

        .deadline-dropdown-body::-webkit-scrollbar-track {
            background: #f1f1f1;
            border-radius: 3px;
        }

        .deadline-dropdown-body::-webkit-scrollbar-thumb {
            background: #ccc;
            border-radius: 3px;
        }

        .deadline-dropdown-body::-webkit-scrollbar-thumb:hover {
            background: #aaa;
        }

        .deadline-section {
            margin-bottom: 1rem;
        }

        .deadline-section:last-child {
            margin-bottom: 0;
        }

        .deadline-section-title {
            font-size: 0.7rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            margin-bottom: 0.5rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .deadline-section-title.critical {
            color: #6f42c1;  /* Purple for critical */
        }

        .deadline-section-title.overdue {
            color: #dc3545;  /* Red for overdue */
        }

        .deadline-section-title.due-soon {
            color: #e6a000;
        }

        .deadline-section-title.near-abandoned {
            color: #fd7e14;
        }

        .deadline-section-title .settings-info-icon {
            position: relative;
            margin-left: auto;
            font-size: 0.75rem;
            color: #adb5bd;
            cursor: help;
        }

        .deadline-section-title .settings-info-icon:hover {
            color: #6c757d;
        }

        /* Critical items use same styling as other task items */

        .deadline-show-more {
            font-size: 0.8rem;
            color: #6B9080;
            cursor: pointer;
            padding: 0.4rem 0.5rem;
            text-align: center;
            background: #f0f4f2;
            border-radius: 5px;
            transition: background 0.15s;
        }

        .deadline-show-more:hover {
            background: #e5eae7;
            color: #5a7a6d;
        }

        .deadline-task-item.near-abandoned {
            border-left: 3px solid #fd7e14;
        }

        .deadline-task-item {
            display: flex;
            align-items: flex-start;
            justify-content: space-between;
            padding: 0.5rem;
            background: #f8f9fa;
            border-radius: 6px;
            margin-bottom: 0.5rem;
            gap: 0.5rem;
        }

        .deadline-task-item:last-child {
            margin-bottom: 0;
        }

        .deadline-task-item.dismissed {
            opacity: 0.6;
        }

        .deadline-task-info {
            flex: 1;
            min-width: 0;
            cursor: pointer;
        }

        .deadline-task-title {
            font-size: 0.85rem;
            font-weight: 500;
            color: #212529;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .deadline-task-date {
            font-size: 0.75rem;
            color: #6c757d;
            margin-top: 0.1rem;
        }

        .deadline-dismiss-btn {
            background: none;
            border: none;
            color: #6c757d;
            cursor: pointer;
            padding: 0.25rem;
            font-size: 0.85rem;
            flex-shrink: 0;
            transition: color 0.2s;
        }

        .deadline-dismiss-btn:hover {
            color: #212529;
        }

        .deadline-dismiss-btn.dismissed {
            color: #28a745;
        }

        .deadline-empty-state {
            text-align: center;
            padding: 1.5rem 1rem;
            color: #6c757d;
        }

        .deadline-empty-state i {
            font-size: 2rem;
            margin-bottom: 0.5rem;
            display: block;
        }

        /* Deadline Section in Panel */
        .panel-deadline-section {
            margin-top: 1rem;
            padding-top: 1rem;
            border-top: 1px solid #e9ecef;
        }

        .panel-deadline-label {
            font-size: 0.8rem;
            color: #6c757d;
            display: block;
            margin-bottom: 0.5rem;
        }

        .panel-deadline-container {
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
        }

        .deadline-presets {
            display: flex;
            flex-wrap: wrap;
            gap: 0.35rem;
        }

        .deadline-preset-btn {
            padding: 0.25rem 0.55rem;
            border: 1px solid #dee2e6;
            border-radius: 12px;
            background: white;
            color: #6c757d;
            font-size: 0.8rem;
            cursor: pointer;
            transition: all 0.15s;
            white-space: nowrap;
        }

        .deadline-preset-btn:hover {
            background: #f8f9fa;
            border-color: #6B9080;
            color: #6B9080;
        }

        .deadline-preset-btn.active {
            background: #6B9080;
            border-color: #6B9080;
            color: white;
        }

        .deadline-date-input {
            padding: 0.35rem 0.5rem;
            border: 1px solid #dee2e6;
            border-radius: 6px;
            font-size: 0.85rem;
            flex: 1;
        }

        .deadline-date-input:focus {
            outline: none;
            border-color: #6B9080;
        }

        .deadline-clear-btn {
            display: inline-flex;
            align-items: center;
            gap: 0.3rem;
            padding: 0.3rem 0.6rem;
            border: 1px dashed #dee2e6;
            border-radius: 12px;
            background: transparent;
            color: #6c757d;
            font-size: 0.8rem;
            cursor: pointer;
            transition: all 0.15s;
        }

        .deadline-clear-btn:hover {
            background: rgba(220, 53, 69, 0.05);
            border-style: solid;
            border-color: #dc3545;
            color: #dc3545;
        }

        .deadline-change-btn {
            display: inline-flex;
            align-items: center;
            gap: 0.3rem;
            padding: 0.3rem 0.6rem;
            border: 1px dashed #dee2e6;
            border-radius: 12px;
            background: transparent;
            color: #6c757d;
            font-size: 0.8rem;
            cursor: pointer;
            transition: all 0.15s;
            white-space: nowrap;
        }

        .deadline-change-btn:hover {
            background: rgba(107, 144, 128, 0.05);
            border-style: solid;
            border-color: #6B9080;
            color: #6B9080;
        }

        .deadline-status {
            font-size: 0.8rem;
            padding: 0.35rem 0.6rem;
            border-radius: 12px;
            display: inline-flex;
            align-items: center;
            font-weight: 500;
        }

        .deadline-status.overdue {
            background: #f0f0f0;
            color: #000;
        }

        .deadline-status.due-soon {
            background: #f0f0f0;
            color: #000;
        }

        .deadline-status.on-track {
            background: #f0f0f0;
            color: #000;
        }

        /* Filter dropdown */
        .filter-dropdown {
            position: fixed;
            top: 1.5rem;
            left: 3.5rem;
            background: white;
            border-radius: 10px;
            box-shadow: 0 4px 24px rgba(0,0,0,0.12);
            padding: 0;
            min-width: 240px;
            max-width: 260px;
            z-index: 1100;
            display: none;
            overflow: visible;
        }

        .filter-dropdown.active {
            display: block;
        }

        .filter-dropdown-header {
            background: linear-gradient(135deg, #6B9080 0%, #5a7a6a 100%);
            color: white;
            padding: 0.75rem 1rem;
            font-weight: 600;
            font-size: 0.9rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            border-radius: 10px 10px 0 0;
        }

        .filter-dropdown-body {
            padding: 0.75rem 1rem;
            max-height: 60vh;
            overflow-y: auto;
            overflow-x: visible;
            scrollbar-width: thin;
        }

        .filter-dropdown-body::-webkit-scrollbar {
            width: 6px;
        }

        .filter-dropdown-body::-webkit-scrollbar-track {
            background: #f1f1f1;
            border-radius: 3px;
        }

        .filter-dropdown-body::-webkit-scrollbar-thumb {
            background: #ccc;
            border-radius: 3px;
        }

        .filter-dropdown-body::-webkit-scrollbar-thumb:hover {
            background: #aaa;
        }

        .filter-section {
            margin-bottom: 0.85rem;
            padding-bottom: 0.85rem;
            border-bottom: 1px solid #f0f0f0;
            overflow: visible;
        }

        .filter-section:last-child {
            margin-bottom: 0;
            padding-bottom: 0;
            border-bottom: none;
        }

        .filter-section-title {
            display: flex;
            align-items: center;
            gap: 0.4rem;
            font-size: 0.7rem;
            font-weight: 600;
            color: #6B9080;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            margin-bottom: 0.5rem;
            cursor: pointer;
            user-select: none;
            position: relative;
        }

        .filter-section-title:hover {
            color: #5a7a6a;
        }

        .filter-section-title i.collapse-icon {
            margin-left: auto;
            font-size: 0.7rem;
            transition: transform 0.2s;
        }

        .filter-section.collapsed .filter-section-title i.collapse-icon {
            transform: rotate(-90deg);
        }

        .filter-section-content {
            overflow: hidden;
            max-height: 500px;
            transition: max-height 0.3s ease-out, opacity 0.2s ease-out;
        }

        .filter-section.collapsed .filter-section-content {
            max-height: 0;
            opacity: 0;
        }

        .layout-mode-btn {
            width: 100%;
            padding: 0.6rem 1rem;
            background: white;
            border: 1px solid #dee2e6;
            border-radius: 6px;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 0.9rem;
            color: #495057;
        }

        .layout-mode-btn:hover {
            background: #f8f9fa;
            border-color: #6B9080;
            color: #6B9080;
        }

        .layout-mode-btn i {
            font-size: 1rem;
        }

        .filter-section-title .settings-info-icon,
        .saved-views-header .settings-info-icon {
            position: relative;
            margin-left: auto;
            font-size: 0.75rem;
            color: #adb5bd;
            cursor: help;
        }

        .filter-section-title .settings-info-icon:hover,
        .saved-views-header .settings-info-icon:hover {
            color: #6c757d;
        }

        .filter-options-row {
            display: flex;
            gap: 0.75rem;
            flex-wrap: wrap;
        }

        .filter-option {
            display: flex;
            align-items: center;
            gap: 0.4rem;
            padding: 0.3rem 0;
            cursor: pointer;
            font-size: 0.85rem;
            color: #495057;
        }

        .filter-option:hover {
            color: #6B9080;
        }

        .filter-option input[type="checkbox"],
        .filter-option input[type="radio"] {
            width: 14px;
            height: 14px;
            cursor: pointer;
            accent-color: #6B9080;
            margin: 0;
        }

        .filter-option .context-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            flex-shrink: 0;
        }

        .filter-option-inline {
            display: inline-flex;
            align-items: center;
            gap: 0.35rem;
            padding: 0.25rem 0.5rem;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.8rem;
            color: #495057;
            background: #f8f9fa;
            border: 1px solid transparent;
            transition: all 0.15s;
        }

        .filter-option-inline:hover {
            border-color: #6B9080;
            color: #6B9080;
        }

        .filter-option-inline.checked {
            background: #e8f0ed;
            border-color: #6B9080;
            color: #6B9080;
        }

        .filter-option-inline input {
            display: none;
        }

        .filter-clear {
            width: 100%;
            padding: 0.5rem;
            border: none;
            background: #f8f9fa;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.8rem;
            color: #6c757d;
            transition: all 0.15s;
            margin-top: 0.5rem;
        }

        .filter-clear:hover {
            background: #e9ecef;
            color: #495057;
        }

        /* Saved Views section */
        .saved-views-section {
            margin-bottom: 0.85rem;
            padding-bottom: 0.85rem;
            border-bottom: 1px solid #f0f0f0;
        }

        .saved-views-header {
            display: flex;
            align-items: center;
            gap: 0.4rem;
            margin-bottom: 0.5rem;
            cursor: pointer;
            user-select: none;
        }

        .saved-views-header:hover {
            color: #5a7a6a;
        }

        .saved-views-header i.collapse-icon {
            margin-left: auto;
            font-size: 0.7rem;
            transition: transform 0.2s;
        }

        .saved-views-section.collapsed .saved-views-header i.collapse-icon {
            transform: rotate(-90deg);
        }

        .saved-views-content {
            overflow: hidden;
            max-height: 300px;
            transition: max-height 0.3s ease-out, opacity 0.2s ease-out;
        }

        .saved-views-section.collapsed .saved-views-content {
            max-height: 0;
            opacity: 0;
        }

        .saved-views-title {
            font-size: 0.7rem;
            font-weight: 600;
            color: #6B9080;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .saved-views-list {
            display: flex;
            flex-direction: column;
            gap: 0.2rem;
            max-height: 120px;
            overflow-y: auto;
        }

        .saved-view-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0.4rem 0.5rem;
            border-radius: 5px;
            cursor: pointer;
            font-size: 0.8rem;
            color: #495057;
            transition: all 0.15s;
            background: white;
            border: 1px solid #e9ecef;
        }

        .saved-view-item:hover {
            background: #e8f0ed;
            border-color: #6B9080;
            color: #6B9080;
        }

        .saved-view-item .view-name {
            flex: 1;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .saved-view-item .view-delete {
            padding: 0.15rem 0.35rem;
            color: #adb5bd;
            cursor: pointer;
            transition: all 0.15s;
            font-size: 0.8rem;
            border-radius: 3px;
        }

        .saved-view-item .view-delete:hover {
            color: #dc3545;
            background: rgba(220, 53, 69, 0.1);
        }

        .saved-view-item.active {
            background: #e8f0ed;
            border-color: #6B9080;
            color: #6B9080;
            font-weight: 500;
        }

        .saved-view-item .view-check {
            display: none;
            color: #6B9080;
            margin-right: 0.35rem;
            font-size: 0.75rem;
        }

        .saved-view-item.active .view-check {
            display: inline;
        }

        .no-saved-views {
            font-size: 0.75rem;
            color: #999;
            text-align: center;
            padding: 0.4rem;
            font-style: italic;
        }

        .save-view-btn {
            width: 100%;
            padding: 0.35rem;
            margin-top: 0.5rem;
            border: 1px dashed #adb5bd;
            background: white;
            border-radius: 5px;
            cursor: pointer;
            font-size: 0.75rem;
            color: #6c757d;
            transition: all 0.15s;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.3rem;
        }

        .save-view-btn:hover {
            border-color: #6B9080;
            color: #6B9080;
            background: #f8f9fa;
        }

        .no-saved-views {
            color: #adb5bd;
            font-size: 0.75rem;
            font-style: italic;
            padding: 0.25rem 0;
            text-align: center;
        }

        /* Tags filter */
        .filter-tags-search {
            width: 100%;
            padding: 0.35rem 0.5rem;
            margin-bottom: 0.5rem;
            border: 1px solid #e9ecef;
            border-radius: 5px;
            font-size: 0.8rem;
            transition: border-color 0.15s;
        }

        .filter-tags-search:focus {
            outline: none;
            border-color: #6B9080;
        }

        .filter-tags-list {
            display: flex;
            flex-direction: column;
            gap: 0.25rem;
        }

        .filter-clear:hover {
            background: #f8f9fa;
            border-color: #6B9080;
            color: #6B9080;
        }

        .filter-badge {
            position: absolute;
            top: 0px;
            right: 0px;
            background: #6B9080;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            display: none;
        }

        /* Settings popup (dropdown style) */
        .settings-dropdown {
            position: fixed;
            top: 1.5rem;
            left: 3.5rem;
            background: white;
            border-radius: 10px;
            box-shadow: 0 4px 24px rgba(0,0,0,0.12);
            padding: 0;
            min-width: 240px;
            max-width: 260px;
            z-index: 1100;
            display: none;
            overflow: visible;
        }

        .settings-dropdown.active {
            display: block;
        }

        .settings-dropdown-header {
            background: linear-gradient(135deg, #6B9080 0%, #5a7a6a 100%);
            color: white;
            padding: 0.75rem 1rem;
            font-weight: 600;
            font-size: 0.9rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            border-radius: 10px 10px 0 0;
        }

        .settings-dropdown-body {
            padding: 0.75rem 0;
            max-height: 60vh;
            overflow-y: auto;
            overflow-x: visible;
            scrollbar-width: thin;
        }

        .settings-dropdown-body::-webkit-scrollbar {
            width: 6px;
        }

        .settings-dropdown-body::-webkit-scrollbar-track {
            background: #f1f1f1;
            border-radius: 3px;
        }

        .settings-dropdown-body::-webkit-scrollbar-thumb {
            background: #ccc;
            border-radius: 3px;
        }

        .settings-dropdown-body::-webkit-scrollbar-thumb:hover {
            background: #aaa;
        }

        .context-list {
            list-style: none;
            padding: 0;
            margin: 0;
        }

        .context-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0.75rem 1.25rem;
            border-bottom: 1px solid #e9ecef;
        }

        .context-item:hover {
            background-color: #f8f9fa;
        }

        .context-name {
            font-size: 1rem;
            cursor: pointer;
            padding: 0.125rem 0.25rem;
            border-radius: 4px;
            transition: background 0.15s;
        }

        .context-name:hover {
            background: #e9ecef;
        }

        .context-name-input {
            font-size: 1rem;
            padding: 0.125rem 0.25rem;
            border: 1px solid #6B9080;
            border-radius: 4px;
            outline: none;
            width: 120px;
        }

        .context-delete {
            background: none;
            border: none;
            color: #adb5bd;
            cursor: pointer;
            padding: 0.25rem;
            font-size: 1rem;
            opacity: 0;
            transition: opacity 0.15s, color 0.15s;
        }

        .context-item:hover .context-delete {
            opacity: 1;
        }

        .context-delete:hover {
            color: #dc3545;
        }

        .context-input-container {
            padding: 1rem 1.25rem;
            border-bottom: 1px solid #e9ecef;
        }

        #new-context-input {
            width: 100%;
            padding: 0.5rem 0.75rem;
            border: 1px solid #dee2e6;
            border-radius: 6px;
            font-size: 0.95rem;
            outline: none;
        }

        #new-context-input:focus {
            border-color: #0d6efd;
        }

        /* Context dropdown in task panel */
        .panel-context-label {
            font-size: 0.875rem;
            color: #6c757d;
            margin-top: 1rem;
            margin-bottom: 0.5rem;
        }

        #panel-context {
            width: 100%;
            padding: 0.5rem 0.75rem;
            border: 1px solid #dee2e6;
            border-radius: 6px;
            font-size: 1rem;
            background: white;
            outline: none;
        }

        #panel-context:focus {
            border-color: #0d6efd;
        }

        /* Context badge on task item */
        .task-context-badge {
            font-size: 0.75rem;
            color: white;
            background: #6c757d;
            padding: 0.125rem 0.5rem;
            border-radius: 4px;
            margin-left: 0.5rem;
        }

        /* Context color indicator */
        .context-color-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 0.5rem;
            flex-shrink: 0;
        }

        .context-item-left {
            display: flex;
            align-items: center;
        }

        /* Settings section headers */
        .settings-section-header {
            font-size: 0.7rem;
            font-weight: 600;
            color: #6B9080;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            padding: 0.65rem 1rem 0.4rem;
            display: flex;
            align-items: center;
            gap: 0.4rem;
            cursor: pointer;
            user-select: none;
        }

        .settings-section-header:hover {
            color: #5a7a6a;
        }

        .settings-section-header i.collapse-icon {
            margin-left: auto;
            font-size: 0.7rem;
            transition: transform 0.2s;
        }

        .settings-section.collapsed .settings-section-header i.collapse-icon {
            transform: rotate(-90deg);
        }

        .settings-section-content {
            overflow: hidden;
            max-height: 1000px;
            transition: max-height 0.3s ease-out, opacity 0.2s ease-out;
        }

        .settings-section.collapsed .settings-section-content {
            max-height: 0;
            opacity: 0;
        }

        .settings-section-header i {
            font-size: 0.8rem;
        }

        .settings-section-header .settings-info-icon {
            position: relative;
            margin-left: auto;
            font-size: 0.75rem;
            color: #adb5bd;
            cursor: help;
        }

        .settings-section-header .settings-info-icon:hover {
            color: #6c757d;
        }

        .settings-info-tooltip {
            display: none;
            position: absolute;
            top: calc(100% + 8px);
            left: auto;
            right: 0;
            background: #fff;
            color: #666;
            padding: 0.5rem 0.65rem;
            border-radius: 4px;
            font-size: 0.65rem;
            font-weight: 400;
            text-transform: none;
            letter-spacing: normal;
            line-height: 1.5;
            white-space: nowrap;
            z-index: 2000;
            box-shadow: 0 2px 8px rgba(0,0,0,0.12);
            border: 1px solid #e9ecef;
        }

        .settings-info-tooltip::before {
            content: '';
            position: absolute;
            bottom: 100%;
            left: auto;
            right: 4px;
            border: 6px solid transparent;
            border-bottom-color: #e9ecef;
        }

        .settings-info-tooltip::after {
            content: '';
            position: absolute;
            bottom: 100%;
            left: auto;
            right: 5px;
            border: 5px solid transparent;
            border-bottom-color: #fff;
        }

        .settings-info-icon:hover .settings-info-tooltip {
            display: block;
        }

        .settings-section {
            border-bottom: 1px solid #f0f0f0;
            padding-bottom: 1rem;
            margin-bottom: 0.5rem;
            overflow: visible;
        }

        .settings-section:last-child {
            border-bottom: none;
            margin-bottom: 0;
        }

        .settings-row {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.5rem 1rem;
            font-size: 0.85rem;
        }

        .settings-toggle {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            cursor: pointer;
        }

        .settings-toggle input[type="checkbox"] {
            accent-color: #6B9080;
            width: 16px;
            height: 16px;
        }

        .abandoned-days-input {
            width: 60px;
            padding: 4px 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 0.85rem;
        }

        .abandoned-days-input:focus {
            outline: none;
            border-color: #6B9080;
        }

        .abandon-exclusion-row {
            flex-direction: column;
            align-items: flex-start !important;
            gap: 0.35rem !important;
            padding: 0.5rem 1rem;
        }

        .abandon-exclusion-row label {
            color: #888;
            font-size: 0.75rem;
            font-weight: 500;
            letter-spacing: 0.02em;
            white-space: nowrap;
        }

        .abandon-exclusion-chips {
            display: flex;
            flex-wrap: wrap;
            gap: 0.35rem;
        }

        .abandon-exclusion-chip {
            display: inline-flex;
            align-items: center;
            gap: 0.2rem;
            padding: 0.2rem 0.6rem;
            border-radius: 999px;
            font-size: 0.75rem;
            cursor: pointer;
            border: 1px solid #ddd;
            background: #fff;
            color: #6c757d;
            transition: all 0.15s ease;
            white-space: nowrap;
        }

        .abandon-exclusion-chip.active {
            background: #6B9080;
            color: #fff;
            border-color: #6B9080;
        }

        .abandon-exclusion-chip:hover {
            border-color: #6B9080;
        }

        /* Toast notification - reusable component */
        .toast-notification {
            position: fixed;
            bottom: 1.5rem;
            left: 1.5rem;
            background: #495057;
            color: white;
            padding: 0.75rem 1rem;
            border-radius: 8px;
            font-size: 0.85rem;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            z-index: 2000;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            opacity: 0;
            visibility: hidden;
            transform: translateY(10px);
            transition: opacity 0.5s ease, transform 0.5s ease, visibility 0s linear 0.5s;
            max-width: 320px;
        }

        .toast-notification.visible {
            opacity: 1;
            visibility: visible;
            transform: translateY(0);
            transition: opacity 0.5s ease, transform 0.5s ease, visibility 0s linear 0s;
        }

        .toast-notification .toast-icon {
            font-size: 1rem;
        }

        .toast-notification .toast-icon.warning {
            color: #fd7e14;
        }

        .toast-notification .toast-icon.success {
            color: #28a745;
        }

        .toast-notification .toast-icon.info {
            color: #17a2b8;
        }

        .toast-notification .toast-icon.error {
            color: #dc3545;
        }

        /* State list styles */
        .state-list {
            list-style: none;
            padding: 0 0.75rem;
            margin: 0;
            display: flex;
            flex-direction: column;
            gap: 0.25rem;
        }

        .state-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0.4rem 0.5rem;
            border-radius: 5px;
            background: #f8f9fa;
            border: 1px solid transparent;
            transition: all 0.15s;
        }

        .state-item:hover {
            background: #e8f0ed;
            border-color: #6B9080;
        }

        .state-name {
            font-size: 0.85rem;
            cursor: pointer;
            padding: 0.1rem 0.2rem;
            border-radius: 3px;
            transition: background 0.15s;
            color: #495057;
        }

        .state-name:hover {
            background: rgba(107, 144, 128, 0.15);
        }

        .state-name.no-edit {
            cursor: default;
        }

        .state-name.no-edit:hover {
            background: transparent;
        }

        .state-name.system-state-name {
            cursor: default;
        }

        .state-name.system-state-name:hover {
            background: transparent;
        }

        .state-name-input {
            font-size: 0.85rem;
            padding: 0.1rem 0.25rem;
            border: 1px solid #6B9080;
            border-radius: 3px;
            outline: none;
            width: 90px;
        }

        .state-terminal-btn {
            background: none;
            border: none;
            color: #adb5bd;
            cursor: pointer;
            padding: 0.2rem;
            font-size: 0.85rem;
            transition: color 0.15s;
        }

        .state-terminal-btn:hover {
            color: #6B9080;
        }

        .state-terminal-btn.active {
            color: #6B9080;
        }

        .state-item.terminal-state {
            background: #f0f7f4;
        }

        .state-delete {
            background: none;
            border: none;
            color: #adb5bd;
            cursor: pointer;
            padding: 0.2rem;
            font-size: 0.85rem;
            transition: color 0.15s;
        }

        .state-delete:hover {
            color: #dc3545;
        }

        .state-delete.disabled {
            color: #dee2e6;
            cursor: not-allowed;
        }

        .state-delete.disabled:hover {
            color: #dee2e6;
        }

        .state-icon-btn {
            background: white;
            border: 1px solid #e9ecef;
            border-radius: 3px;
            color: #6c757d;
            cursor: pointer;
            padding: 0.2rem 0.35rem;
            font-size: 0.8rem;
            transition: all 0.15s;
        }

        .state-icon-btn:hover {
            border-color: #6B9080;
            color: #6B9080;
            background: #e8f0ed;
        }

        .state-icon-btn i.bi-plus-circle-dotted {
            opacity: 0.5;
        }

        .icon-picker-popup {
            position: fixed;
            background: white;
            border-radius: 8px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.2);
            padding: 0.75rem;
            z-index: 1200;
            max-width: 280px;
            max-height: 300px;
            overflow-y: auto;
        }

        .icon-picker-grid {
            display: grid;
            grid-template-columns: repeat(6, 1fr);
            gap: 0.25rem;
        }

        .icon-picker-item {
            width: 36px;
            height: 36px;
            display: flex;
            align-items: center;
            justify-content: center;
            border: none;
            background: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 1.1rem;
            color: #333;
            transition: background 0.15s;
        }

        .icon-picker-item:hover {
            background: #e9ecef;
        }

        .icon-picker-item.selected {
            background: #6B9080;
            color: white;
        }

        .icon-picker-clear {
            width: 100%;
            padding: 0.5rem;
            margin-top: 0.5rem;
            border: 1px solid #dee2e6;
            background: white;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.8rem;
            color: #6c757d;
        }

        .icon-picker-clear:hover {
            background: #f8f9fa;
        }

        .icon-picker-custom {
            display: flex;
            gap: 0.5rem;
            margin-bottom: 0.75rem;
            padding-bottom: 0.75rem;
            border-bottom: 1px solid #e9ecef;
        }

        .icon-picker-custom input {
            flex: 1;
            padding: 0.4rem 0.6rem;
            border: 1px solid #dee2e6;
            border-radius: 4px;
            font-size: 0.85rem;
            outline: none;
        }

        .icon-picker-custom input:focus {
            border-color: #6B9080;
        }

        .icon-picker-custom button {
            padding: 0.4rem 0.75rem;
            background: #6B9080;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.85rem;
        }

        .icon-picker-custom button:hover {
            background: #5a7a6c;
        }

        .state-input-container {
            padding: 0.4rem 0.75rem 0.5rem;
        }

        #new-state-input {
            width: 100%;
            padding: 0.4rem 0.6rem;
            border: 1px solid #e9ecef;
            border-radius: 5px;
            font-size: 0.8rem;
            outline: none;
            transition: border-color 0.15s, box-shadow 0.15s;
        }

        #new-state-input:focus {
            border-color: #6B9080;
            box-shadow: 0 0 0 2px rgba(107, 144, 128, 0.15);
        }

        #new-state-input::placeholder {
            color: #adb5bd;
        }

        .state-item-left {
            display: flex;
            align-items: center;
            gap: 0.35rem;
        }

        .state-item-right {
            display: flex;
            align-items: center;
            gap: 0.35rem;
        }

        .state-drag-handle {
            cursor: grab;
            color: #bbb;
            padding: 0.1rem;
            font-size: 0.9rem;
        }

        .state-drag-handle:hover {
            color: #6B9080;
        }

        .state-item.dragging {
            opacity: 0.5;
            background: #e9ecef;
        }

        .state-item.drag-over-top {
            border-top: 2px solid #6B9080;
            margin-top: -1px;
        }

        .state-item.drag-over-bottom {
            border-bottom: 2px solid #6B9080;
            margin-bottom: -1px;
        }

        .state-list.drag-over-bottom {
            border-bottom: 2px solid #6B9080;
            padding-bottom: 8px;
        }

        .terminal-state .state-group-body {
            padding-top: 0.25rem;
        }

        .delete-completed-link {
            font-size: 0.65rem;
            color: #999;
            cursor: pointer;
            text-align: right;
            padding: 0 0.5rem 0.25rem 0;
        }

        .delete-completed-link:hover {
            color: #dc3545;
        }

        /* Panel header right container */
        .panel-header-right {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-left: auto;
        }

        .tasks-panel-wrapper {
            display: flex;
            flex-direction: column;
            flex: 1;
            min-width: 300px;
            height: 100%;
        }

        .tasks-panel-wrapper:has(.panel.minimized) {
            flex: 0 0 60px;
            min-width: 60px;
        }

        .state-terminal-checkbox-wrapper.disabled-terminal {
            cursor: help;
        }

        .state-terminal-checkbox-wrapper.disabled-terminal::after {
            content: attr(data-tooltip);
            position: absolute;
            left: 100%;
            top: 50%;
            transform: translateY(-50%);
            background: #333;
            color: white;
            padding: 0.4rem 0.6rem;
            border-radius: 4px;
            font-size: 0.75rem;
            white-space: nowrap;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.2s, visibility 0.2s;
            z-index: 1200;
            margin-left: 8px;
        }

        .state-terminal-checkbox-wrapper.disabled-terminal:hover::after {
            opacity: 1;
            visibility: visible;
        }

        /* Mobile adjustments */
        @media (max-width: 576px) {
            .container {
                padding: 1rem;
            }

            h1 {
                font-size: 1.5rem;
                margin-bottom: 1.5rem;
            }

            #new-task-input {
                font-size: 1.25rem;
                padding: 0.75rem 0;
            }

            .slide-panel {
                max-width: 100%;
            }

            .settings-dropdown {
                left: 1rem;
                min-width: 240px;
                max-width: calc(100% - 2rem);
            }

            .settings-gear {
                top: 1rem;
                left: 1rem;
            }

            .task-title {
                font-size: 1rem;
            }

            .kanban-board {
                flex-direction: column;
                gap: 1rem;
            }

            .kanban-column {
                min-width: 100%;
                max-height: 300px;
            }
        }

        /* Section Headers */
        .section-container {
            max-width: 1800px;
            margin: 0.25rem auto;
        }

        .section-container:first-of-type {
            margin-top: 2rem;
        }

        .section-header {
            padding: 0 3rem 0.5rem;
        }

        .section-title {
            font-size: 1.5rem;
            font-weight: 600;
            color: #2c3e50;
            margin: 0;
            letter-spacing: -0.5px;
        }

        /* Kanban Board */
        .kanban-container {
            max-width: 1800px;
            margin: 0 auto;
            padding: 0 3rem 0.5rem;
        }

        .kanban-board {
            display: flex;
            gap: 1.25rem;
            overflow-x: auto;
            padding-bottom: 0.5rem;
        }

        .kanban-column {
            flex: 1;
            min-width: 200px;
            background: #fff;
            border-radius: 8px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            display: flex;
            flex-direction: column;
        }

        .kanban-column-header {
            padding: 0.75rem 1rem;
            font-weight: 500;
            font-size: 0.875rem;
            color: #333;
            border-bottom: 1px solid #e9ecef;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .kanban-column-count {
            background: #e9ecef;
            color: #6c757d;
            font-size: 0.75rem;
            padding: 0.125rem 0.5rem;
            border-radius: 10px;
        }

        .kanban-column-body {
            padding: 0.5rem;
            flex: 1;
            overflow-y: auto;
            min-height: 100px;
            max-height: 190px;
        }

        .kanban-column-body.drag-over {
            background: #f0f7f4;
        }

        .kanban-card {
            background: #f8f9fa;
            border: 1px solid #e9ecef;
            border-radius: 6px;
            padding: 0.625rem 0.75rem;
            margin-bottom: 0.5rem;
            cursor: grab;
            transition: background 0.15s, box-shadow 0.15s, transform 0.15s;
            position: relative;
            height: 50px;
            display: flex;
            flex-direction: column;
            justify-content: center;
        }

        .kanban-card:hover {
            background: #e8f5e9;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .kanban-card.dragging {
            opacity: 0.5;
            transform: rotate(2deg);
        }

        .kanban-card-title {
            font-size: 0.9rem;
            color: #212529;
            margin-bottom: 0;
            padding-right: 1.5rem;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .kanban-card.critical {
            background: #fff5f5;
            border-color: #f8d7da;
        }

        .kanban-card.critical:hover {
            background: #e8f5e9;
        }

        .kanban-card-meta {
            display: none;
        }

        .kanban-card-context {
            font-size: 0.7rem;
            color: white;
            padding: 0.1rem 0.4rem;
            border-radius: 3px;
        }

        .kanban-empty {
            color: #adb5bd;
            font-size: 0.8rem;
            text-align: center;
            padding: 1rem;
            font-style: italic;
        }

        /* Calendar (Today View) */
        .calendar-container {
            max-width: 1800px;
            margin: 0 auto;
            padding: 0 3rem 1rem;
        }

        .calendar-board {
            display: flex;
            gap: 1rem;
        }

        .calendar-box {
            flex: 1;
            min-width: 200px;
            background: #fff;
            border-radius: 8px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            display: flex;
            flex-direction: column;
        }


        .calendar-box-header {
            padding: 0.75rem 1rem;
            font-weight: 500;
            font-size: 0.875rem;
            color: #333;
            border-bottom: 1px solid #e9ecef;
        }

        .calendar-box-title {
            font-weight: 500;
            font-size: 0.875rem;
            color: #333;
        }

        .calendar-box-body {
            flex: 1;
            overflow-y: auto;
            min-height: 100px;
            max-height: 400px;
            display: flex;
            flex-direction: row;
        }

        .calendar-label-column {
            background: #f8f9fa;
            min-width: 56px;
            display: flex;
            flex-direction: column;
            flex-shrink: 0;
        }

        .calendar-label-column .calendar-time-label {
            font-size: 0.75rem;
            color: #6c757d;
            text-align: left;
            padding: 1.25rem 0.5rem;
            border-bottom: 1px solid #e0e0e0;
            flex: 1;
            display: flex;
            align-items: center;
        }

        .calendar-label-column .calendar-time-label:last-child {
            border-bottom: none;
        }

        .calendar-content-column {
            flex: 1;
            display: flex;
            flex-direction: column;
        }

        .calendar-content-column .calendar-section {
            padding: 0.5rem;
            border-bottom: 1px solid #e9ecef;
            min-height: 60px;
            flex: 1;
            display: flex;
            align-items: center;
        }

        .calendar-content-column .calendar-section:last-child {
            border-bottom: none;
        }

        .calendar-section-content {
            width: 100%;
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
            align-items: center;
        }

        .calendar-task-count {
            background: #f8f9fa;
            border: 1px solid #e9ecef;
            border-radius: 6px;
            padding: 0.625rem 0.75rem;
            cursor: pointer;
            transition: box-shadow 0.15s;
            height: 50px;
            display: flex;
            align-items: center;
            font-size: 0.9rem;
            color: #495057;
        }

        .calendar-task-count:hover {
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .calendar-section-content .kanban-card {
            margin-bottom: 0;
        }

        /* Right slide-out panel for time slot tasks */
        .timeslot-panel {
            position: fixed;
            top: 0;
            right: 0;
            width: 100%;
            max-width: 400px;
            height: 100%;
            background: white;
            box-shadow: -4px 0 20px rgba(0, 0, 0, 0.15);
            transform: translateX(100%);
            transition: transform 0.3s ease;
            z-index: 1001;
            display: flex;
            flex-direction: column;
        }

        .timeslot-panel.active {
            transform: translateX(0);
        }

        .timeslot-panel-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s ease, visibility 0.3s ease;
            z-index: 1000;
        }

        .timeslot-panel-overlay.active {
            opacity: 1;
            visibility: visible;
        }

        .timeslot-task-list {
            flex: 1;
            overflow-y: auto;
            padding: 1rem;
        }

        .timeslot-task-item {
            background: #f8f9fa;
            border: 1px solid #e9ecef;
            border-radius: 6px;
            padding: 0.75rem;
            margin-bottom: 0.75rem;
            cursor: grab;
            transition: box-shadow 0.15s;
            position: relative;
        }

        .timeslot-task-item:active {
            cursor: grabbing;
        }

        .timeslot-task-item:hover {
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .timeslot-task-item.dragging {
            opacity: 0.5;
        }

        .timeslot-task-title {
            font-size: 0.95rem;
            color: #212529;
            margin-bottom: 0.25rem;
        }

        .timeslot-task-meta {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .timeslot-task-context {
            font-size: 0.7rem;
            color: white;
            padding: 0.1rem 0.4rem;
            border-radius: 3px;
        }

        .calendar-content-column .calendar-section.drag-over {
            background: #f0f7f4;
        }

        /* ========== Two-Panel Layout ========== */
        .two-panel-container {
            max-width: 1800px;
            margin: 0 auto;
            padding: 0 2rem 2rem;
        }

        .panels-wrapper {
            display: flex;
            gap: 1rem;
            align-items: stretch;
        }

        .panel {
            background: white;
            border: 1px solid #dee2e6;
            border-radius: 8px;
            display: flex;
            flex-direction: column;
            overflow-y: hidden;
            overflow-x: visible;
            transition: height 0.3s ease;
            position: relative;
            flex: 1;
            min-width: 300px;
            min-height: 870px;
        }

        /* Horizontal collapse (when panel is in sidebar mode) */
        .panel.minimized {
            flex: 0 0 60px;
            min-width: 60px;
        }

        .panel.minimized .panel-content {
            display: none;
        }

        .panel.minimized .panel-header {
            flex-direction: column;
            padding: 0.75rem 0.5rem;
            height: 100%;
            border-bottom: none;
            border-right: 1px solid #e9ecef;
            cursor: pointer;
        }

        .panel.minimized .panel-header:hover {
            background: #f0f0f0;
        }

        .panel.minimized .panel-header-left {
            writing-mode: vertical-rl;
            text-orientation: mixed;
            transform: rotate(180deg);
        }

        .panel.minimized .panel-header-right {
            display: none;
        }

        .panel.minimized .tasks-search-bar {
            display: none;
        }

        .panel.minimized .panel-collapsed-metrics {
            display: none;
        }

        .panel.focused {
            flex: 1;
        }

        .panel-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0.75rem 1rem;
            border-bottom: 1px solid #e9ecef;
            background: #fafafa;
            min-height: 48px;
        }

        .panel-header-left {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .panel-header-title {
            font-weight: 600;
            font-size: 0.8rem;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            color: #495057;
        }

        .panel-collapse-btn {
            background: none;
            border: none;
            color: #6c757d;
            cursor: pointer;
            padding: 0.25rem;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: color 0.15s, transform 0.3s;
            font-size: 1rem;
        }

        .panel-collapse-btn:hover {
            color: #495057;
        }

        .panel.collapsed .panel-collapse-btn {
            transform: rotate(180deg);
        }

        .panel-content {
            flex: 1;
            overflow-y: auto;
            padding: 1rem;
            padding-bottom: 0;
        }

        /* Tasks search bar */
        .tasks-search-bar {
            display: flex;
            align-items: center;
            padding: 0.5rem 1rem;
            border-top: 1px solid #eee;
            background: #fafafa;
            gap: 0.5rem;
            cursor: pointer;
        }

        .tasks-search-bar.expanded {
            cursor: default;
        }

        .tasks-search-icon {
            color: #aaa;
            font-size: 0.9rem;
            cursor: pointer;
            padding: 0.25rem;
            transition: color 0.15s;
        }

        .tasks-search-icon:hover {
            color: #6B9080;
        }

        .tasks-search-expanded {
            display: none;
            align-items: center;
            gap: 0.5rem;
            flex: 1;
        }

        .tasks-search-bar.expanded .tasks-search-expanded {
            display: flex;
        }

        .tasks-search-bar.expanded .tasks-search-icon {
            display: none;
        }

        .tasks-search-expanded input {
            flex: 1;
            border: none;
            background: transparent;
            font-size: 0.85rem;
            color: #333;
            outline: none;
            min-width: 100px;
        }

        .tasks-search-expanded input::placeholder {
            color: #aaa;
        }

        .tasks-search-btn {
            padding: 0.25rem 0.6rem;
            border: 1px solid #6B9080;
            border-radius: 4px;
            background: #6B9080;
            color: white;
            font-size: 0.75rem;
            cursor: pointer;
            white-space: nowrap;
        }

        .tasks-search-btn:hover {
            background: #5a7d6e;
        }

        .tasks-search-results {
            font-size: 0.75rem;
            color: #6B9080;
            white-space: nowrap;
            font-weight: 500;
        }

        .tasks-search-clear {
            color: #aaa;
            font-size: 1rem;
            cursor: pointer;
            padding: 0.25rem;
            transition: color 0.15s;
        }

        .tasks-search-clear:hover {
            color: #dc3545;
        }

        /* Hide search bar when panel is collapsed or minimized */
        .panel.collapsed .tasks-search-bar,
        .panel.minimized .tasks-search-bar {
            display: none;
        }

        .panel-header-vertical {
            display: none;
        }

        .panel.collapsed .panel-header {
            border-bottom: none;
            height: 46px;
            min-height: 46px;
            max-height: 46px;
            box-sizing: border-box;
        }

        /* Collapsed panel metrics */
        .panel-collapsed-metrics {
            display: none;
            flex-wrap: wrap;
            gap: 0.5rem;
            margin-right: 0.5rem;
            justify-content: flex-end;
        }

        .panel.collapsed .panel-collapsed-metrics {
            display: flex;
        }

        /* Hide expand button when panel is vertically collapsed */
        .panel.collapsed .panel-expand-btn {
            display: none;
        }

        .metric-pill {
            background: #e9ecef;
            color: #495057;
            font-size: 0.75rem;
            padding: 0.25rem 0.6rem;
            border-radius: 12px;
            white-space: nowrap;
        }

        .metric-pill .metric-count,
        .metric-pill #meetings-count,
        .metric-pill #meetings-time {
            font-weight: 600;
        }

        /* Block Time button - only visible when Calendar is expanded */
        .add-event-btn {
            display: none;
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            color: #495057;
            cursor: pointer;
            padding: 0.25rem 0.5rem;
            border-radius: 4px;
            font-size: 0.75rem;
            font-weight: 500;
            align-items: center;
            gap: 0.25rem;
            margin-right: 0.5rem;
            transition: all 0.15s;
        }

        .add-event-btn:hover {
            background: #e9ecef;
            border-color: #ced4da;
        }

        /* Show when horizontally expanded OR vertically expanded (not collapsed) */
        .calendar-panel.expanded .add-event-btn,
        .calendar-panel:not(.collapsed):not(.minimized) .add-event-btn {
            display: flex;
        }

        /* Panel expand button */
        .panel-expand-btn {
            background: none;
            border: none;
            color: #6c757d;
            cursor: pointer;
            padding: 0.25rem;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: color 0.15s;
            font-size: 1rem;
            margin-left: auto;
            margin-right: 0.5rem;
        }

        .panel-expand-btn:hover {
            color: #495057;
        }

        /* Horizontal expansion states - THREE explicit states only */

        /* Fully expanded: takes ALL available space (others are minimized) */
        .panel.fully-expanded {
            flex: 1;
            min-width: 300px;
        }

        .panel.fully-expanded .panel-expand-btn i {
            transform: rotate(180deg);
        }

        .panel.fully-expanded .panel-collapse-btn {
            display: none;
        }

        /* Half expanded: takes HALF the space (one other is half, one is minimized) */
        .panel.half-expanded {
            flex: 1;
            min-width: 300px;
        }

        .panel.half-expanded .panel-collapse-btn {
            display: none;
        }

        /* Minimized/Collapsed: fixed 60px width */
        /* Tasks Panel - State Groups */
        .state-group {
            margin-bottom: 1.5rem;
        }

        .state-group:last-child {
            margin-bottom: 0;
        }

        .state-group-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0.75rem 1rem;
            cursor: pointer;
            background: #fafbfc;
            border: 1px solid #e9ecef;
            border-left: 3px solid #6B9080;
            border-radius: 6px;
            transition: all 0.15s;
            user-select: none;
        }

        .state-group-header:hover {
            background: #f5f7f8;
            border-color: #dee2e6;
        }

        .state-group.collapsed .state-group-header {
            background: #fdfdfd;
            border-left-color: #cbd5e0;
        }

        .state-group-header.drag-hover {
            background: #f0f7f4;
            border-left-color: #6B9080;
            border-color: #6B9080;
        }

        .state-group:not(.collapsed) .state-group-header {
            border-bottom-left-radius: 0;
            border-bottom-right-radius: 0;
        }

        .state-group-left {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .state-group-icon {
            color: #495057;
            font-size: 1rem;
        }

        .state-group-name {
            font-weight: 600;
            font-size: 0.85rem;
            color: #2c3e50;
            text-transform: uppercase;
            letter-spacing: 0.03em;
        }

        .state-group-right {
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }

        .state-group-count {
            background: #e9ecef;
            color: #6c757d;
            font-size: 0.7rem;
            padding: 0.125rem 0.4rem;
            border-radius: 10px;
        }

        .state-group-toggle {
            color: #6c757d;
            font-size: 0.875rem;
            transition: transform 0.2s;
        }

        .state-group.collapsed .state-group-toggle {
            transform: rotate(-90deg);
        }

        .state-group-body {
            padding: 0.9rem 0.5rem;
            background: white;
            border: 1px solid #e9ecef;
            border-top: none;
            border-bottom-left-radius: 6px;
            border-bottom-right-radius: 6px;
            min-height: 40px;
            max-height: 220px;
            overflow-y: auto;
            transition: background 0.15s;
        }

        .state-group-body.drag-over {
            background: #f0f7f4;
        }

        .state-group-header.drag-over {
            background: #e8f4ea;
        }

        .state-group.collapsed .state-group-body {
            display: none;
        }

        .task-card {
            background: #fafbfc;
            border: 1px solid #eef0f2;
            border-radius: 4px;
            padding: 0.4rem 0.6rem;
            margin-bottom: 0.7rem;
            cursor: grab;
            transition: background 0.15s, box-shadow 0.15s, opacity 0.15s;
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 0.5rem;
        }

        .task-card:last-child {
            margin-bottom: 0;
        }

        .task-card:hover {
            background: #e8f5e9;
            border-color: #d0e0d8;
        }

        .task-card:focus {
            outline: 2px solid #6B9080;
            outline-offset: 2px;
            background: #e8f5e9;
        }

        .task-card.dragging {
            opacity: 0.5;
            cursor: grabbing;
        }

        .task-card.selected {
            background: #d4edda;
            border-color: #6B9080;
            box-shadow: 0 0 0 1px #6B9080;
        }

        .task-card.selected:hover {
            background: #c3e6cb;
        }

        .task-card.drag-over {
            border-color: #6B9080;
            box-shadow: 0 0 0 1px #6B9080;
        }
        }

        .task-card:last-child {
            margin-bottom: 0;
        }

        .task-card-title {
            font-size: 0.8rem;
            color: #333;
            margin-bottom: 0;
            flex: 1;
            min-width: 0;
        }

        .task-card.critical {
            /* Critical tasks use icon instead of red background */
        }

        .task-card.critical:hover {
            background: #e8f5e9;
        }

        .panel-header-icon {
            font-size: 1rem;
            opacity: 0.7;
        }

        .task-card-icons {
            display: flex;
            align-items: center;
            gap: 0.25rem;
            flex-shrink: 0;
            margin-left: auto;
        }

        .task-critical-icon {
            color: #dc3545;
            font-size: 0.85rem;
            flex-shrink: 0;
        }

        .task-card.completed .task-card-title {
            text-decoration: line-through;
            color: #6c757d;
        }

        .task-card.highlight-new {
            animation: highlightGlow 4.5s ease-out;
        }

        .calendar-scheduled-task.highlight-new {
            animation: highlightGlow 4.5s ease-out;
        }

        @keyframes highlightGlow {
            0% {
                background: #fff9c4;
                box-shadow: 0 0 8px rgba(255, 235, 59, 0.6);
            }
            44% {
                background: #fff9c4;
                box-shadow: 0 0 8px rgba(255, 235, 59, 0.6);
            }
            100% {
                background: #fafbfc;
                box-shadow: none;
            }
        }

        .task-card.critical.highlight-new {
            animation: highlightGlowCritical 4.5s ease-out;
        }

        .calendar-scheduled-task.critical.highlight-new {
            animation: highlightGlowCritical 4.5s ease-out;
        }

        @keyframes highlightGlowCritical {
            0% {
                background: #fff9c4;
                box-shadow: 0 0 8px rgba(255, 235, 59, 0.6);
            }
            44% {
                background: #fff9c4;
                box-shadow: 0 0 8px rgba(255, 235, 59, 0.6);
            }
            100% {
                background: #fff5f5;
                box-shadow: none;
            }
        }

        .task-card-meta {
            display: none;
        }

        .task-card-context {
            font-size: 0.65rem;
            color: white;
            padding: 0.1rem 0.4rem;
            border-radius: 3px;
        }

        .task-card-tags {
            display: flex;
            gap: 0.25rem;
            flex-wrap: wrap;
            justify-content: flex-end;
            flex-shrink: 0;
        }

        .task-tag-pill {
            font-size: 0.6rem;
            padding: 0.1rem 0.35rem;
            border-radius: 3px;
            background: #e9ecef;
            color: #6c757d;
            white-space: nowrap;
        }

        /* Panel tags section */
        .panel-tags-container {
            display: flex;
            flex-wrap: wrap;
            gap: 0.35rem;
            align-items: center;
        }

        .panel-tag {
            display: inline-flex;
            align-items: center;
            gap: 0.35rem;
            font-size: 0.75rem;
            padding: 0.3rem 0.6rem;
            border-radius: 12px;
            background: #f1f3f5;
            color: #495057;
            border: 1px solid #e9ecef;
        }

        .panel-tag .remove-tag {
            cursor: pointer;
            opacity: 0.5;
            font-size: 0.65rem;
            line-height: 1;
            transition: all 0.15s;
        }

        .panel-tag .remove-tag:hover {
            opacity: 1;
            color: #dc3545;
        }

        .panel-tag-add {
            display: inline-flex;
            align-items: center;
            gap: 0.3rem;
            font-size: 0.8rem;
            padding: 0.3rem 0.6rem;
            border-radius: 12px;
            background: transparent;
            border: 1px dashed #dee2e6;
            color: #6c757d;
            cursor: pointer;
            transition: all 0.15s;
        }

        .panel-tag-add:hover {
            border-color: #6B9080;
            border-style: solid;
            color: #6B9080;
            background: rgba(107, 144, 128, 0.05);
        }

        .panel-tag-dropdown {
            position: relative;
            display: inline-block;
        }

        .panel-tag-dropdown-menu {
            position: absolute;
            top: 100%;
            left: 0;
            margin-top: 0.25rem;
            background: white;
            border: 1px solid #dee2e6;
            border-radius: 6px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            min-width: 180px;
            max-height: 250px;
            overflow-y: auto;
            z-index: 1100;
            display: none;
        }

        .panel-tag-dropdown-menu.show {
            display: block;
        }

        .panel-tag-dropdown-item {
            display: block;
            width: 100%;
            padding: 0.5rem 0.75rem;
            border: none;
            background: none;
            text-align: left;
            font-size: 0.85rem;
            color: #333;
            cursor: pointer;
        }

        .panel-tag-dropdown-item:hover {
            background: #f0f7f4;
        }

        .panel-tag-dropdown-item.checked {
            background: #e8f5e9;
        }

        .panel-tag-dropdown-item.checked::before {
            content: ' ';
            color: #6B9080;
        }

        .panel-tag-dropdown-item.new-tag {
            border-top: 1px solid #eee;
            color: #6B9080;
        }

        .panel-tag-search {
            width: 100%;
            padding: 0.5rem 0.75rem;
            border: none;
            border-bottom: 1px solid #eee;
            font-size: 0.85rem;
            outline: none;
        }

        /* Schedule indicator pills - shows Today, Tomorrow, or Future */
        .task-schedule-pill {
            font-size: 0.55rem;
            padding: 0.1rem 0.4rem;
            border-radius: 10px;
            white-space: nowrap;
            font-weight: 500;
            letter-spacing: 0.02em;
            flex-shrink: 0;
        }

        .task-schedule-pill.today {
            background: #fff3cd;
            color: #856404;
        }

        .task-schedule-pill.tomorrow {
            background: #d1ecf1;
            color: #0c5460;
        }

        .task-schedule-pill.future {
            background: #f3e8ff;
            color: #7c3aed;
        }

        /* State indicator pills - shows task state in Tags/Scheduled views */
        .task-state-pill {
            font-size: 0.55rem;
            padding: 0.1rem 0.4rem;
            border-radius: 10px;
            white-space: nowrap;
            font-weight: 500;
            letter-spacing: 0.02em;
            flex-shrink: 0;
            background: #e9ecef;
            color: #495057;
        }

        /* State pills in Schedule and Tags views get colored styling */
        .state-group-body[data-schedule-group] .task-state-pill,
        .state-group-body[data-tag-id] .task-state-pill {
            background: #e0e7ff;
            color: #3730a3;
        }

        .task-card-content {
            display: flex;
            align-items: flex-start;
            gap: 0.5rem;
            width: 100%;
        }

        .task-card-drag-handle {
            color: #bbb;
            padding: 0 2px;
            font-size: 0.75rem;
            flex-shrink: 0;
            opacity: 0.5;
            transition: opacity 0.15s;
        }

        .task-card:hover .task-card-drag-handle {
            opacity: 1;
        }

        .task-card-content .task-card-title {
            flex: 1;
            min-width: 0;
        }

        .task-card:active {
            cursor: grabbing;
        }

        /* Scheduled task on calendar - matches Tasks section styling */
        .calendar-scheduled-task {
            position: absolute;
            left: 4px;
            right: 4px;
            min-height: 28px;
            background: #f8f9fa;
            color: #333;
            font-size: 0.75rem;
            padding: 0.25rem 0.5rem;
            padding-right: 1.5rem;
            border-radius: 4px;
            cursor: grab;
            border: 1px solid #dee2e6;
            overflow: hidden;
            z-index: 2;
            box-sizing: border-box;
            display: flex;
            flex-direction: row;
            align-items: flex-start;
            gap: 6px;
        }

        .calendar-task-content {
            display: flex;
            align-items: center;
            gap: 4px;
            white-space: nowrap;
            overflow: hidden;
            flex: 1;
            min-width: 0;
            margin-top: 1.5px;
        }

        .calendar-task-icon {
            font-size: 0.7rem;
            flex-shrink: 0;
            opacity: 0.7;
        }

        .calendar-task-title {
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .calendar-task-tags {
            display: flex;
            flex-wrap: nowrap;
            gap: 2px;
            flex-shrink: 0;
            margin-left: auto;
            margin-top: 1.5px;
        }

        .calendar-task-tag {
            background: rgba(0, 0, 0, 0.1);
            padding: 1px 4px;
            border-radius: 2px;
            font-size: 0.6rem;
            white-space: nowrap;
        }

        .calendar-scheduled-task.critical .calendar-task-tag {
            background: rgba(0, 0, 0, 0.1);
        }

        .calendar-task-resize-handle {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            height: 8px;
            cursor: ns-resize;
            background: transparent;
            z-index: 10;
        }

        .calendar-task-resize-handle-top {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 8px;
            cursor: ns-resize;
            background: transparent;
            z-index: 10;
        }

        .calendar-task-resize-handle-top:hover {
            background: rgba(0, 0, 0, 0.1);
        }

        /* Time block on calendar - elegant warm orange */
        .calendar-time-block {
            position: absolute;
            left: 4px;
            right: 4px;
            min-height: 28px;
            background: #fff4ed;
            color: #8b5a3c;
            font-size: 0.75rem;
            padding: 0.25rem 0.5rem;
            padding-right: 1.5rem;
            border-radius: 4px;
            cursor: grab;
            border: 2px dotted #e8a87c;
            overflow: hidden;
            z-index: 2;
            box-sizing: border-box;
            display: flex;
            flex-direction: row;
            align-items: flex-start;
            gap: 6px;
        }

        .calendar-time-block:hover {
            background: #ffece0;
        }

        .calendar-time-block.dragging {
            opacity: 0.5;
            cursor: grabbing;
            /* Lock dimensions using CSS variables set in mousedown */
            width: var(--drag-width) !important;
            left: var(--drag-left) !important;
            right: auto !important;
        }

        .time-block-content {
            display: flex;
            align-items: center;
            gap: 4px;
            white-space: nowrap;
            overflow: hidden;
            flex: 1;
            min-width: 0;
            margin-top: 1.5px;
        }

        .time-block-title {
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            font-weight: 500;
            cursor: default;
        }

        .time-block-inline-input {
            background: white;
            border: 1px solid #e8a87c;
            border-radius: 2px;
            font-size: 0.75rem;
            font-weight: 500;
            color: #8b5a3c;
            padding: 0 2px;
            margin: -1px 0;
            width: 100%;
            outline: none;
        }

        .time-block-resize-handle {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            height: 8px;
            cursor: ns-resize;
            background: transparent;
            z-index: 10;
        }

        .time-block-resize-handle:hover {
            background: rgba(232, 168, 124, 0.3);
        }

        .time-block-resize-handle-top {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 8px;
            cursor: ns-resize;
            background: transparent;
            z-index: 10;
        }

        .time-block-resize-handle-top:hover {
            background: rgba(232, 168, 124, 0.3);
        }

        .calendar-time-block .remove-btn {
            background: transparent;
            border: none;
            color: #c9956c;
            cursor: pointer;
            position: absolute;
            right: 0;
            top: 0;
            padding: 8px;
            font-size: 0.75rem;
            line-height: 1;
            min-width: 24px;
            min-height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .calendar-time-block .remove-btn:hover {
            color: #dc3545;
            background: rgba(220, 53, 69, 0.1);
            border-radius: 4px;
        }

        .calendar-task-resize-handle:hover {
            background: rgba(0, 0, 0, 0.1);
        }

        .calendar-scheduled-task.resizing {
            user-select: none;
            cursor: ns-resize;
        }

        .calendar-scheduled-task .remove-btn {
            position: absolute;
            right: 0;
            top: 0;
            background: none;
            border: none;
            color: #6c757d;
            opacity: 0.4;
            cursor: pointer;
            padding: 8px;
            font-size: 0.7rem;
            line-height: 1;
            min-width: 24px;
            min-height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .calendar-scheduled-task .remove-btn:hover {
            opacity: 1;
            background: rgba(108, 117, 125, 0.1);
            border-radius: 4px;
        }

        .calendar-scheduled-task:hover {
            background: #e8e8e8;
        }

        .calendar-scheduled-task.dragging {
            opacity: 0.5;
            cursor: grabbing;
            /* Lock dimensions using CSS variables set in dragstart */
            width: var(--drag-width) !important;
            left: var(--drag-left) !important;
            right: auto !important;
        }

        /* Critical tasks use icon instead of red background */
        .calendar-scheduled-task.critical {
            /* No special background - icon indicates critical */
        }

        .calendar-critical-icon {
            color: #dc3545;
            font-size: 0.7rem;
            flex-shrink: 0;
            margin-left: auto;
            margin-top: 1.5px;
        }

        /* Completed tasks in calendar have strikethrough */
        .calendar-scheduled-task.completed {
            opacity: 0.6;
        }

        .calendar-scheduled-task.completed .calendar-task-title {
            text-decoration: line-through;
            color: #6c757d;
        }

        /* Done for Today icon on calendar tasks */
        .calendar-done-for-day-icon {
            color: #6c757d;
            opacity: 0.4;
            margin-left: auto;
            margin-right: 3px;
            flex-shrink: 0;
        }

        /* Drop indicator for calendar - dynamic height based on task duration */
        .hour-content.drag-over::before {
            content: '';
            position: absolute;
            left: 4px;
            right: 4px;
            height: var(--preview-height, 50%);
            background: #e9ecef;
            border: 2px dashed #6c757d;
            border-radius: 4px;
            pointer-events: none;
            z-index: 5;
        }

        .hour-content.drag-over::before {
            top: var(--preview-top, 0);
        }

        .hour-content.drag-over.drag-blocked::before {
            background: #fee2e2;
            border-color: #f87171;
            opacity: 0.7;
        }

        /* Gap fill preview when Cmd/Ctrl + hover over empty space */
        .gap-fill-preview {
            position: absolute;
            left: 4px;
            right: 4px;
            background: #fff4ed;
            border: 2px dashed #e8a87c;
            border-radius: 4px;
            pointer-events: none;
            z-index: 10;
            display: flex;
            align-items: center;
            justify-content: center;
            box-sizing: border-box;
            overflow: visible;
        }

        .gap-fill-label {
            font-size: 12px;
            color: #8b5a3c;
            font-weight: 500;
            opacity: 0.8;
        }

        .state-group-empty {
            color: #adb5bd;
            font-size: 0.8rem;
            font-style: italic;
            padding: 0.5rem;
            text-align: center;
        }

        /* Calendar Panel - Hourly View */
        .calendar-date-header {
            display: flex;
            align-items: flex-start;
            justify-content: space-between;
            padding: 0.6rem 0.25rem;
            border-bottom: 1px solid #e9ecef;
            background: white;
        }

        .calendar-date-text {
            font-size: 0.9rem;
            font-weight: 500;
            color: #333;
            line-height: 1;
            display: flex;
            align-items: center;
        }

        .calendar-nav-btn {
            background: white;
            border: 1px solid #dee2e6;
            border-radius: 4px;
            padding: 0.4rem;
            cursor: pointer;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            color: #495057;
            transition: all 0.15s ease;
            line-height: 1;
            position: relative;
            bottom: 10px;
        }

        .calendar-nav-btn:hover {
            background: #f8f9fa;
            border-color: #adb5bd;
        }

        .calendar-nav-btn i {
            font-size: 1.17rem;
            line-height: 1;
        }

        /* Today button - matches Block Time button style */
        .calendar-today-btn {
            display: none;
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            color: #495057;
            cursor: pointer;
            padding: 0.25rem 0.5rem;
            border-radius: 4px;
            font-size: 0.75rem;
            font-weight: 500;
            align-items: center;
            gap: 0.25rem;
            margin-right: 0.5rem;
            transition: all 0.15s;
        }

        .calendar-today-btn:hover {
            background: #e9ecef;
            border-color: #ced4da;
        }

        /* Show when panel is expanded AND not viewing today (controlled by JS) */
        .calendar-panel.expanded .calendar-today-btn.visible,
        .calendar-panel:not(.collapsed):not(.minimized) .calendar-today-btn.visible {
            display: flex;
        }

        .hourly-grid {
            flex: 1;
            overflow-y: auto;
            overflow-x: visible;
            position: relative;
            padding-right: 20px;
        }

        .hour-row {
            display: flex;
            min-height: 60px;
            border-bottom: 1px solid #f0f0f0;
        }

        .hour-row:last-child {
            /* Keep bottom border on last row */
        }

        .hour-label {
            width: 50px;
            padding: 0 0.5rem;
            font-size: 0.75rem;
            color: #6c757d;
            text-align: right;
            border-right: 1px solid #e9ecef;
            flex-shrink: 0;
            background: #fafafa;
            display: flex;
            align-items: center;
            justify-content: flex-end;
            white-space: nowrap;
        }

        .hour-content {
            flex: 1;
            padding: 0 0.5rem;
            position: relative;
            min-height: 60px;
            overflow: visible;
        }

        /* Removed hover effect on hour rows */

        .hour-event {
            background: #e8f4f0;
            color: #3d5a4c;
            font-size: 0.75rem;
            padding: 0.25rem 0.5rem;
            border-radius: 4px;
            margin-bottom: 0.25rem;
            cursor: grab;
            border: 1px solid #b8d4c8;
            position: relative;
        }

        .hour-event:hover {
            background: #dceee8;
        }

        .hour-event:active {
            cursor: grabbing;
        }

        /* Current time indicator line */
        .current-time-line {
            position: absolute;
            left: 50px;
            right: 17.5px;
            height: 0;
            border: none;
            border-top: 1px solid rgba(0, 0, 0, 0.7);
            z-index: 100;
            pointer-events: none;
        }

        .current-time-now-label {
            position: absolute;
            right: 0px;
            font-size: 0.65rem;
            color: rgba(0, 0, 0, 0.7);
            font-weight: 600;
            letter-spacing: 0.5px;
            writing-mode: vertical-rl;
            text-orientation: mixed;
            z-index: 101;
            pointer-events: none;
            transform: translateY(-50%);
        }

        .hour-row {
            overflow: visible;
        }

        .hour-event-content {
            display: flex;
            align-items: center;
            gap: 4px;
            white-space: nowrap;
            overflow: visible;
            position: relative;
        }

        .hour-event-subject {
            overflow: hidden;
            text-overflow: ellipsis;
        }

        /* Instant tooltip for calendar events */
        .hour-event[data-tooltip]::after {
            content: attr(data-tooltip);
            position: absolute;
            bottom: calc(100% + 5px);
            left: 0;
            background: #333;
            color: white;
            padding: 0.5rem;
            border-radius: 4px;
            font-size: 0.75rem;
            white-space: pre-wrap;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.1s;
            pointer-events: none;
            z-index: 1000;
            min-width: 200px;
        }

        .hour-event[data-tooltip]::before {
            content: "";
            position: absolute;
            bottom: calc(100% - 1px);
            left: 10px;
            border: 5px solid transparent;
            border-top-color: #333;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.1s;
            pointer-events: none;
            z-index: 1001;
        }

        .hour-event[data-tooltip]:hover::after,
        .hour-event[data-tooltip]:hover::before {
            opacity: 1;
            visibility: visible;
        }

        .hour-event-subject {
            font-weight: 500;
            overflow: hidden;
            text-overflow: ellipsis;
            flex: 1;
        }

        .hour-event-hide-btn {
            background: none;
            border: none;
            padding: 0;
            cursor: pointer;
            color: #6c757d;
            opacity: 0;
            transition: opacity 0.15s;
            font-size: 1rem;
            line-height: 1;
            flex-shrink: 0;
        }

        .hour-event:hover .hour-event-hide-btn {
            opacity: 0.6;
        }

        .hour-event-hide-btn:hover {
            opacity: 1 !important;
            color: #dc3545;
        }

        .hour-event-override-indicator {
            position: absolute;
            top: 2px;
            right: 2px;
            width: 6px;
            height: 6px;
            background: #f59e0b;
            border-radius: 50%;
        }

        /* Right-click context menu */
        .task-context-menu {
            position: fixed;
            background: white;
            border-radius: 8px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.2);
            padding: 0.5rem 0;
            min-width: 180px;
            z-index: 1300;
        }

        .task-context-menu-item {
            padding: 0.5rem 1rem;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 0.75rem;
            font-size: 0.9rem;
            color: #333;
            transition: background 0.15s;
        }

        .task-context-menu-item:hover {
            background: #f0f7f4;
        }

        .task-context-menu-item i {
            width: 16px;
            text-align: center;
            color: #6c757d;
        }

        .task-context-menu-item.danger {
            color: #dc3545;
        }

        .task-context-menu-item.danger i {
            color: #dc3545;
        }

        .task-context-menu-item.save-tags-btn {
            color: #6B9080;
            border-top: 1px solid #e9ecef;
            margin-top: 0.25rem;
            padding-top: 0.6rem;
        }

        .task-context-menu-item.save-tags-btn:hover {
            background: #f0f7f4;
        }

        .task-context-menu-item.save-tags-btn i {
            color: #6B9080;
        }

        .task-context-menu-divider {
            height: 1px;
            background: #e9ecef;
            margin: 0.25rem 0;
        }

        .task-context-menu-submenu {
            position: relative;
        }

        .task-context-menu-submenu-content {
            position: absolute;
            left: 100%;
            top: -0.5rem;
            background: white;
            border-radius: 8px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.2);
            padding: 0.5rem 0;
            min-width: 150px;
            display: none;
        }

        .task-context-menu-submenu:hover .task-context-menu-submenu-content {
            display: block;
        }

        .task-context-menu-item .submenu-arrow {
            margin-left: auto;
            font-size: 0.75rem;
        }

        .context-option {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .context-option-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
        }

        .task-context-menu-item.active {
            background: #f0f7f4;
        }

        .task-context-menu-item.active::before {
            content: '';
            position: absolute;
            right: 1rem;
            font-size: 0.75rem;
            color: #6B9080;
        }

        /* === Classes extracted from inline styles === */

        /* Sidebar icon wrapper - position relative */
        .sidebar-icon-wrapper {
            position: relative;
        }

        /* Filter dropdown layout row */
        .filter-layout-row {
            padding: 0.75rem 1rem;
            border-bottom: 1px solid #e9ecef;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        /* Flex: 1 utility for layout button */
        .flex-1 {
            flex: 1;
        }

        /* Small tooltip icon (0.7rem) */
        .tooltip-icon-sm {
            font-size: 0.7rem;
        }

        /* Filter/settings section title inner span */
        .section-title-inner {
            display: flex;
            align-items: center;
            gap: 0.3rem;
        }

        /* Critical icon color */
        .icon-critical {
            color: #dc3545;
        }

        /* Today icon color */
        .icon-today {
            color: #ffc107;
        }

        /* Hidden by default (JS-controlled visibility) */
        .initially-hidden {
            display: none;
        }

        /* Clickable panel header */
        .panel-header-clickable {
            cursor: pointer;
        }

        /* Filter info icon in summary */
        .filter-info-icon-style {
            margin-left: 0.3rem;
            cursor: help;
        }

        /* No states empty item */
        .no-states-empty {
            color: #6c757d;
            justify-content: center;
            background: transparent;
        }

        /* Abandon settings - no tags placeholder */
        .abandon-no-tags {
            color: #aaa;
            font-size: 0.75rem;
            font-style: italic;
        }

        /* State icon in abandon exclusion chips */
        .abandon-chip-icon {
            font-size: 0.7rem;
        }

        /* Panel header title icon margin */
        .panel-title-icon {
            margin-right: 0.4rem;
        }

        /* Panel body with no padding */
        .panel-body-flush {
            padding: 0;
        }

        /* Details header flex container */
        .details-header-flex {
            display: flex;
            align-items: center;
            gap: 0.35rem;
        }

        /* Properties section content layout */
        .properties-content {
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }

        /* Deadline status spacing */
        .deadline-status-spacing {
            margin-bottom: 0.75rem;
        }

        /* Scheduled section tooltip */
        .scheduled-tooltip {
            font-size: 0.7rem;
            color: #6c757d;
            margin-left: 0.25rem;
        }

        /* Remove from calendar button alignment */
        .align-self-start {
            align-self: flex-start;
        }

        /* Timeslot panel title */
        .timeslot-title {
            font-weight: 500;
        }

        /* Custom date input full width */
        .custom-date-input-full {
            width: 100%;
            padding: 0.5rem;
            font-size: 1rem;
        }

        /* Modal field group spacing */
        .modal-field-group {
            margin-bottom: 0.75rem;
        }

        /* Modal field label */
        .modal-field-label {
            font-size: 0.8rem;
            color: #6c757d;
            display: block;
            margin-bottom: 0.25rem;
        }

        /* Modal field label with flex */
        .modal-field-label-flex {
            font-size: 0.8rem;
            color: #6c757d;
            display: flex;
            align-items: center;
            gap: 0.25rem;
        }

        /* Modal input with no bottom margin */
        .modal-input-compact {
            margin-bottom: 0;
        }

        /* Modal tip paragraph */
        .modal-tip {
            font-size: 0.7rem;
            color: #6b9080;
            margin-top: 0.75rem;
            margin-bottom: 0;
            padding: 8px;
            background: #f0f7f4;
            border-radius: 4px;
        }

        /* Modal field header (flex with space-between) */
        .modal-field-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 0.25rem;
        }

        /* Template modal content wider */
        .modal-content-template {
            width: 450px;
        }

        /* Template content preview box */
        .template-preview-box {
            min-height: 200px;
            max-height: 300px;
            overflow-y: auto;
            border: 1px solid #dee2e6;
            border-radius: 4px;
            padding: 0.75rem;
        }

        /* State drag handle hidden */
        .drag-handle-hidden {
            visibility: hidden;
        }

        /* Settings info icon size (0.75rem) */
        .settings-info-icon-size {
            font-size: 0.75rem;
        }
    </style>
</head>
<body>
    <!-- Sidebar icons -->
    <div id="sidebar-icons" class="sidebar-icons">
        <!-- Deadline warning icon -->
        <div class="sidebar-icon-wrapper">
            <i class="bi bi-exclamation-triangle-fill deadline-warning-icon" id="deadline-warning-icon" title="Things to Worry About"></i>
        </div>
        <div class="sidebar-icon-wrapper">
            <i class="bi bi-binoculars-fill sidebar-icon" id="filter-icon" title="Filter"></i>
            <span class="filter-badge" id="filter-badge"></span>
        </div>
        <i class="bi bi-gear sidebar-icon" id="settings-gear" title="Settings"></i>
    </div>

    <!-- Deadline Warning Dropdown -->
    <div class="deadline-dropdown" id="deadline-dropdown">
        <div class="deadline-dropdown-header" id="deadline-dropdown-header">
            <i class="bi bi-exclamation-triangle-fill"></i>
            Things to Worry About
        </div>
        <div class="deadline-dropdown-body" id="deadline-dropdown-body">
            <!-- Content populated by JavaScript -->
        </div>
    </div>

    <!-- Toast notification (reusable) -->
    <div class="toast-notification" id="toast-notification">
        <i class="toast-icon" id="toast-icon"></i>
        <span id="toast-message"></span>
    </div>

    <!-- Filter dropdown -->
    <div class="filter-dropdown" id="filter-dropdown">
        <div class="filter-dropdown-header">
            <i class="bi bi-sliders"></i>
            What You See
        </div>

        <!-- Panel Layout Button -->
        <div class="filter-layout-row">
            <button class="layout-mode-btn flex-1" id="filter-layout-btn">
                <i class="bi bi-columns"></i>
                <span>Choose Layout</span>
            </button>
            <span class="has-tooltip tooltip-icon-sm">
                <i class="bi bi-info-circle"></i>
                <span class="custom-tooltip">Select panel layout configuration</span>
            </span>
        </div>

        <div class="filter-dropdown-body">
            <!-- Saved Views Section -->
            <div class="saved-views-section collapsed">
                <div class="saved-views-header">
                    <span class="section-title-inner">
                        <span class="saved-views-title">Saved Views</span>
                        <span class="has-tooltip tooltip-icon-sm">
                            <i class="bi bi-info-circle"></i>
                            <span class="custom-tooltip">Save and restore filter configurations</span>
                        </span>
                    </span>
                    <i class="bi bi-chevron-down collapse-icon"></i>
                </div>
                <div class="saved-views-content">
                    <div class="saved-views-list" id="saved-views-list">
                        <!-- Views will be populated by JavaScript -->
                    </div>
                    <button class="save-view-btn" id="save-view-btn">
                        <i class="bi bi-plus-lg"></i> Save Current View
                    </button>
                </div>
            </div>

            <!-- Group By -->
            <div class="filter-section collapsed">
                <div class="filter-section-title">
                    <span class="section-title-inner">Group By
                        <span class="has-tooltip tooltip-icon-sm">
                            <i class="bi bi-info-circle"></i>
                            <span class="custom-tooltip">Organize by states or tags</span>
                        </span>
                    </span>
                    <i class="bi bi-chevron-down collapse-icon"></i>
                </div>
                <div class="filter-section-content">
                    <div class="filter-options-row">
                        <label class="filter-option-inline" id="group-by-states-label">
                            <input type="radio" name="group-by" value="states" id="group-by-states" checked>
                            <i class="bi bi-kanban"></i> States
                        </label>
                        <label class="filter-option-inline" id="group-by-tags-label">
                            <input type="radio" name="group-by" value="tags" id="group-by-tags">
                            <i class="bi bi-tags"></i> Tags
                        </label>
                        <label class="filter-option-inline" id="group-by-schedules-label">
                            <input type="radio" name="group-by" value="schedules" id="group-by-schedules">
                            <i class="bi bi-calendar-check"></i> Scheduled
                        </label>
                    </div>
                </div>
            </div>

            <!-- Filters -->
            <div class="filter-section collapsed">
                <div class="filter-section-title">
                    <span class="section-title-inner">Show Only
                        <span class="has-tooltip tooltip-icon-sm">
                            <i class="bi bi-info-circle"></i>
                            <span class="custom-tooltip">Filter by critical or today's tasks</span>
                        </span>
                    </span>
                    <i class="bi bi-chevron-down collapse-icon"></i>
                </div>
                <div class="filter-section-content">
                    <div class="filter-options-row">
                        <label class="filter-option-inline" id="filter-critical-label">
                            <input type="checkbox" id="filter-critical">
                            <i class="bi bi-exclamation-circle icon-critical"></i> Critical
                        </label>
                        <label class="filter-option-inline" id="filter-today-label">
                            <input type="checkbox" id="filter-today">
                            <i class="bi bi-sun icon-today"></i> Today
                        </label>
                    </div>
                </div>
            </div>

            <!-- Tags -->
            <div class="filter-section collapsed" id="filter-tags-section">
                <div class="filter-section-title">
                    <span class="section-title-inner">Tags
                        <span class="has-tooltip tooltip-icon-sm">
                            <i class="bi bi-info-circle"></i>
                            <span class="custom-tooltip">Filter tasks by one or more tags</span>
                        </span>
                    </span>
                    <i class="bi bi-chevron-down collapse-icon"></i>
                </div>
                <div class="filter-section-content">
                    <input type="text" id="filter-tags-search" class="filter-tags-search" placeholder="Search tags...">
                    <div id="filter-tags-list" class="filter-tags-list">
                        <!-- Tags will be populated by JavaScript -->
                    </div>
                </div>
            </div>

            <!-- Options -->
            <div class="filter-section collapsed">
                <div class="filter-section-title">
                    <span class="section-title-inner">Options
                        <span class="has-tooltip tooltip-icon-sm">
                            <i class="bi bi-info-circle"></i>
                            <span class="custom-tooltip">Toggle completed tasks and metrics</span>
                        </span>
                    </span>
                    <i class="bi bi-chevron-down collapse-icon"></i>
                </div>
                <div class="filter-section-content">
                    <label class="filter-option initially-hidden" id="show-completed-label">
                        <input type="checkbox" id="show-completed-toggle">
                        Include Completed
                    </label>
                    <label class="filter-option">
                        <input type="checkbox" id="hide-rollups-toggle">
                        Hide Rollups
                    </label>
                </div>
            </div>

            <button class="filter-clear" id="filter-clear">
                <i class="bi bi-x-circle"></i> Clear All Filters
            </button>
        </div>
    </div>

    <div class="container">
        <div class="page-header">
            <i class="bi bi-highlights page-icon" id="page-icon"></i>
            <h1 class="page-title">Empty, Marvelous</h1>
        </div>

        <div class="task-input-container">
            <input type="text"
                   id="new-task-input"
                   placeholder=""
                   autocomplete="off">
            <div class="animated-placeholder" id="animated-placeholder">Add a new task...</div>
        </div>
    </div>

    <!-- Layout Modal -->
    <div class="layout-modal initially-hidden" id="layout-modal">
        <div class="layout-modal-overlay" id="layout-modal-overlay"></div>
        <div class="layout-modal-content" id="layout-modal-content">
            <!-- Mode Selection View -->
            <div class="layout-view layout-mode-view" id="layout-mode-view">
                <div class="layout-mode-options">
                    <button class="layout-mode-card" id="focus-mode-btn">
                        <i class="bi bi-bullseye"></i>
                        <div class="layout-mode-name">FOCUS</div>
                    </button>
                    <button class="layout-mode-card" id="side-by-side-mode-btn">
                        <i class="bi bi-layout-split"></i>
                        <div class="layout-mode-name">SIDE BY SIDE</div>
                    </button>
                    <button class="layout-mode-card" id="all-mode-btn">
                        <i class="bi bi-columns-gap"></i>
                        <div class="layout-mode-name">ALL</div>
                    </button>
                </div>
            </div>

            <!-- Focus Mode View -->
            <div class="layout-view layout-focus-view initially-hidden" id="layout-focus-view">
                <div class="layout-panel-options">
                    <button class="layout-panel-card" data-panel="tasks">
                        <i class="bi bi-check2-circle"></i>
                        <div class="layout-panel-name">Tasks</div>
                    </button>
                    <button class="layout-panel-card" data-panel="calendar">
                        <i class="bi bi-calendar3"></i>
                        <div class="layout-panel-name">Calendar</div>
                    </button>
                    <button class="layout-panel-card" data-panel="notes">
                        <i class="bi bi-journal-text"></i>
                        <div class="layout-panel-name">Notes</div>
                    </button>
                </div>
            </div>

            <!-- Side by Side Mode View -->
            <div class="layout-view layout-sidebyside-view initially-hidden" id="layout-sidebyside-view">
                <div class="layout-panel-checkboxes">
                    <label class="layout-panel-checkbox">
                        <input type="checkbox" name="panel" value="tasks">
                        <i class="bi bi-check2-circle"></i>
                        <span>Tasks</span>
                    </label>
                    <label class="layout-panel-checkbox">
                        <input type="checkbox" name="panel" value="calendar">
                        <i class="bi bi-calendar3"></i>
                        <span>Calendar</span>
                    </label>
                    <label class="layout-panel-checkbox">
                        <input type="checkbox" name="panel" value="notes">
                        <i class="bi bi-journal-text"></i>
                        <span>Notes</span>
                    </label>
                </div>
            </div>
        </div>
    </div>

    <!-- Two-Panel Layout -->
    <div class="two-panel-container">
        <div class="panels-wrapper">
            <!-- Tasks Panel Wrapper (for toggle placement) -->
            <div class="tasks-panel-wrapper" id="tasks-panel-wrapper">
            <!-- Tasks Panel -->
            <div class="panel tasks-panel collapsed" id="tasks-panel">
                <div class="panel-header panel-header-clickable" id="tasks-panel-header">
                    <div class="panel-header-left">
                        <i class="bi bi-check2-circle panel-header-icon"></i>
                        <span class="panel-header-title">Tasks</span>
                    </div>
                    <div class="panel-header-right">
                        <div class="panel-collapsed-metrics" id="tasks-collapsed-metrics">
                            {% for state in states %}
                            <span class="metric-pill" data-state-id="{{ state.id }}">{{ state.name }}: <span class="metric-count">0</span></span>
                            {% endfor %}
                        </div>
                    </div>
                </div>
                <div class="filter-summary" id="filter-summary">
                    <span class="filter-summary-text" id="filter-summary-text">
                        Showing <span id="visible-task-count">0</span> of <span id="total-task-count">0</span> tasks
                        <span class="filter-info-wrapper">
                            <i class="bi bi-info-circle filter-info-icon-style" id="filter-info-icon"></i>
                            <span class="filter-info-tooltip" id="filter-info-tooltip"></span>
                        </span>
                    </span>
                    <span class="clear-filters-link" id="clear-filters-link">Clear filters</span>
                </div>
                <div class="panel-content" id="tasks-content">
                    <!-- States grouping (default) -->
                    <div id="states-content">
                        {% for state in states %}
                        <div class="state-group collapsed" data-state-id="{{ state.id }}" data-is-system="{{ state.is_system|yesno:'true,false' }}" data-is-terminal="{{ state.is_terminal|yesno:'true,false' }}"{% if state.is_system %} style="display: none;"{% endif %}>
                            <div class="state-group-header" onclick="toggleStateGroup(this)">
                                <div class="state-group-left">
                                    {% if state.bootstrap_icon %}<i class="bi {{ state.bootstrap_icon }} state-group-icon"></i>{% endif %}
                                    <span class="state-group-name">{{ state.name }}</span>
                                </div>
                                <div class="state-group-right">
                                    <span class="state-group-count" id="panel-count-{{ state.id }}">0</span>
                                    <i class="bi bi-chevron-down state-group-toggle"></i>
                                </div>
                            </div>
                            <div class="state-group-body" data-state-id="{{ state.id }}">
                                {% for task in tasks %}
                                {% if task.state == state %}
                                <div class="task-card{% if task.critical %} critical{% endif %}{% if task.schedules.first %} scheduled{% endif %}" data-task-id="{{ task.id }}">
                                    <div class="task-card-content">
                                        <i class="bi bi-grip-vertical task-card-drag-handle"></i>
                                        <div class="task-card-title">{{ task.title }}</div>
                                        {% if task.tags.all %}<div class="task-card-tags">{% for tag in task.tags.all %}<span class="task-tag-pill">{{ tag.name }}</span>{% endfor %}</div>{% endif %}
                                        {% if task.critical %}<div class="task-card-icons"><i class="bi bi-exclamation-circle-fill task-critical-icon" title="Critical: High priority task requiring immediate attention"></i></div>{% endif %}
                                    </div>
                                </div>
                                {% endif %}
                                {% endfor %}
                            </div>
                        </div>
                        {% endfor %}
                        <!-- No State group for orphaned tasks -->
                        <div class="state-group collapsed" data-state-id="none">
                            <div class="state-group-header" onclick="toggleStateGroup(this)">
                                <div class="state-group-left">
                                    <i class="bi bi-question-circle state-group-icon"></i>
                                    <span class="state-group-name">No State</span>
                                </div>
                                <div class="state-group-right">
                                    <span class="state-group-count" id="panel-count-none">0</span>
                                    <i class="bi bi-chevron-down state-group-toggle"></i>
                                </div>
                            </div>
                            <div class="state-group-body" data-state-id="none">
                                {% for task in tasks %}
                                {% if not task.state %}
                                <div class="task-card{% if task.critical %} critical{% endif %}{% if task.schedules.first %} scheduled{% endif %}" data-task-id="{{ task.id }}">
                                    <div class="task-card-content">
                                        <i class="bi bi-grip-vertical task-card-drag-handle"></i>
                                        <div class="task-card-title">{{ task.title }}</div>
                                        {% if task.tags.all %}<div class="task-card-tags">{% for tag in task.tags.all %}<span class="task-tag-pill">{{ tag.name }}</span>{% endfor %}</div>{% endif %}
                                        {% if task.critical %}<div class="task-card-icons"><i class="bi bi-exclamation-circle-fill task-critical-icon" title="Critical: High priority task requiring immediate attention"></i></div>{% endif %}
                                    </div>
                                </div>
                                {% endif %}
                                {% endfor %}
                            </div>
                        </div>
                    </div>
                    <!-- Tags grouping (hidden by default) -->
                    <div id="tags-content" class="initially-hidden"></div>
                    <!-- Schedules grouping (hidden by default) -->
                    <div id="schedules-content" class="initially-hidden"></div>
                </div>
                <div class="tasks-search-bar" id="tasks-search-bar">
                    <i class="bi bi-search tasks-search-icon" id="tasks-search-icon" title="Search tasks"></i>
                    <div class="tasks-search-expanded" id="tasks-search-expanded">
                        <input type="text" id="tasks-search-input" placeholder="Search tasks..." autocomplete="off">
                        <button type="button" class="tasks-search-btn" id="tasks-search-btn">Search</button>
                        <span class="tasks-search-results" id="tasks-search-results"></span>
                        <i class="bi bi-x tasks-search-clear" id="tasks-search-clear" title="Clear search"></i>
                    </div>
                </div>
            </div>
            </div>

            <!-- Calendar Panel -->
            <div class="panel calendar-panel collapsed" id="calendar-panel">
                <div class="panel-header panel-header-clickable" id="calendar-panel-header">
                    <div class="panel-header-left">
                        <i class="bi bi-calendar3 panel-header-icon"></i>
                        <span class="panel-header-title">Calendar</span>
                    </div>
                    <div class="panel-header-right">
                        <div class="panel-collapsed-metrics" id="calendar-collapsed-metrics">
                            <span class="metric-pill">Meetings: <span id="meetings-count">0</span></span>
                            <span class="metric-pill">Time in Meetings: <span id="meetings-time">0h</span></span>
                        </div>
                        <button class="calendar-today-btn" id="calendar-today-btn" title="Jump to Today">
                            <i class="bi bi-calendar-check"></i> Today
                        </button>
                        <button class="add-event-btn" id="add-event-btn" title="Block Time">
                            <i class="bi bi-plus-lg"></i> Block Time
                        </button>
                    </div>
                </div>
                <div class="panel-content">
                    <div class="calendar-date-header">
                        <button class="calendar-nav-btn" id="calendar-prev-day" title="Previous Day">
                            <i class="bi bi-chevron-left"></i>
                        </button>
                        <span class="calendar-date-text" id="calendar-date-text">Today</span>
                        <button class="calendar-nav-btn" id="calendar-next-day" title="Next Day">
                            <i class="bi bi-chevron-right"></i>
                        </button>
                    </div>
                    <div class="hourly-grid" id="hourly-grid">
                        <!-- Hours 7am to 6pm will be generated by JavaScript -->
                    </div>
                </div>
            </div>

            <!-- Notes Panel -->
            <div class="panel notes-panel collapsed" id="notes-panel">
                <div class="panel-header panel-header-clickable" id="notes-panel-header">
                    <div class="panel-header-left">
                        <i class="bi bi-journal-text panel-header-icon"></i>
                        <span class="panel-header-title">Notes</span>
                    </div>
                    <div class="panel-header-right">
                        <div class="panel-collapsed-metrics" id="notes-collapsed-metrics">
                            <!-- Metrics placeholder for future use -->
                        </div>
                    </div>
                </div>
                <div class="panel-content" id="notes-content">
                    <!-- Notes content will be added later -->
                </div>
            </div>
        </div>
    </div>

    <!-- Settings popup -->
    <div class="settings-dropdown" id="settings-dropdown">
        <div class="settings-dropdown-header">
            <i class="bi bi-gear"></i>
            Settings
        </div>
        <div class="settings-dropdown-body">
            <!-- States Section -->
            <div class="settings-section collapsed">
                <div class="settings-section-header">
                    <span class="section-title-inner">
                        <i class="bi bi-collection"></i> States
                        <span class="has-tooltip settings-info-icon settings-info-icon-size">
                            <i class="bi bi-info-circle"></i>
                            <span class="custom-tooltip">Manage workflow states for tasks</span>
                        </span>
                    </span>
                    <i class="bi bi-chevron-down collapse-icon"></i>
                </div>
                <div class="settings-section-content">
                    <div class="state-input-container">
                        <input type="text" id="new-state-input" placeholder="Add new state..." autocomplete="off">
                    </div>
                    <ul class="state-list" id="state-list">
                    {% for state in states %}
                    <li class="state-item{% if state.is_terminal %} terminal-state{% endif %}" data-state-id="{{ state.id }}" data-state-name="{{ state.name }}" data-order="{{ state.order }}" data-icon="{{ state.bootstrap_icon }}" data-is-system="{{ state.is_system|yesno:'true,false' }}" data-is-terminal="{{ state.is_terminal|yesno:'true,false' }}" draggable="{% if state.is_system %}false{% else %}true{% endif %}">
                        <div class="state-item-left">
                            <i class="bi bi-grip-vertical state-drag-handle"{% if state.is_system %} style="visibility: hidden;"{% endif %}></i>
                            <span class="state-name{% if state.is_system %} system-state-name{% endif %}"{% if not state.is_system %} onclick="editStateName({{ state.id }}, this)"{% endif %}>{{ state.name }}</span>
                        </div>
                        <div class="state-item-right">
                            {% if not state.is_system %}
                            <button class="state-terminal-btn{% if state.is_terminal %} active{% endif %}" onclick="toggleTerminalState({{ state.id }}, this)" title="{% if state.is_terminal %}Terminal state (completed){% else %}Set as terminal state{% endif %}">
                                <i class="bi bi-check-circle{% if state.is_terminal %}-fill{% endif %}"></i>
                            </button>
                            {% endif %}
                            <button class="state-icon-btn" onclick="openIconPicker({{ state.id }}, this)" title="Choose icon">
                                <i class="bi {% if state.bootstrap_icon %}{{ state.bootstrap_icon }}{% else %}bi-plus-circle-dotted{% endif %}"></i>
                            </button>
                            <button class="state-delete{% if state.is_system %} disabled{% endif %}" {% if not state.is_system %}onclick="deleteState({{ state.id }}, this)"{% endif %} title="{% if state.is_system %}System state cannot be deleted{% else %}Delete state{% endif %}">
                                <i class="bi bi-x-lg"></i>
                            </button>
                        </div>
                    </li>
                    {% empty %}
                    <li class="state-item no-states-empty" id="no-states">
                        No states yet
                    </li>
                    {% endfor %}
                </ul>
                </div>
            </div>

            <!-- Task Detail Templates Section -->
            <div class="settings-section collapsed">
                <div class="settings-section-header">
                    <span class="section-title-inner">
                        <i class="bi bi-file-earmark-text"></i> Templates
                        <span class="has-tooltip settings-info-icon settings-info-icon-size">
                            <i class="bi bi-info-circle"></i>
                            <span class="custom-tooltip">Reusable templates for task details</span>
                        </span>
                    </span>
                    <i class="bi bi-chevron-down collapse-icon"></i>
                </div>
                <div class="settings-section-content">
                    <div class="template-list" id="template-list">
                        <!-- Templates will be populated by JavaScript -->
                    </div>
                    <button class="add-template-btn" id="add-template-btn">
                        <i class="bi bi-plus-lg"></i> Add Template
                    </button>
                </div>
            </div>

            <!-- Auto-Abandon Section -->
            <div class="settings-section collapsed">
                <div class="settings-section-header">
                    <span class="section-title-inner">
                        <i class="bi bi-archive"></i> Auto-Abandon
                        <span class="has-tooltip settings-info-icon settings-info-icon-size">
                            <i class="bi bi-info-circle"></i>
                            <span class="custom-tooltip auto-abandon-tooltip">Auto-move unscheduled tasks to abandoned</span>
                        </span>
                    </span>
                    <i class="bi bi-chevron-down collapse-icon"></i>
                </div>
                <div class="settings-section-content">
                    <div class="settings-row">
                        <label class="settings-toggle">
                            <input type="checkbox" id="auto-abandon-enabled" checked>
                            <span>Enable auto-abandon</span>
                        </label>
                    </div>
                    <div class="settings-row" id="abandoned-days-row">
                        <label for="abandoned-days-input">Days until abandoned:</label>
                        <input type="number" id="abandoned-days-input" min="1" max="365" value="14" class="abandoned-days-input">
                    </div>
                    <div class="settings-row abandon-exclusion-row" id="abandon-exclude-tags-row">
                        <label>Exclude tags:</label>
                        <div class="abandon-exclusion-chips" id="abandon-exclude-tags-chips">
                            {% for tag in tags %}
                            <span class="abandon-exclusion-chip" data-tag-id="{{ tag.id }}" onclick="toggleAbandonExcludeTag(this)">{{ tag.name }}</span>
                            {% empty %}
                            <span class="abandon-no-tags">No tags</span>
                            {% endfor %}
                        </div>
                    </div>
                    <div class="settings-row abandon-exclusion-row" id="abandon-exclude-states-row">
                        <label>Exclude states:</label>
                        <div class="abandon-exclusion-chips" id="abandon-exclude-states-chips">
                            {% for state in states %}
                            {% if not state.is_system and not state.is_terminal %}
                            <span class="abandon-exclusion-chip" data-state-id="{{ state.id }}" onclick="toggleAbandonExcludeState(this)">{% if state.bootstrap_icon %}<i class="bi {{ state.bootstrap_icon }} abandon-chip-icon"></i> {% endif %}{{ state.name }}</span>
                            {% endif %}
                            {% endfor %}
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Right slide-out Panel for Task Details -->
    <div class="panel-overlay" id="panel-overlay"></div>
    <div class="slide-panel" id="slide-panel">
        <div class="panel-header">
            <span><i class="bi bi-pencil-square panel-title-icon"></i>Task Details</span>
            <button class="panel-close" id="panel-close"></button>
        </div>
        <div class="panel-body panel-body-flush">
            <!-- Title Section -->
            <div class="task-panel-section">
                <div class="task-panel-section-header">Title</div>
                <div class="task-panel-section-content">
                    <textarea class="panel-title-input" id="panel-title" placeholder="Task title" rows="1"></textarea>
                </div>
            </div>

            <!-- Details Section -->
            <div class="task-panel-section">
                <div class="task-panel-section-header">
                    <div class="details-header-flex">
                        <span>Details</span>
                        <span class="markdown-help-icon">
                            <i class="bi bi-question-circle"></i>
                            <span class="markdown-help-tooltip">
                                <strong>Markdown</strong><br>
                                <code>**text**</code> bold<br>
                                <code>*text*</code> italic<br>
                                <code>[text](url)</code> link<br>
                                <code>- item</code> bullet<br>
                                <code>1. item</code> numbered<br>
                                <code>`code`</code> code<br>
                                <code>## text</code> heading
                            </span>
                        </span>
                    </div>
                    <div class="task-panel-section-actions">
                        <div class="template-dropdown" id="template-dropdown">
                            <button type="button" class="template-dropdown-btn" id="template-dropdown-btn" title="Load template">
                                <i class="bi bi-file-earmark-text"></i>
                            </button>
                            <div class="template-dropdown-menu" id="template-dropdown-menu">
                                <!-- Template options populated by JavaScript -->
                            </div>
                        </div>
                        <div class="markdown-mode-toggle">
                            <button type="button" class="markdown-mode-btn active" id="markdown-edit-btn">Edit</button>
                            <button type="button" class="markdown-mode-btn" id="markdown-view-btn">View</button>
                        </div>
                    </div>
                </div>
                <div class="task-panel-section-content">
                    <div class="panel-details-container">
                        <textarea class="panel-details-input" id="panel-details" placeholder=""></textarea>
                        <div class="panel-details-preview initially-hidden" id="panel-details-preview"></div>
                    </div>
                </div>
            </div>

            <!-- Properties Section -->
            <div class="task-panel-section">
                <div class="task-panel-section-header">Properties</div>
                <div class="task-panel-section-content properties-content">

                    <!-- Critical -->
                    <div class="property-card">
                        <div class="property-card-header">
                            <i class="bi bi-exclamation-circle"></i>
                            <span>Critical</span>
                        </div>
                        <div class="property-card-body">
                            <label class="task-toggle">
                                <input type="checkbox" id="panel-critical">
                                <span class="task-toggle-slider"></span>
                            </label>
                        </div>
                    </div>

                    <!-- Tags -->
                    <div class="property-card">
                        <div class="property-card-header">
                            <i class="bi bi-tags"></i>
                            <span>Tags</span>
                        </div>
                        <div class="property-card-body">
                            <div class="panel-tags-container" id="panel-tags-container">
                                <!-- Tags will be populated by JavaScript -->
                            </div>
                        </div>
                    </div>

                    <!-- Deadline -->
                    <div class="property-card">
                        <div class="property-card-header">
                            <i class="bi bi-calendar-event"></i>
                            <span>Deadline</span>
                        </div>
                        <div class="property-card-body">
                            <div id="panel-deadline-status" class="deadline-status-spacing"></div>
                            <div class="deadline-presets">
                                <button type="button" class="deadline-preset-btn" data-preset="tomorrow">Tomorrow</button>
                                <button type="button" class="deadline-preset-btn" data-preset="next-week">Next Week</button>
                                <button type="button" class="deadline-preset-btn" data-preset="two-weeks">2 Weeks</button>
                                <button type="button" class="deadline-preset-btn" data-preset="custom" id="deadline-custom-btn">Custom</button>
                                <button type="button" class="deadline-change-btn initially-hidden" id="panel-deadline-change" title="Change deadline">
                                    Change
                                </button>
                                <button type="button" class="deadline-clear-btn" id="panel-deadline-clear" title="Remove deadline">
                                    Remove
                                </button>
                            </div>
                        </div>
                    </div>

                    <!-- Scheduled Dates (read-only) -->
                    <div class="property-card initially-hidden" id="panel-scheduled-section">
                        <div class="property-card-header">
                            <i class="bi bi-calendar-check"></i>
                            <span>Scheduled</span>
                            <span class="has-tooltip scheduled-tooltip">
                                <i class="bi bi-info-circle"></i>
                                <span class="custom-tooltip">Click dates to jump to calendar</span>
                            </span>
                        </div>
                        <div class="property-card-body">
                            <div id="panel-scheduled-dates" class="deadline-status-spacing">
                                <!-- Date chips will be inserted here by JavaScript -->
                            </div>
                            <button type="button" class="deadline-clear-btn align-self-start" id="panel-remove-from-calendar" title="Remove from all scheduled days">
                                Remove from Calendar
                            </button>
                        </div>
                    </div>

                </div>
            </div>
        </div>
        <div class="panel-footer">
            <div class="panel-footer-left">
                <button class="save-close-btn" id="panel-save-close">
                    <i class="bi bi-check-lg"></i>
                    <span>Save</span>
                </button>
                <button class="mark-done-btn" id="panel-mark-done">
                    <i class="bi bi-check-circle"></i>
                    <span>Task Complete!</span>
                </button>
            </div>
            <button class="delete-btn" id="panel-delete" title="Delete task">
                <i class="bi bi-trash"></i>
            </button>
        </div>
    </div>

    <!-- Right slide-out Panel for Time Slot Tasks -->
    <div class="timeslot-panel-overlay" id="timeslot-panel-overlay"></div>
    <div class="timeslot-panel" id="timeslot-panel">
        <div class="panel-header">
            <span class="timeslot-title" id="timeslot-panel-title">Time Slot Tasks</span>
            <button class="panel-close" id="timeslot-panel-close"></button>
        </div>
        <div class="timeslot-task-list" id="timeslot-task-list">
            <!-- Tasks will be populated here -->
        </div>
    </div>

    <!-- Delete State Modal -->
    <div class="modal-overlay" id="delete-state-modal">
        <div class="modal-content">
            <div class="modal-title" id="delete-state-modal-title">Delete State</div>
            <div class="modal-body" id="delete-state-modal-body">
                <!-- Content will be populated dynamically -->
            </div>
            <div id="delete-state-modal-select-container" class="initially-hidden">
                <select class="modal-select" id="delete-state-move-to">
                    <!-- Options will be populated dynamically -->
                </select>
            </div>
            <div class="modal-buttons">
                <button class="modal-btn modal-btn-cancel" onclick="closeDeleteStateModal()">Cancel</button>
                <button class="modal-btn modal-btn-danger initially-hidden" id="delete-state-confirm-btn">Delete</button>
                <button class="modal-btn modal-btn-primary initially-hidden" id="delete-state-ok-btn" onclick="closeDeleteStateModal()">OK</button>
            </div>
        </div>
    </div>

    <!-- Confirm Modal -->
    <div class="modal-overlay" id="confirm-modal">
        <div class="modal-content">
            <div class="modal-title" id="confirm-modal-title">Confirm</div>
            <div class="modal-body" id="confirm-modal-body"></div>
            <div class="modal-buttons">
                <button class="modal-btn modal-btn-cancel" id="confirm-modal-cancel">Cancel</button>
                <button class="modal-btn modal-btn-danger" id="confirm-modal-confirm">Delete</button>
            </div>
        </div>
    </div>

    <!-- Alert Modal -->
    <div class="modal-overlay" id="alert-modal">
        <div class="modal-content">
            <div class="modal-title" id="alert-modal-title">Error</div>
            <div class="modal-body" id="alert-modal-body"></div>
            <div class="modal-buttons">
                <button class="modal-btn modal-btn-primary" id="alert-modal-ok">OK</button>
            </div>
        </div>
    </div>

    <!-- Prompt Modal -->
    <div class="modal-overlay" id="prompt-modal">
        <div class="modal-content">
            <div class="modal-title" id="prompt-modal-title">Input</div>
            <div class="modal-body" id="prompt-modal-body"></div>
            <input type="text" class="modal-input" id="prompt-modal-input" placeholder="">
            <div class="modal-buttons">
                <button class="modal-btn modal-btn-cancel" id="prompt-modal-cancel">Cancel</button>
                <button class="modal-btn modal-btn-primary" id="prompt-modal-ok">OK</button>
            </div>
        </div>
    </div>

    <!-- Custom Date Modal -->
    <div class="modal-overlay" id="custom-date-modal">
        <div class="modal-content">
            <div class="modal-title">Deadline</div>
            <div class="modal-body">
                <input type="date" class="deadline-date-input custom-date-input-full" id="custom-date-input">
            </div>
            <div class="modal-actions">
                <button class="modal-btn modal-btn-cancel" id="custom-date-cancel">Cancel</button>
                <button class="modal-btn modal-btn-confirm" id="custom-date-confirm">OK</button>
            </div>
        </div>
    </div>

    <!-- Custom Content Modal -->
    <div class="modal-overlay" id="custom-modal">
        <div class="modal-content modal-content-wide">
            <div class="modal-title" id="custom-modal-title">Title</div>
            <div class="modal-body" id="custom-modal-body"></div>
            <div class="modal-buttons">
                <button class="modal-btn modal-btn-primary" id="custom-modal-close">Close</button>
            </div>
        </div>
    </div>

    <!-- Block Time Modal -->
    <div class="modal-overlay" id="add-event-modal">
        <div class="modal-content">
            <div class="modal-title">Block Time</div>
            <div class="modal-body">
                <div class="modal-field-group">
                    <label for="event-name-input" class="modal-field-label">Name</label>
                    <input type="text" class="modal-input modal-input-compact" id="event-name-input" placeholder="Event name">
                </div>
                <div>
                    <div class="time-slot-buttons" id="time-slot-buttons">
                        <!-- Buttons will be populated dynamically -->
                    </div>
                </div>
                <p class="modal-tip">
                    <strong>Tip:</strong> Hold <strong>COMMAND</strong> (on MacOS) or <strong>CTRL</strong> (on a PC) over an open space on the calendar to block time. That's likeway faster than using this clunky method that you're using now. :)
                </p>
            </div>
            <div class="modal-buttons">
                <button class="modal-btn modal-btn-cancel" id="add-event-cancel">Cancel</button>
                <button class="modal-btn modal-btn-ok" id="add-event-ok" disabled>OK</button>
            </div>
        </div>
    </div>

    <!-- Edit Time Block Modal -->
    <div class="modal-overlay" id="edit-time-block-modal">
        <div class="modal-content">
            <div class="modal-title">Edit Time Block</div>
            <div class="modal-body">
                <div class="modal-field-group">
                    <label for="edit-time-block-name-input" class="modal-field-label">Name</label>
                    <input type="text" class="modal-input modal-input-compact" id="edit-time-block-name-input" placeholder="Time block name">
                </div>
            </div>
            <div class="modal-actions">
                <button class="modal-btn modal-btn-secondary" id="edit-time-block-cancel">Cancel</button>
                <button class="modal-btn modal-btn-primary" id="edit-time-block-save">Save</button>
            </div>
        </div>
    </div>

    <!-- Task Detail Template Modal -->
    <div class="modal-overlay" id="template-modal">
        <div class="modal-content modal-content-template">
            <div class="modal-title" id="template-modal-title">New Template</div>
            <div class="modal-body">
                <div class="modal-field-group">
                    <label for="template-name-input" class="modal-field-label">Template Name</label>
                    <input type="text" class="modal-input modal-input-compact" id="template-name-input" placeholder="e.g., Meeting Notes">
                </div>
                <div class="modal-field-group">
                    <div class="modal-field-header">
                        <label for="template-content-input" class="modal-field-label-flex">
                            Content
                            <span class="markdown-help-icon">
                                <i class="bi bi-question-circle"></i>
                                <span class="markdown-help-tooltip">
                                    <strong>Markdown</strong><br>
                                    <code>**text**</code> bold<br>
                                    <code>*text*</code> italic<br>
                                    <code>[text](url)</code> link<br>
                                    <code>- item</code> bullet<br>
                                    <code>1. item</code> numbered<br>
                                    <code>`code`</code> code<br>
                                    <code>## text</code> heading
                                </span>
                            </span>
                        </label>
                        <div class="markdown-mode-toggle">
                            <button type="button" class="markdown-mode-btn active" id="template-edit-btn">Edit</button>
                            <button type="button" class="markdown-mode-btn" id="template-view-btn">View</button>
                        </div>
                    </div>
                    <div class="template-content-container">
                        <textarea class="modal-textarea" id="template-content-input" placeholder="## Overview&#10;&#10;## Action Items&#10;- [ ] &#10;&#10;## Notes" rows="10"></textarea>
                        <div class="panel-details-preview initially-hidden template-preview-box" id="template-content-preview"></div>
                    </div>
                </div>
                <div class="template-default-toggle">
                    <input type="checkbox" id="template-is-default">
                    <label for="template-is-default">Set as default template</label>
                </div>
            </div>
            <div class="modal-buttons">
                <button class="modal-btn modal-btn-cancel" id="template-modal-cancel">Cancel</button>
                <button class="modal-btn modal-btn-primary" id="template-modal-save">Save</button>
            </div>
        </div>
    </div>

    <script>
        const csrfToken = document.querySelector('meta[name="csrf-token"]').content;
        let currentTaskId = null;
        let saveTimeout = null;


        // Store tags locally for immediate availability
        let tagsList = [
            {% for tag in tags %}
            { id: {{ tag.id }}, name: "{{ tag.name|escapejs }}" }{% if not forloop.last %},{% endif %}
            {% endfor %}
        ];

        // Store task tags for quick lookup (task_id -> array of tag objects)
        let taskTagsMap = {};
        {% for task in tasks %}
        taskTagsMap[{{ task.id }}] = [{% for tag in task.tags.all %}{ id: {{ tag.id }}, name: "{{ tag.name|escapejs }}" }{% if not forloop.last %},{% endif %}{% endfor %}];
        {% endfor %}

        // Store all task schedules for quick lookup (task_id -> array of {id, start_time, end_time})
        // Supports multiple schedules per task (task can appear on multiple days)
        let taskSchedulesMap = {};
        {% for task in tasks %}
        taskSchedulesMap[{{ task.id }}] = [
            {% for schedule in task.schedules.all %}
            { id: {{ schedule.id }}, start_time: "{{ schedule.start_time.isoformat }}", end_time: "{{ schedule.end_time.isoformat }}" }{% if not forloop.last %},{% endif %}
            {% endfor %}
        ];
        {% endfor %}

        // Store task deadlines for quick lookup (task_id -> {deadline, deadline_dismissed, state_id, critical})
        let taskDeadlinesMap = {};
        {% for task in tasks %}
        taskDeadlinesMap[{{ task.id }}] = {
            deadline: {% if task.deadline %}"{{ task.deadline|date:'Y-m-d' }}"{% else %}null{% endif %},
            deadline_dismissed: {{ task.deadline_dismissed|yesno:"true,false" }},
            state_id: {{ task.state_id|default:"null" }},
            critical: {{ task.critical|yesno:"true,false" }}
        };
        {% endfor %}

        // Store task updated_at for abandonment calculations (any edit resets the timer)
        let taskUpdatedAtMap = {};
        {% for task in tasks %}
        taskUpdatedAtMap[{{ task.id }}] = {% if task.updated_at %}"{{ task.updated_at|date:'c' }}"{% else %}null{% endif %};
        {% endfor %}

        // Store task done_for_day for calendar "Done for Today" feature
        let taskDoneForDayMap = {};
        {% for task in tasks %}
        taskDoneForDayMap[{{ task.id }}] = {% if task.done_for_day %}"{{ task.done_for_day|date:'Y-m-d' }}"{% else %}null{% endif %};
        {% endfor %}

        // Abandoned state tracking
        let abandonedStateId = null;
        let abandonedDays = 14;  // Default, will be loaded from cookie
        let autoAbandonEnabled = true;  // Default, will be loaded from cookie
        let abandonExcludedTagIds = [];   // Tag IDs to exclude from auto-abandon
        let abandonExcludedStateIds = []; // State IDs to exclude from auto-abandon

        // Saved views from database
        let savedViews = {{ saved_views|safe }};
        let currentActiveViewId = null; // null means "All Tasks" (no view applied)

        // Current calendar date being displayed (defaults to today)
        let currentCalendarDate = new Date();
        // Set to start of day
        currentCalendarDate.setHours(0, 0, 0, 0);

        // ========== Custom Modal Functions ==========

        // Confirm modal - returns a Promise that resolves to true/false
        function showConfirmModal(message, title = 'Confirm', confirmText = 'Delete') {
            return new Promise((resolve) => {
                const modal = document.getElementById('confirm-modal');
                const titleEl = document.getElementById('confirm-modal-title');
                const bodyEl = document.getElementById('confirm-modal-body');
                const cancelBtn = document.getElementById('confirm-modal-cancel');
                const confirmBtn = document.getElementById('confirm-modal-confirm');

                titleEl.textContent = title;
                bodyEl.textContent = message;
                confirmBtn.textContent = confirmText;

                const cleanup = () => {
                    modal.classList.remove('active');
                    cancelBtn.removeEventListener('click', handleCancel);
                    confirmBtn.removeEventListener('click', handleConfirm);
                    document.removeEventListener('keydown', handleKeydown);
                };

                const handleCancel = () => {
                    cleanup();
                    resolve(false);
                };

                const handleConfirm = () => {
                    cleanup();
                    resolve(true);
                };

                const handleKeydown = (e) => {
                    if (e.key === 'Enter') {
                        e.preventDefault();
                        handleConfirm();
                    } else if (e.key === 'Escape') {
                        e.preventDefault();
                        handleCancel();
                    }
                };

                cancelBtn.addEventListener('click', handleCancel);
                confirmBtn.addEventListener('click', handleConfirm);
                document.addEventListener('keydown', handleKeydown);

                modal.classList.add('active');
                confirmBtn.focus();
            });
        }

        // Alert modal - returns a Promise that resolves when closed
        function showAlertModal(message, title = 'Error') {
            return new Promise((resolve) => {
                const modal = document.getElementById('alert-modal');
                const titleEl = document.getElementById('alert-modal-title');
                const bodyEl = document.getElementById('alert-modal-body');
                const okBtn = document.getElementById('alert-modal-ok');

                titleEl.textContent = title;
                bodyEl.textContent = message;

                const cleanup = () => {
                    modal.classList.remove('active');
                    okBtn.removeEventListener('click', handleOk);
                    document.removeEventListener('keydown', handleKeydown);
                };

                const handleOk = () => {
                    cleanup();
                    resolve();
                };

                const handleKeydown = (e) => {
                    if (e.key === 'Enter' || e.key === 'Escape') {
                        e.preventDefault();
                        handleOk();
                    }
                };

                okBtn.addEventListener('click', handleOk);
                document.addEventListener('keydown', handleKeydown);
                modal.classList.add('active');
                okBtn.focus();
            });
        }

        // Custom modal - displays HTML content
        function showCustomModal(content, title = 'Info', buttonText = 'Close', isHtml = false) {
            const modal = document.getElementById('custom-modal');
            const modalContent = modal.querySelector('.modal-content');
            const titleEl = document.getElementById('custom-modal-title');
            const bodyEl = document.getElementById('custom-modal-body');
            const closeBtn = document.getElementById('custom-modal-close');

            titleEl.textContent = title;
            if (isHtml) {
                bodyEl.innerHTML = content;
            } else {
                bodyEl.textContent = content;
            }
            if (buttonText) {
                closeBtn.textContent = buttonText;
                closeBtn.style.display = '';
            } else {
                closeBtn.style.display = 'none';
            }

            const cleanup = () => {
                modal.classList.remove('active');
                closeBtn.removeEventListener('click', handleClose);
                modal.removeEventListener('click', handleOverlayClick);
                document.removeEventListener('keydown', handleKeydown);
            };

            const handleClose = () => {
                cleanup();
            };

            const handleOverlayClick = (e) => {
                // Close if clicking on the overlay (not the modal content)
                if (e.target === modal) {
                    handleClose();
                }
            };

            const handleKeydown = (e) => {
                if (e.key === 'Escape') {
                    e.preventDefault();
                    handleClose();
                }
            };

            closeBtn.addEventListener('click', handleClose);
            modal.addEventListener('click', handleOverlayClick);
            document.addEventListener('keydown', handleKeydown);
            modal.classList.add('active');
        }

        function closeModal() {
            const customModal = document.getElementById('custom-modal');
            if (customModal.classList.contains('active')) {
                customModal.classList.remove('active');
            }
        }

        // Prompt modal - returns a Promise that resolves to the input value or null if cancelled
        function showPromptModal(message, title = 'Input', placeholder = '') {
            return new Promise((resolve) => {
                const modal = document.getElementById('prompt-modal');
                const titleEl = document.getElementById('prompt-modal-title');
                const bodyEl = document.getElementById('prompt-modal-body');
                const inputEl = document.getElementById('prompt-modal-input');
                const cancelBtn = document.getElementById('prompt-modal-cancel');
                const okBtn = document.getElementById('prompt-modal-ok');

                titleEl.textContent = title;
                bodyEl.textContent = message;
                inputEl.placeholder = placeholder;
                inputEl.value = '';

                const cleanup = () => {
                    modal.classList.remove('active');
                    cancelBtn.removeEventListener('click', handleCancel);
                    okBtn.removeEventListener('click', handleOk);
                    inputEl.removeEventListener('keydown', handleKeydown);
                };

                const handleCancel = () => {
                    cleanup();
                    resolve(null);
                };

                const handleOk = () => {
                    const value = inputEl.value;
                    cleanup();
                    resolve(value);
                };

                const handleKeydown = (e) => {
                    if (e.key === 'Enter') {
                        e.preventDefault();
                        handleOk();
                    } else if (e.key === 'Escape') {
                        e.preventDefault();
                        handleCancel();
                    }
                };

                cancelBtn.addEventListener('click', handleCancel);
                okBtn.addEventListener('click', handleOk);
                inputEl.addEventListener('keydown', handleKeydown);

                modal.classList.add('active');
                setTimeout(() => inputEl.focus(), 100);
            });
        }

        // ========== Layout Modal ==========

        const layoutModal = document.getElementById('layout-modal');
        const filterLayoutBtn = document.getElementById('filter-layout-btn');
        const layoutModeView = document.getElementById('layout-mode-view');
        const layoutFocusView = document.getElementById('layout-focus-view');
        const layoutSideBySideView = document.getElementById('layout-sidebyside-view');

        let selectedFocusPanel = null;
        let selectedSideBySidePanels = [];

        // Open layout modal from filter dropdown
        filterLayoutBtn.addEventListener('click', () => {
            layoutModal.style.display = 'block';
            showLayoutModeView();
            // Close filter dropdown
            document.getElementById('filter-dropdown').classList.remove('active');
        });

        // Close modal when clicking overlay
        document.getElementById('layout-modal-overlay').addEventListener('click', () => {
            layoutModal.style.display = 'none';
        });

        // Show mode selection view
        function showLayoutModeView() {
            layoutModeView.style.display = 'block';
            layoutFocusView.style.display = 'none';
            layoutSideBySideView.style.display = 'none';
        }

        // Focus mode button
        document.getElementById('focus-mode-btn').addEventListener('click', () => {
            layoutModeView.style.display = 'none';
            layoutFocusView.style.display = 'block';
            document.querySelectorAll('.layout-focus-view .layout-panel-card').forEach(card => {
                card.classList.remove('selected');
            });
        });

        // Side by side mode button
        document.getElementById('side-by-side-mode-btn').addEventListener('click', () => {
            layoutModeView.style.display = 'none';
            layoutSideBySideView.style.display = 'block';
            document.querySelectorAll('.layout-panel-checkbox input').forEach(checkbox => {
                checkbox.checked = false;
            });
        });

        // All mode button
        document.getElementById('all-mode-btn').addEventListener('click', () => {
            applyAllLayout();
            layoutModal.style.display = 'none';
        });

        // Focus panel selection - auto-close on selection
        document.querySelectorAll('.layout-focus-view .layout-panel-card').forEach(card => {
            card.addEventListener('click', () => {
                applyFocusLayout(card.dataset.panel);
                layoutModal.style.display = 'none';
            });
        });

        // Side by side panel checkboxes - auto-close when 2 selected
        document.querySelectorAll('.layout-panel-checkbox input').forEach(checkbox => {
            checkbox.addEventListener('change', () => {
                const selectedPanels = Array.from(document.querySelectorAll('.layout-panel-checkbox input:checked'))
                    .map(cb => cb.value);

                if (selectedPanels.length === 2) {
                    applySideBySideLayout(selectedPanels);
                    layoutModal.style.display = 'none';
                }
            });
        });

        // Apply focus layout
        function applyFocusLayout(focusPanel) {
            const panels = ['tasks', 'calendar', 'notes'];

            // Apply classes and order to prevent minimized panels in the middle
            panels.forEach((panel, index) => {
                const panelEl = document.getElementById(`${panel}-panel`);
                // Clear any inline styles and old expansion classes
                panelEl.style.flex = '';
                panelEl.style.display = '';
                panelEl.classList.remove('fully-expanded', 'half-expanded', 'collapsed', 'expanded');

                if (panel === focusPanel) {
                    panelEl.classList.remove('minimized');
                    panelEl.classList.add('focused');
                    panelEl.style.order = '0'; // Focused panel in the middle
                } else {
                    panelEl.classList.add('minimized');
                    panelEl.classList.remove('focused');
                    // Put minimized panels on the edges
                    panelEl.style.order = index < panels.indexOf(focusPanel) ? '-1' : '1';
                }
            });

            // Save to localStorage
            localStorage.setItem('layoutMode', 'focus');
            localStorage.setItem('layoutFocusPanel', focusPanel);
        }

        // Apply side by side layout
        function applySideBySideLayout(sideBySidePanels) {
            const panels = ['tasks', 'calendar', 'notes'];

            // Find indices of expanded and minimized panels
            const expandedIndices = panels.map((p, i) => sideBySidePanels.includes(p) ? i : -1).filter(i => i !== -1);
            const minimizedIndex = panels.findIndex(p => !sideBySidePanels.includes(p));

            panels.forEach((panel, index) => {
                const panelEl = document.getElementById(`${panel}-panel`);
                // Clear any inline styles and old expansion classes
                panelEl.style.flex = '';
                panelEl.style.display = '';
                panelEl.classList.remove('fully-expanded', 'half-expanded', 'collapsed', 'expanded');

                if (sideBySidePanels.includes(panel)) {
                    panelEl.classList.remove('minimized');
                    panelEl.classList.remove('focused');
                    panelEl.style.order = '0'; // Expanded panels in the middle
                } else {
                    panelEl.classList.add('minimized');
                    panelEl.classList.remove('focused');
                    // If minimized panel is between two expanded panels, push to left edge
                    if (minimizedIndex > Math.min(...expandedIndices) && minimizedIndex < Math.max(...expandedIndices)) {
                        panelEl.style.order = '-1'; // Push to left edge
                    } else if (minimizedIndex < Math.min(...expandedIndices)) {
                        panelEl.style.order = '-1'; // Already on left
                    } else {
                        panelEl.style.order = '1'; // Push to right edge
                    }
                }
            });

            // Save to localStorage
            localStorage.setItem('layoutMode', 'sidebyside');
            localStorage.setItem('layoutSideBySidePanels', JSON.stringify(sideBySidePanels));
        }

        // Apply all panels layout
        function applyAllLayout() {
            const panels = ['tasks', 'calendar', 'notes'];
            panels.forEach(panel => {
                const panelEl = document.getElementById(`${panel}-panel`);
                // Clear any inline styles and old expansion classes
                panelEl.style.flex = '';
                panelEl.style.display = '';
                panelEl.classList.remove('fully-expanded', 'half-expanded', 'collapsed', 'expanded');

                panelEl.classList.remove('minimized');
                panelEl.classList.remove('focused');
                panelEl.style.order = '0';
            });

            // Save to localStorage
            localStorage.setItem('layoutMode', 'all');
        }

        // Restore layout from localStorage on page load
        function restoreLayout() {
            const layoutMode = localStorage.getItem('layoutMode');
            if (layoutMode === 'focus') {
                const focusPanel = localStorage.getItem('layoutFocusPanel');
                if (focusPanel) {
                    applyFocusLayout(focusPanel);
                }
            } else if (layoutMode === 'sidebyside') {
                const sideBySidePanels = JSON.parse(localStorage.getItem('layoutSideBySidePanels') || '[]');
                if (sideBySidePanels.length === 2) {
                    applySideBySideLayout(sideBySidePanels);
                }
            } else if (layoutMode === 'all') {
                applyAllLayout();
            } else {
                // Default: show tasks and calendar side by side
                applySideBySideLayout(['tasks', 'calendar']);
            }
        }

        // Make ALL panel headers clickable to open layout modal
        document.querySelectorAll('.panel-header').forEach(header => {
            header.addEventListener('click', (e) => {
                // Don't open layout modal when clicking buttons inside the header
                if (e.target.closest('button')) return;
                e.preventDefault();
                e.stopPropagation();
                layoutModal.style.display = 'block';
                showLayoutModeView();
            });
        });

        // Restore layout on page load
        restoreLayout();

        // ========== Deadline Management ==========

        function getToday() {
            const today = new Date();
            today.setHours(0, 0, 0, 0);
            return today;
        }

        function formatDateForInput(date) {
            const year = date.getFullYear();
            const month = String(date.getMonth() + 1).padStart(2, '0');
            const day = String(date.getDate()).padStart(2, '0');
            return `${year}-${month}-${day}`;
        }

        function formatDateDisplay(dateStr) {
            if (!dateStr) return '';
            const date = new Date(dateStr + 'T00:00:00');
            const options = { weekday: 'short', month: 'short', day: 'numeric' };
            return date.toLocaleDateString('en-US', options);
        }

        function getPresetDate(preset) {
            const today = getToday();
            switch (preset) {
                case 'tomorrow':
                    today.setDate(today.getDate() + 1);
                    break;
                case 'next-week':
                    today.setDate(today.getDate() + 7);
                    break;
                case 'two-weeks':
                    today.setDate(today.getDate() + 14);
                    break;
            }
            return formatDateForInput(today);
        }

        function getDeadlineStatus(deadlineStr) {
            if (!deadlineStr) return null;

            const today = getToday();
            const deadline = new Date(deadlineStr + 'T00:00:00');
            deadline.setHours(0, 0, 0, 0);

            const diffTime = deadline.getTime() - today.getTime();
            const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));

            if (diffDays < 0) {
                return { status: 'overdue', days: Math.abs(diffDays), label: `${Math.abs(diffDays)} day${Math.abs(diffDays) !== 1 ? 's' : ''} overdue` };
            } else if (diffDays === 0) {
                return { status: 'due-soon', days: 0, label: 'Due today' };
            } else if (diffDays === 1) {
                return { status: 'due-soon', days: 1, label: 'Due tomorrow' };
            } else if (diffDays <= 7) {
                return { status: 'on-track', days: diffDays, label: `Due in ${diffDays} days` };
            } else {
                return { status: 'on-track', days: diffDays, label: `Due ${formatDateDisplay(deadlineStr)}` };
            }
        }

        function isTaskInTerminalState(taskId) {
            const terminalStateId = getTerminalStateId();
            if (!terminalStateId) return false;
            const taskData = taskDeadlinesMap[taskId];
            return taskData && taskData.state_id === terminalStateId;
        }

        function getDeadlineWarnings() {
            const critical = [];
            const overdue = [];
            const dueSoon = [];
            const nearAbandoned = [];
            const today = getToday();

            // Check deadline warnings and critical tasks
            for (const [taskId, data] of Object.entries(taskDeadlinesMap)) {
                if (isTaskInTerminalState(taskId)) continue;
                if (isTaskInAbandonedState(taskId)) continue;

                const taskCard = document.querySelector(`.task-card[data-task-id="${taskId}"], .kanban-card[data-task-id="${taskId}"]`);
                const title = taskCard ? taskCard.querySelector('.task-card-title, .kanban-card-title')?.textContent : `Task ${taskId}`;

                // Collect critical tasks
                if (data.critical) {
                    critical.push({
                        id: parseInt(taskId),
                        title: title || `Task ${taskId}`
                    });
                }

                // Check deadlines
                if (data.deadline) {
                    const deadline = new Date(data.deadline + 'T00:00:00');
                    deadline.setHours(0, 0, 0, 0);

                    const diffTime = deadline.getTime() - today.getTime();
                    const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));

                    const taskInfo = {
                        id: parseInt(taskId),
                        title: title || `Task ${taskId}`,
                        deadline: data.deadline,
                        dismissed: data.deadline_dismissed,
                        days: diffDays
                    };

                    if (diffDays < 0) {
                        overdue.push(taskInfo);
                    } else if (diffDays <= 1) {
                        dueSoon.push(taskInfo);
                    }
                }
            }

            // Check for near-abandoned tasks (within 3 days of threshold)
            if (autoAbandonEnabled && abandonedDays > 0) {
                const warningThreshold = abandonedDays - 3;
                for (const [taskId, updatedAt] of Object.entries(taskUpdatedAtMap)) {
                    if (!updatedAt) continue;
                    if (isTaskInTerminalState(taskId)) continue;
                    if (isTaskInAbandonedState(taskId)) continue;
                    if (isTaskExcludedFromAbandon(taskId)) continue;

                    const lastEditDate = new Date(updatedAt);
                    const daysSinceEdit = Math.floor((today - lastEditDate) / (1000 * 60 * 60 * 24));

                    if (daysSinceEdit >= warningThreshold && daysSinceEdit < abandonedDays) {
                        const daysUntilAbandoned = abandonedDays - daysSinceEdit;
                        const taskCard = document.querySelector(`.task-card[data-task-id="${taskId}"], .kanban-card[data-task-id="${taskId}"]`);
                        const title = taskCard ? taskCard.querySelector('.task-card-title, .kanban-card-title')?.textContent : `Task ${taskId}`;

                        nearAbandoned.push({
                            id: parseInt(taskId),
                            title: title || `Task ${taskId}`,
                            days: daysUntilAbandoned
                        });
                    }
                }
            }

            // Sort by title alphabetically for critical, by days for others
            critical.sort((a, b) => a.title.localeCompare(b.title));
            overdue.sort((a, b) => a.days - b.days);
            dueSoon.sort((a, b) => a.days - b.days);
            nearAbandoned.sort((a, b) => a.days - b.days);

            return { critical, overdue, dueSoon, nearAbandoned };
        }

        function isTaskInAbandonedState(taskId) {
            if (!abandonedStateId) return false;
            const taskData = taskDeadlinesMap[taskId];
            return taskData && taskData.state_id === abandonedStateId;
        }

        function isTaskExcludedFromAbandon(taskId) {
            if (abandonExcludedTagIds.length > 0) {
                const tags = taskTagsMap[taskId] || [];
                if (tags.some(tag => abandonExcludedTagIds.includes(tag.id))) return true;
            }
            if (abandonExcludedStateIds.length > 0) {
                const taskData = taskDeadlinesMap[taskId];
                if (taskData && abandonExcludedStateIds.includes(taskData.state_id)) return true;
            }
            return false;
        }

        function toggleAbandonExcludeTag(chipEl) {
            const tagId = parseInt(chipEl.dataset.tagId);
            chipEl.classList.toggle('active');
            if (chipEl.classList.contains('active')) {
                if (!abandonExcludedTagIds.includes(tagId)) abandonExcludedTagIds.push(tagId);
            } else {
                abandonExcludedTagIds = abandonExcludedTagIds.filter(id => id !== tagId);
            }
            saveFilterSettings();
            updateDeadlineWarningIcon();
        }

        function toggleAbandonExcludeState(chipEl) {
            const stateId = parseInt(chipEl.dataset.stateId);
            chipEl.classList.toggle('active');
            if (chipEl.classList.contains('active')) {
                if (!abandonExcludedStateIds.includes(stateId)) abandonExcludedStateIds.push(stateId);
            } else {
                abandonExcludedStateIds = abandonExcludedStateIds.filter(id => id !== stateId);
            }
            saveFilterSettings();
            updateDeadlineWarningIcon();
        }

        async function processAbandonedTasks() {
            if (!autoAbandonEnabled || abandonedDays <= 0) return;

            try {
                const response = await fetch('/tasks/api/process-abandoned/', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-CSRFToken': csrfToken
                    },
                    body: JSON.stringify({
                        abandoned_days: abandonedDays,
                        excluded_tag_ids: abandonExcludedTagIds,
                        excluded_state_ids: abandonExcludedStateIds
                    })
                });

                const data = await response.json();
                if (data.success) {
                    if (data.abandoned_state_id) {
                        abandonedStateId = data.abandoned_state_id;
                    }

                    if (data.abandoned_count > 0) {
                        // Move abandoned task cards to the Abandoned state group in the DOM
                        const abandonedGroup = document.querySelector(`#states-content .state-group[data-state-id="${abandonedStateId}"]`);
                        const abandonedBody = abandonedGroup ? abandonedGroup.querySelector('.state-group-body') : null;
                        if (abandonedBody && data.abandoned_task_ids) {
                            data.abandoned_task_ids.forEach(taskId => {
                                const card = document.querySelector(`#states-content .task-card[data-task-id="${taskId}"]`);
                                if (card) abandonedBody.appendChild(card);
                                // Update local maps
                                if (taskDeadlinesMap[taskId]) taskDeadlinesMap[taskId].state_id = abandonedStateId;
                            });
                            // Remove empty messages from abandoned body
                            const emptyMsg = abandonedBody.querySelector('.state-group-empty');
                            if (emptyMsg) emptyMsg.remove();
                        }

                        // Show toast notification
                        const taskWord = data.abandoned_count === 1 ? 'Task' : 'Tasks';
                        showToast(`${data.abandoned_count} ${taskWord} Abandoned`, {
                            icon: 'bi-archive-fill',
                            type: 'warning',
                            duration: 6000
                        });

                        updatePanelCounts();
                    }

                    updateAbandonedStateVisibility();
                }
            } catch (error) {
                console.error('Error processing abandoned tasks:', error);
            }
        }

        /**
         * Show a toast notification
         * @param {string} message - The message to display
         * @param {Object} options - Optional configuration
         * @param {string} options.icon - Bootstrap icon class (e.g., 'bi-archive-fill')
         * @param {string} options.type - Icon color type: 'warning', 'success', 'info', 'error'
         * @param {number} options.duration - How long to show the toast in ms (default: 6000)
         */
        function showToast(message, options = {}) {
            const { icon = 'bi-info-circle-fill', type = 'info', duration = 6000 } = options;

            const toast = document.getElementById('toast-notification');
            const iconEl = document.getElementById('toast-icon');
            const messageEl = document.getElementById('toast-message');
            if (!toast || !iconEl || !messageEl) return;

            // Set icon and type
            iconEl.className = `bi ${icon} toast-icon ${type}`;
            messageEl.textContent = message;

            // Show toast with fade-in
            toast.classList.add('visible');

            // After duration, fade out by removing visible class
            setTimeout(() => {
                toast.classList.remove('visible');
            }, duration);
        }

        function updateAbandonedStateVisibility() {
            if (!abandonedStateId) return;

            // Hide/show abandoned state group based on task count
            const abandonedGroup = document.querySelector(`.state-group[data-state-id="${abandonedStateId}"]`);
            if (abandonedGroup) {
                const taskCount = abandonedGroup.querySelectorAll('.task-card').length;
                abandonedGroup.style.display = taskCount > 0 ? '' : 'none';
            }

            // Also hide/show in settings state list
            const stateItem = document.querySelector(`.state-item[data-state-id="${abandonedStateId}"]`);
            if (stateItem) {
                const taskCount = document.querySelectorAll(`.task-card[data-state-id="${abandonedStateId}"]`).length ||
                                  (abandonedGroup ? abandonedGroup.querySelectorAll('.task-card').length : 0);
                stateItem.style.display = taskCount > 0 ? '' : 'none';
            }
        }

        function updateDeadlineWarningIcon() {
            const icon = document.getElementById('deadline-warning-icon');
            if (!icon) return;

            const warnings = getDeadlineWarnings();
            const hasOverdue = warnings.overdue.some(t => !t.dismissed);
            const hasDueSoon = warnings.dueSoon.some(t => !t.dismissed);

            icon.classList.remove('has-warnings', 'has-overdue', 'has-near-abandoned');

            if (hasOverdue) {
                icon.classList.add('has-overdue');
            } else if (hasDueSoon) {
                icon.classList.add('has-warnings');
            }
            // Note: Near-abandoned tasks appear in dropdown but don't change icon color
        }

        function renderDeadlineDropdown() {
            const body = document.getElementById('deadline-dropdown-body');
            const warnings = getDeadlineWarnings();

            if (warnings.critical.length === 0 && warnings.overdue.length === 0 && warnings.dueSoon.length === 0 && warnings.nearAbandoned.length === 0) {
                body.innerHTML = `
                    <div class="deadline-empty-state">
                        <i class="bi bi-check-circle"></i>
                        <div>Nothing to worry about</div>
                    </div>
                `;
                return;
            }

            let html = '';
            const LIMIT = 5;

            // Store warnings globally for modal access
            window.currentWarnings = warnings;

            // Critical tasks first
            if (warnings.critical.length > 0) {
                const displayTasks = warnings.critical.slice(0, LIMIT);
                const remaining = warnings.critical.length - LIMIT;
                html += `
                    <div class="deadline-section">
                        <div class="deadline-section-title critical">
                            <i class="bi bi-exclamation-circle-fill"></i>
                            Critical (${warnings.critical.length})
                            <span class="settings-info-icon"><i class="bi bi-info-circle"></i>
                                <span class="settings-info-tooltip">Tasks marked as critical priority.</span>
                            </span>
                        </div>
                        ${displayTasks.map(task => renderCriticalTaskItem(task)).join('')}
                        ${remaining > 0 ? `<div class="deadline-show-more" data-type="critical">${remaining} more...</div>` : ''}
                    </div>
                `;
            }

            if (warnings.overdue.length > 0) {
                const displayTasks = warnings.overdue.slice(0, LIMIT);
                const remaining = warnings.overdue.length - LIMIT;
                html += `
                    <div class="deadline-section">
                        <div class="deadline-section-title overdue">
                            <i class="bi bi-exclamation-circle-fill"></i>
                            Overdue (${warnings.overdue.length})
                            <span class="settings-info-icon"><i class="bi bi-info-circle"></i>
                                <span class="settings-info-tooltip">Tasks past their deadline.</span>
                            </span>
                        </div>
                        ${displayTasks.map(task => renderDeadlineTaskItem(task, 'overdue')).join('')}
                        ${remaining > 0 ? `<div class="deadline-show-more" data-type="overdue">${remaining} more...</div>` : ''}
                    </div>
                `;
            }

            if (warnings.dueSoon.length > 0) {
                const displayTasks = warnings.dueSoon.slice(0, LIMIT);
                const remaining = warnings.dueSoon.length - LIMIT;
                html += `
                    <div class="deadline-section">
                        <div class="deadline-section-title due-soon">
                            <i class="bi bi-clock-fill"></i>
                            Due Soon (${warnings.dueSoon.length})
                            <span class="settings-info-icon"><i class="bi bi-info-circle"></i>
                                <span class="settings-info-tooltip">Tasks due within the next 3 days.</span>
                            </span>
                        </div>
                        ${displayTasks.map(task => renderDeadlineTaskItem(task, 'due-soon')).join('')}
                        ${remaining > 0 ? `<div class="deadline-show-more" data-type="dueSoon">${remaining} more...</div>` : ''}
                    </div>
                `;
            }

            if (warnings.nearAbandoned.length > 0) {
                const displayTasks = warnings.nearAbandoned.slice(0, LIMIT);
                const remaining = warnings.nearAbandoned.length - LIMIT;
                html += `
                    <div class="deadline-section">
                        <div class="deadline-section-title near-abandoned">
                            <i class="bi bi-archive-fill"></i>
                            Near Abandoned (${warnings.nearAbandoned.length})
                            <span class="settings-info-icon"><i class="bi bi-info-circle"></i>
                                <span class="settings-info-tooltip">Tasks within 3 days of being auto-abandoned.</span>
                            </span>
                        </div>
                        ${displayTasks.map(task => renderNearAbandonedItem(task)).join('')}
                        ${remaining > 0 ? `<div class="deadline-show-more" data-type="nearAbandoned">${remaining} more...</div>` : ''}
                    </div>
                `;
            }

            body.innerHTML = html;

            body.querySelectorAll('.deadline-task-info').forEach(el => {
                el.addEventListener('click', () => {
                    const taskId = el.closest('.deadline-task-item').dataset.taskId;
                    closeDeadlineDropdown();
                    fetchAndOpenPanel(taskId);
                });
            });

            // Deadline dismiss buttons (stored in DB)
            body.querySelectorAll('.deadline-dismiss-btn:not(.near-abandon-dismiss)').forEach(btn => {
                btn.addEventListener('click', async (e) => {
                    e.stopPropagation();
                    const item = btn.closest('.deadline-task-item');
                    const taskId = parseInt(item.dataset.taskId);
                    const currentlyDismissed = taskDeadlinesMap[taskId]?.deadline_dismissed || false;
                    await updateTaskDeadlineDismiss(taskId, !currentlyDismissed);
                });
            });

            // Show more links
            body.querySelectorAll('.deadline-show-more').forEach(el => {
                el.addEventListener('click', () => {
                    const type = el.dataset.type;
                    showAllWarningsModal(type);
                });
            });

        }

        function showAllWarningsModal(type) {
            const warnings = window.currentWarnings;
            if (!warnings) return;

            const typeConfig = {
                critical: { title: 'Critical Tasks', tasks: warnings.critical, renderer: renderCriticalTaskItem },
                overdue: { title: 'Overdue Tasks', tasks: warnings.overdue, renderer: (t) => renderDeadlineTaskItem(t, 'overdue') },
                dueSoon: { title: 'Due Soon Tasks', tasks: warnings.dueSoon, renderer: (t) => renderDeadlineTaskItem(t, 'due-soon') },
                nearAbandoned: { title: 'Near Abandoned Tasks', tasks: warnings.nearAbandoned, renderer: renderNearAbandonedItem }
            };

            const config = typeConfig[type];
            if (!config || !config.tasks.length) return;

            // Close the deadline dropdown
            closeDeadlineDropdown();

            // Create modal content
            const tasksHtml = config.tasks.map(config.renderer).join('');

            showCustomModal(
                `<div class="warnings-modal-list">${tasksHtml}</div>`,
                config.title,
                'Close',
                true  // isHtml
            );

            // Add click listeners to the tasks in the modal
            setTimeout(() => {
                const modalBody = document.querySelector('.modal-container .modal-body');
                if (modalBody) {
                    modalBody.querySelectorAll('.deadline-task-info').forEach(el => {
                        el.addEventListener('click', () => {
                            const taskId = el.closest('.deadline-task-item').dataset.taskId;
                            closeModal();
                            fetchAndOpenPanel(taskId);
                        });
                    });
                }
            }, 50);
        }

        function renderCriticalTaskItem(task) {
            return `
                <div class="deadline-task-item" data-task-id="${task.id}">
                    <div class="deadline-task-info">
                        <div class="deadline-task-title">${escapeHtml(task.title)}</div>
                    </div>
                </div>
            `;
        }

        function renderNearAbandonedItem(task) {
            const daysText = task.days === 1 ? '1 day' : `${task.days} days`;

            return `
                <div class="deadline-task-item near-abandoned" data-task-id="${task.id}">
                    <div class="deadline-task-info">
                        <div class="deadline-task-title">${escapeHtml(task.title)}</div>
                        <div class="deadline-task-date">${daysText} until abandoned</div>
                    </div>
                </div>
            `;
        }

        function renderDeadlineTaskItem(task, type) {
            const statusText = task.days < 0
                ? `${Math.abs(task.days)} day${Math.abs(task.days) !== 1 ? 's' : ''} overdue`
                : task.days === 0
                    ? 'Due today'
                    : `${task.days} day${task.days !== 1 ? 's' : ''} until due`;

            const dismissIcon = task.dismissed ? 'bi-bell-slash-fill' : 'bi-bell-slash';
            const dismissTitle = task.dismissed ? 'Enable warnings' : 'Silence future warnings';

            return `
                <div class="deadline-task-item ${task.dismissed ? 'dismissed' : ''}" data-task-id="${task.id}">
                    <div class="deadline-task-info">
                        <div class="deadline-task-title">${escapeHtml(task.title)}</div>
                        <div class="deadline-task-date">${statusText}</div>
                    </div>
                    <button class="deadline-dismiss-btn ${task.dismissed ? 'dismissed' : ''}" title="${dismissTitle}">
                        <i class="bi ${dismissIcon}"></i>
                    </button>
                </div>
            `;
        }

        async function updateTaskDeadlineDismiss(taskId, dismissed) {
            try {
                const response = await fetch(`/tasks/api/${taskId}/update/`, {
                    method: 'PATCH',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-CSRFToken': csrfToken
                    },
                    body: JSON.stringify({ deadline_dismissed: dismissed })
                });

                const data = await response.json();
                if (data.success) {
                    if (taskDeadlinesMap[taskId]) {
                        taskDeadlinesMap[taskId].deadline_dismissed = dismissed;
                    }
                    renderDeadlineDropdown();
                    updateDeadlineWarningIcon();
                }
            } catch (error) {
                console.error('Error updating deadline dismiss:', error);
            }
        }

        function closeDeadlineDropdown() {
            document.getElementById('deadline-dropdown').classList.remove('active');
        }

        function closeFilterDropdown() {
            const filterDropdown = document.getElementById('filter-dropdown');
            const filterIcon = document.getElementById('filter-icon');
            if (filterDropdown) {
                filterDropdown.classList.remove('active');
            }
            if (filterIcon) {
                filterIcon.classList.remove('active');
            }
        }

        // ========== Terminal State Management ==========

        function updateStateTypeLabels() {
            // Update state groups with terminal class and delete link
            updateTerminalStateGroup();
        }

        function getTerminalStateId() {
            // First check for explicitly marked terminal state
            const terminalItem = document.querySelector('.state-item[data-is-terminal="true"]');
            if (terminalItem) {
                return parseInt(terminalItem.dataset.stateId);
            }
            // Fallback: Get last non-system state item (exclude Abandoned and other system states)
            const stateItems = document.querySelectorAll('.state-item:not(#no-states):not([data-is-system="true"])');
            if (stateItems.length === 0) return null;
            return parseInt(stateItems[stateItems.length - 1].dataset.stateId);
        }

        function updateTerminalStateGroup() {
            // Remove all existing delete completed links
            document.querySelectorAll('.delete-completed-link').forEach(el => el.remove());
            document.querySelectorAll('.state-group').forEach(g => g.classList.remove('terminal-state'));

            const terminalStateId = getTerminalStateId();
            if (!terminalStateId) return;

            const terminalGroup = document.querySelector(`.state-group[data-state-id="${terminalStateId}"]`);
            if (terminalGroup) {
                terminalGroup.classList.add('terminal-state');
                const body = terminalGroup.querySelector('.state-group-body');
                if (body) {
                    // Only show delete link if there are tasks in the terminal state
                    const taskCards = body.querySelectorAll('.task-card');
                    if (taskCards.length > 0) {
                        const deleteLink = document.createElement('div');
                        deleteLink.className = 'delete-completed-link';
                        deleteLink.textContent = 'Delete Completed Tasks';
                        deleteLink.onclick = (e) => {
                            e.stopPropagation();
                            deleteCompletedTasks(terminalStateId);
                        };
                        // Insert at the beginning of the body
                        body.insertBefore(deleteLink, body.firstChild);
                    }
                }
            }
        }

        async function deleteCompletedTasks(stateId) {
            const body = document.querySelector(`#states-content .state-group-body[data-state-id="${stateId}"]`);
            if (!body) return;

            const taskCards = body.querySelectorAll('.task-card');
            const count = taskCards.length;

            if (count === 0) {
                await showAlertModal('There are no tasks to delete.', 'No Tasks');
                return;
            }

            const confirmed = await showConfirmModal(
                `Are you sure you want to permanently delete ${count} task${count > 1 ? 's' : ''}?`,
                'Delete Completed Tasks',
                'Delete All'
            );

            if (!confirmed) return;

            // Collect task IDs to delete
            const taskIds = [];
            taskCards.forEach(card => taskIds.push(parseInt(card.dataset.taskId)));

            // Delete all tasks in the terminal state
            for (const taskId of taskIds) {
                try {
                    await fetch(`/tasks/api/${taskId}/delete/`, {
                        method: 'DELETE',
                        headers: {
                            'X-CSRFToken': csrfToken
                        }
                    });
                    // Remove from all views
                    document.querySelectorAll(`.kanban-card[data-task-id="${taskId}"], .task-card[data-task-id="${taskId}"]`).forEach(card => card.remove());
                    // Remove from tags map
                    delete taskTagsMap[taskId];
                    // Remove from schedules map and re-render calendar
                    delete taskSchedulesMap[taskId];
                    // Remove from deadlines map and update warning icon
                    delete taskDeadlinesMap[taskId];
                    updateDeadlineWarningIcon();
                    renderScheduledTasks();
                } catch (error) {
                    console.error('Error deleting task:', error);
                }
            }

            updatePanelCounts();
            updateKanbanCounts();
        }

        // Add new task on Enter
        document.getElementById('new-task-input').addEventListener('keypress', async function(e) {
            if (e.key === 'Enter' && this.value.trim()) {
                const title = this.value.trim();
                this.value = '';

                try {
                    const response = await fetch('/tasks/api/create/', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'X-CSRFToken': csrfToken
                        },
                        body: JSON.stringify({ title })
                    });

                    const data = await response.json();
                    if (data.success) {
                        addTaskToKanban(data.task);
                    }
                } catch (error) {
                    console.error('Error creating task:', error);
                }
            }
        });

        function addTaskToKanban(task) {
            // Initialize tags map for the new task
            taskTagsMap[task.id] = task.tags || [];
            // Initialize schedules for the new task
            taskSchedulesMap[task.id] = task.schedules || [];
            // Initialize deadline map for the new task
            taskDeadlinesMap[task.id] = {
                deadline: task.deadline || null,
                deadline_dismissed: task.deadline_dismissed || false,
                state_id: task.state_id,
                critical: task.critical || false
            };

            // Helper to create a task card
            function createTaskCard(withHighlight) {
                const card = document.createElement('div');
                const isScheduled = (taskSchedulesMap[task.id] || []).length > 0;
                card.className = 'task-card' + (task.critical ? ' critical' : '') + (isScheduled ? ' scheduled' : '') + (withHighlight ? ' highlight-new' : '');
                card.dataset.taskId = task.id;
                card.tabIndex = 0; // Make focusable
                card.innerHTML = `
                    <div class="task-card-content">
                        <i class="bi bi-grip-vertical task-card-drag-handle"></i>
                        <div class="task-card-title">${escapeHtml(task.title)}</div>
                        ${task.critical ? '<div class="task-card-icons"><i class="bi bi-exclamation-circle-fill task-critical-icon" title="Critical: High priority task requiring immediate attention"></i></div>' : ''}
                    </div>
                `;

                // Setup drag events and context menu for the new card
                setupTaskCardDragEvents(card);
                card.addEventListener('contextmenu', function(e) {
                    e.preventDefault();
                    showContextMenu(e, parseInt(this.dataset.taskId), 'openTaskPanel');
                });

                // Add Enter key listener to open task panel
                card.addEventListener('keydown', function(e) {
                    if (e.key === 'Enter') {
                        e.preventDefault();
                        openTaskPanel(parseInt(this.dataset.taskId));
                    }
                });

                return card;
            }

            // Expand both Tasks and Calendar panels if collapsed
            const tasksPanel = document.getElementById('tasks-panel');
            if (tasksPanel && tasksPanel.classList.contains('collapsed')) {
                tasksPanel.classList.remove('collapsed');
            }
            const calendarPanel = document.getElementById('calendar-panel');
            if (calendarPanel && calendarPanel.classList.contains('collapsed')) {
                calendarPanel.classList.remove('collapsed');
            }

            // Always add to states-content (it's the master view)
            const firstStateGroup = document.querySelector('#states-content .state-group');
            if (firstStateGroup) {
                const stateGroupBody = firstStateGroup.querySelector('.state-group-body');
                if (stateGroupBody) {
                    const statesCard = createTaskCard(currentGroupBy === 'states');
                    stateGroupBody.insertBefore(statesCard, stateGroupBody.firstChild);

                    if (currentGroupBy === 'states') {
                        // Expand the first state group if collapsed
                        if (firstStateGroup.classList.contains('collapsed')) {
                            firstStateGroup.classList.remove('collapsed');
                        }
                        // Focus the newly created card
                        setTimeout(() => {
                            statesCard.focus();
                        }, 100);
                        // Remove highlight class after animation
                        setTimeout(() => {
                            statesCard.classList.remove('highlight-new');
                        }, 4500);
                    }
                }
            }

            // If currently viewing by tags, rebuild to show new task in Untagged group
            if (currentGroupBy === 'tags') {
                buildTagGroups(task.id);
            }

            // If currently viewing by schedules, rebuild to show new task in Not Scheduled group
            if (currentGroupBy === 'schedules') {
                buildScheduleGroups(task.id);
            }

            // Update counts
            updatePanelCounts();
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }


        function closePanel() {
            document.getElementById('panel-overlay').classList.remove('active');
            document.getElementById('slide-panel').classList.remove('active');
            currentTaskId = null;
        }

        document.getElementById('panel-close').addEventListener('click', closePanel);
        document.getElementById('panel-overlay').addEventListener('click', closePanel);

        // Auto-resize title textarea
        function autoResizeTitle() {
            const titleEl = document.getElementById('panel-title');
            titleEl.style.height = 'auto';
            titleEl.style.height = titleEl.scrollHeight + 'px';
        }

        // Configure marked to open links in new tabs
        const renderer = new marked.Renderer();
        const originalLinkRenderer = renderer.link.bind(renderer);
        renderer.link = function(href, title, text) {
            const html = originalLinkRenderer(href, title, text);
            return html.replace('<a ', '<a target="_blank" rel="noopener noreferrer" ');
        };
        marked.setOptions({ renderer: renderer });

        // Markdown preview handling
        const detailsTextarea = document.getElementById('panel-details');
        const detailsPreview = document.getElementById('panel-details-preview');
        const markdownEditBtn = document.getElementById('markdown-edit-btn');
        const markdownViewBtn = document.getElementById('markdown-view-btn');

        function showMarkdownPreview() {
            const text = detailsTextarea.value.trim();
            detailsPreview.innerHTML = text ? marked.parse(text) : '';
            detailsTextarea.style.display = 'none';
            detailsPreview.style.display = 'block';
            markdownEditBtn.classList.remove('active');
            markdownViewBtn.classList.add('active');
        }

        function showMarkdownEdit() {
            detailsPreview.style.display = 'none';
            detailsTextarea.style.display = 'block';
            markdownEditBtn.classList.add('active');
            markdownViewBtn.classList.remove('active');
            detailsTextarea.focus();
        }

        // Toggle buttons
        markdownEditBtn.addEventListener('click', showMarkdownEdit);
        markdownViewBtn.addEventListener('click', showMarkdownPreview);

        // Clicking into textarea switches to edit mode
        detailsTextarea.addEventListener('focus', function() {
            markdownEditBtn.classList.add('active');
            markdownViewBtn.classList.remove('active');
        });

        // Track whether we're interacting with tag controls
        let isInteractingWithTags = false;

        // Clicking outside switches to view mode
        detailsTextarea.addEventListener('blur', function() {
            // Small delay to allow clicking the toggle buttons or tag controls
            setTimeout(() => {
                if (!isInteractingWithTags) {
                    showMarkdownPreview();
                }
            }, 150);
        });

        // Clicking preview switches to edit mode and positions cursor at click location
        detailsPreview.addEventListener('click', function(e) {
            // Get click position relative to preview
            const previewRect = detailsPreview.getBoundingClientRect();
            const relativeY = (e.clientY - previewRect.top) / previewRect.height;

            // Switch to edit mode
            detailsPreview.style.display = 'none';
            detailsTextarea.style.display = 'block';
            markdownEditBtn.classList.add('active');
            markdownViewBtn.classList.remove('active');

            // Position cursor based on relative click position
            detailsTextarea.focus();
            const textLength = detailsTextarea.value.length;

            // Map the relative Y position to a character position
            // This is approximate but gives a reasonable starting point
            const cursorPos = Math.floor(relativeY * textLength);
            detailsTextarea.setSelectionRange(cursorPos, cursorPos);

            // Scroll to make cursor visible
            const lineHeight = parseInt(getComputedStyle(detailsTextarea).lineHeight) || 20;
            const charsPerLine = 60; // Approximate
            const lineNumber = Math.floor(cursorPos / charsPerLine);
            detailsTextarea.scrollTop = lineNumber * lineHeight - detailsTextarea.clientHeight / 2;
        });

        // Auto-save on changes
        ['panel-title', 'panel-details', 'panel-critical'].forEach(id => {
            const el = document.getElementById(id);
            const event = (el.type === 'checkbox') ? 'change' : 'input';
            el.addEventListener(event, () => {
                if (id === 'panel-title') autoResizeTitle();
                if (saveTimeout) clearTimeout(saveTimeout);
                saveTimeout = setTimeout(saveCurrentTask, 500);
            });
        });

        // Handle Enter key in title field - save immediately without creating line break
        document.getElementById('panel-title').addEventListener('keydown', function(e) {
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                // Trigger immediate save
                if (saveTimeout) clearTimeout(saveTimeout);
                saveCurrentTask();
                // Blur the field to indicate save completed
                this.blur();
            }
        });

        async function saveCurrentTask() {
            if (!currentTaskId) return;

            const title = document.getElementById('panel-title').value.trim();
            const details = document.getElementById('panel-details').value;
            const critical = document.getElementById('panel-critical').checked;

            try {
                const response = await fetch(`/tasks/api/${currentTaskId}/update/`, {
                    method: 'PATCH',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-CSRFToken': csrfToken
                    },
                    body: JSON.stringify({ title, details, critical })
                });

                const data = await response.json();
                if (data.success) {
                    handleTaskStateChange(data.task);
                }
            } catch (error) {
                console.error('Error updating task:', error);
            }
        }

        function updateTaskInList(task) {
            const taskItem = document.querySelector(`.task-item[data-task-id="${task.id}"]`);
            if (!taskItem) return;

            taskItem.className = 'task-item' + (task.critical ? ' critical' : '');

            const titleEl = taskItem.querySelector('.task-title');
            titleEl.textContent = task.title;

            let detailsEl = taskItem.querySelector('.task-details-preview');
            if (task.details) {
                if (!detailsEl) {
                    detailsEl = document.createElement('div');
                    detailsEl.className = 'task-details-preview';
                    taskItem.querySelector('.task-content').appendChild(detailsEl);
                }
                detailsEl.textContent = task.details.substring(0, 50) + (task.details.length > 50 ? '...' : '');
            } else if (detailsEl) {
                detailsEl.remove();
            }
        }

        // Delete task
        document.getElementById('panel-delete').addEventListener('click', async () => {
            if (!currentTaskId) return;
            const confirmed = await showConfirmModal('Are you sure you want to delete this task?', 'Delete Task', 'Delete');
            if (!confirmed) return;
            await deleteTask(currentTaskId);
            closePanel();
        });

        // Save and close button handler
        document.getElementById('panel-save-close').addEventListener('click', async () => {
            if (!currentTaskId) return;
            // Trigger a save (even though auto-save handles it)
            await saveCurrentTask();
            closePanel();
        });

        // Mark as done button handler
        document.getElementById('panel-mark-done').addEventListener('click', async () => {
            if (!currentTaskId) return;
            const terminalStateId = getTerminalStateId();
            if (!terminalStateId) return;

            const markDoneBtn = document.getElementById('panel-mark-done');
            const isAlreadyDone = markDoneBtn.classList.contains('is-done');

            // If already done, do nothing (or could toggle back to previous state if we stored it)
            if (isAlreadyDone) return;

            try {
                const response = await fetch(`/tasks/api/${currentTaskId}/update/`, {
                    method: 'PATCH',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-CSRFToken': csrfToken
                    },
                    body: JSON.stringify({ state_id: terminalStateId })
                });

                const data = await response.json();
                if (data.success) {
                    // Update button state
                    markDoneBtn.classList.add('is-done');
                    markDoneBtn.querySelector('span').textContent = 'Task Complete!';
                    markDoneBtn.querySelector('i').className = 'bi bi-check-circle-fill';

                    // Update the UI
                    handleTaskStateChange(data.task);
                }
            } catch (error) {
                console.error('Error marking task as done:', error);
            }
        });

        // Panel deadline preset buttons
        document.querySelectorAll('.deadline-preset-btn').forEach(btn => {
            btn.addEventListener('click', async function() {
                if (!currentTaskId) return;
                const preset = this.dataset.preset;

                if (preset === 'custom') {
                    // Show custom date modal
                    showCustomDateModal();
                } else {
                    const deadlineDate = getPresetDate(preset);
                    await updateTaskDeadline(currentTaskId, deadlineDate);
                    updatePresetButtonStates(deadlineDate);
                    updatePanelDeadlineStatus(deadlineDate);
                }
            });
        });

        // Custom date modal functions
        function showCustomDateModal() {
            const modal = document.getElementById('custom-date-modal');
            const dateInput = document.getElementById('custom-date-input');

            // Pre-populate with current deadline if exists
            const currentDeadline = taskDeadlinesMap[currentTaskId]?.deadline;
            dateInput.value = currentDeadline || '';

            modal.classList.add('active');
            dateInput.focus();
        }

        document.getElementById('custom-date-cancel').addEventListener('click', function() {
            document.getElementById('custom-date-modal').classList.remove('active');
        });

        document.getElementById('custom-date-confirm').addEventListener('click', async function() {
            if (!currentTaskId) return;
            const dateInput = document.getElementById('custom-date-input');
            const deadlineDate = dateInput.value || null;

            await updateTaskDeadline(currentTaskId, deadlineDate);
            updatePresetButtonStates(deadlineDate);
            updatePanelDeadlineStatus(deadlineDate);

            document.getElementById('custom-date-modal').classList.remove('active');
        });

        // Close custom date modal on overlay click
        document.getElementById('custom-date-modal').addEventListener('click', function(e) {
            if (e.target === this) {
                this.classList.remove('active');
            }
        });

        // Panel deadline clear button
        document.getElementById('panel-deadline-clear').addEventListener('click', async function() {
            if (!currentTaskId) return;
            await updateTaskDeadline(currentTaskId, null);
            updatePresetButtonStates(null);
            updatePanelDeadlineStatus(null);
        });

        // Panel deadline change button
        document.getElementById('panel-deadline-change').addEventListener('click', function() {
            // Show preset buttons again
            const presetsEl = document.querySelector('.deadline-presets');
            if (presetsEl) {
                const presetBtns = presetsEl.querySelectorAll('.deadline-preset-btn');
                presetBtns.forEach(btn => btn.style.display = '');
            }
            // Hide change button
            this.style.display = 'none';
        });

        // Panel unschedule all button
        document.getElementById('panel-remove-from-calendar').addEventListener('click', async function() {
            if (!currentTaskId) return;
            confirmRemoveFromCalendar(currentTaskId);
        });

        async function updateTaskDeadline(taskId, deadline) {
            try {
                const response = await fetch(`/tasks/api/${taskId}/update/`, {
                    method: 'PATCH',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-CSRFToken': csrfToken
                    },
                    body: JSON.stringify({
                        deadline: deadline,
                        deadline_dismissed: false
                    })
                });

                const data = await response.json();
                if (data.success) {
                    taskDeadlinesMap[taskId] = {
                        deadline: deadline,
                        deadline_dismissed: false,
                        state_id: data.task.state_id,
                        critical: data.task.critical || false
                    };
                    updateDeadlineWarningIcon();
                    handleTaskStateChange(data.task);
                }
            } catch (error) {
                console.error('Error updating deadline:', error);
            }
        }

        function updatePresetButtonStates(deadlineDate) {
            let matchedPreset = false;
            document.querySelectorAll('.deadline-preset-btn').forEach(btn => {
                const preset = btn.dataset.preset;
                if (preset === 'custom') return; // Handle custom separately
                const presetDate = getPresetDate(preset);
                const isMatch = deadlineDate === presetDate;
                if (isMatch) matchedPreset = true;
                btn.classList.toggle('active', isMatch);
            });

            // Custom button is active if there's a deadline but no preset matched
            const customBtn = document.getElementById('deadline-custom-btn');
            if (customBtn) {
                customBtn.classList.toggle('active', deadlineDate && !matchedPreset);
            }
        }

        function updatePanelDeadlineStatus(deadlineDate) {
            const statusEl = document.getElementById('panel-deadline-status');
            const presetsEl = document.querySelector('.deadline-presets');
            const changeBtn = document.getElementById('panel-deadline-change');

            if (!deadlineDate) {
                statusEl.innerHTML = '';
                // Show preset buttons when no deadline is set
                if (presetsEl) {
                    const presetBtns = presetsEl.querySelectorAll('.deadline-preset-btn');
                    presetBtns.forEach(btn => btn.style.display = '');
                }
                // Hide change button when no deadline
                if (changeBtn) changeBtn.style.display = 'none';
                return;
            }
            const status = getDeadlineStatus(deadlineDate);
            if (!status) {
                statusEl.innerHTML = '';
                // Show preset buttons when no deadline is set
                if (presetsEl) {
                    const presetBtns = presetsEl.querySelectorAll('.deadline-preset-btn');
                    presetBtns.forEach(btn => btn.style.display = '');
                }
                // Hide change button when no deadline
                if (changeBtn) changeBtn.style.display = 'none';
                return;
            }
            statusEl.innerHTML = `
                <span class="deadline-status ${status.status}">
                    ${status.label}
                </span>
            `;

            // Hide preset buttons when deadline is set (but keep change and clear buttons visible)
            if (presetsEl) {
                const presetBtns = presetsEl.querySelectorAll('.deadline-preset-btn');
                presetBtns.forEach(btn => btn.style.display = 'none');
            }
            // Show change button when deadline is set
            if (changeBtn) changeBtn.style.display = '';
        }

        async function deleteTask(taskId) {
            try {
                const response = await fetch(`/tasks/api/${taskId}/delete/`, {
                    method: 'DELETE',
                    headers: {
                        'X-CSRFToken': csrfToken
                    }
                });

                const data = await response.json();
                if (data.success) {
                    // Remove from all views
                    const allCards = document.querySelectorAll(`.kanban-card[data-task-id="${taskId}"], .task-card[data-task-id="${taskId}"]`);
                    allCards.forEach(card => {
                        card.style.opacity = '0';
                        card.style.transform = 'translateX(20px)';
                        card.style.transition = 'all 0.3s';
                        setTimeout(() => {
                            card.remove();
                        }, 300);
                    });

                    // Update counts after removal animation
                    setTimeout(() => {
                        updateKanbanCounts();
                        updatePanelCounts();
                        // Update tag group counts if in tags view
                        if (currentGroupBy === 'tags') {
                            document.querySelectorAll('#tags-content .state-group').forEach(group => {
                                const count = group.querySelectorAll('.task-card').length;
                                const countEl = group.querySelector('.state-group-count');
                                if (countEl) countEl.textContent = count;
                            });
                        }
                    }, 300);

                    // Remove from tags map
                    delete taskTagsMap[taskId];
                    // Remove from schedules map and re-render calendar
                    delete taskSchedulesMap[taskId];
                    // Remove from deadlines map and update warning icon
                    delete taskDeadlinesMap[taskId];
                    updateDeadlineWarningIcon();
                    renderScheduledTasks();
                }
            } catch (error) {
                console.error('Error deleting task:', error);
            }
        }

        // ========== Settings Dropdown ==========

        // Toggle settings dropdown
        document.getElementById('settings-gear').addEventListener('click', (e) => {
            e.stopPropagation();
            const dropdown = document.getElementById('settings-dropdown');
            const isActive = dropdown.classList.contains('active');

            // Close other dropdowns first
            closeFilterDropdown();
            closeDeadlineDropdown();

            if (isActive) {
                closeSettingsDropdown();
            } else {
                dropdown.classList.add('active');
            }
        });

        function closeSettingsDropdown() {
            document.getElementById('settings-dropdown').classList.remove('active');
        }

        // Handle collapsible sections in settings dropdown
        document.querySelectorAll('#settings-dropdown .settings-section-header').forEach(header => {
            header.addEventListener('click', function(e) {
                // Don't toggle if clicking on info icon
                if (e.target.closest('.settings-info-icon')) return;

                const section = this.closest('.settings-section');
                section.classList.toggle('collapsed');
            });
        });

        // Close settings dropdown when clicking outside
        document.addEventListener('click', (e) => {
            const dropdown = document.getElementById('settings-dropdown');
            const gear = document.getElementById('settings-gear');
            if (dropdown.classList.contains('active') &&
                !dropdown.contains(e.target) &&
                !gear.contains(e.target)) {
                closeSettingsDropdown();
            }
        });

        // Global Escape and Delete key handler for slide-out panels, dropdowns, and batch delete
        document.addEventListener('keydown', function(e) {
            if (e.key === 'Escape') {
                // Don't handle if a modal is active (modals handle their own Escape)
                const activeModal = document.querySelector('.modal-overlay.active');
                if (activeModal) return;

                // Close dropdowns first
                const settingsDropdown = document.getElementById('settings-dropdown');
                if (settingsDropdown && settingsDropdown.classList.contains('active')) {
                    closeSettingsDropdown();
                    return;
                }

                // Check if any slide-out panel is open and close it
                const taskPanel = document.getElementById('slide-panel');
                const timeslotPanel = document.getElementById('timeslot-panel');

                if (taskPanel && taskPanel.classList.contains('active')) {
                    closePanel();
                } else if (timeslotPanel && timeslotPanel.classList.contains('active')) {
                    closeTimeslotPanel();
                }
            }

            // Delete key handler for batch delete
            if (e.key === 'Delete' || e.key === 'Backspace') {
                // Don't handle if a modal is active
                const activeModal = document.querySelector('.modal-overlay.active');
                if (activeModal) return;

                // Don't handle if user is typing in an input/textarea
                const activeElement = document.activeElement;
                if (activeElement && (activeElement.tagName === 'INPUT' || activeElement.tagName === 'TEXTAREA')) {
                    return;
                }

                // Don't handle if any slide-out panel is open
                const taskPanel = document.getElementById('slide-panel');
                const timeslotPanel = document.getElementById('timeslot-panel');
                if ((taskPanel && taskPanel.classList.contains('active')) ||
                    (timeslotPanel && timeslotPanel.classList.contains('active'))) {
                    return;
                }

                // Trigger batch delete if tasks are selected
                if (selectedTaskIds.size > 0) {
                    e.preventDefault();
                    batchDeleteTasks();
                }
            }
        });

        // Edit state name inline
        function editStateName(stateId, spanElement) {
            const currentName = spanElement.textContent.trim();
            const input = document.createElement('input');
            input.type = 'text';
            input.className = 'state-name-input';
            input.value = currentName;

            spanElement.replaceWith(input);
            input.focus();
            input.select();

            async function saveStateName() {
                const newName = input.value.trim();
                if (newName && newName !== currentName) {
                    try {
                        const response = await fetch(`/tasks/api/states/${stateId}/update/`, {
                            method: 'PATCH',
                            headers: {
                                'Content-Type': 'application/json',
                                'X-CSRFToken': csrfToken
                            },
                            body: JSON.stringify({ name: newName })
                        });

                        const data = await response.json();
                        if (data.success) {
                            // Update local list
                            const state = statesList.find(s => s.id === stateId);
                            if (state) state.name = newName;

                            // Update the state item data attribute
                            const stateItem = input.closest('.state-item');
                            if (stateItem) stateItem.dataset.stateName = newName;

                            // Update state group name in tasks panel
                            const stateGroup = document.querySelector(`.state-group[data-state-id="${stateId}"]`);
                            if (stateGroup) {
                                const nameSpan = stateGroup.querySelector('.state-group-name');
                                if (nameSpan) nameSpan.textContent = newName;
                            }

                            // Update metric pill text
                            const metricPill = document.querySelector(`.metric-pill[data-state-id="${stateId}"]`);
                            if (metricPill) {
                                const countSpan = metricPill.querySelector('.metric-count');
                                const count = countSpan ? countSpan.textContent : '0';
                                metricPill.innerHTML = `${escapeHtml(newName)}: <span class="metric-count">${count}</span>`;
                            }

                            restoreStateSpan(newName);
                        } else {
                            showAlertModal(data.error || 'Failed to rename state', 'Error');
                            restoreStateSpan(currentName);
                        }
                    } catch (error) {
                        console.error('Error renaming state:', error);
                        restoreStateSpan(currentName);
                    }
                } else {
                    restoreStateSpan(currentName);
                }
            }

            function restoreStateSpan(name) {
                const span = document.createElement('span');
                span.className = 'state-name';
                span.textContent = name;
                span.onclick = () => editStateName(stateId, span);
                input.replaceWith(span);
            }

            input.addEventListener('blur', saveStateName);
            input.addEventListener('keydown', function(e) {
                if (e.key === 'Enter') {
                    input.blur();
                } else if (e.key === 'Escape') {
                    restoreStateSpan(currentName);
                }
            });
        }

        // ========== States Management ==========

        // Store states locally
        let statesList = [
            {% for state in states %}
            { id: {{ state.id }}, name: "{{ state.name|escapejs }}", order: {{ state.order }}, bootstrap_icon: "{{ state.bootstrap_icon|escapejs }}" }{% if not forloop.last %},{% endif %}
            {% endfor %}
        ];

        // Icon picker for states
        const stateIcons = [
            'bi-inbox', 'bi-inbox-fill', 'bi-play-circle', 'bi-play-fill', 'bi-arrow-right-circle',
            'bi-hourglass-split', 'bi-clock', 'bi-clock-fill', 'bi-pause-circle', 'bi-pause-fill',
            'bi-check-circle', 'bi-check-circle-fill', 'bi-check2-circle', 'bi-check-lg',
            'bi-star', 'bi-star-fill', 'bi-flag', 'bi-flag-fill', 'bi-bookmark', 'bi-bookmark-fill',
            'bi-lightning', 'bi-lightning-fill', 'bi-fire', 'bi-rocket', 'bi-bullseye',
            'bi-eye', 'bi-eye-fill', 'bi-search', 'bi-binoculars', 'bi-crosshair',
            'bi-gear', 'bi-gear-fill', 'bi-tools', 'bi-wrench', 'bi-hammer',
            'bi-pencil', 'bi-pencil-fill', 'bi-brush', 'bi-palette', 'bi-vector-pen',
            'bi-chat', 'bi-chat-fill', 'bi-chat-dots', 'bi-chat-dots-fill', 'bi-megaphone',
            'bi-people', 'bi-people-fill', 'bi-person', 'bi-person-fill', 'bi-person-check',
            'bi-folder', 'bi-folder-fill', 'bi-file-earmark', 'bi-file-text', 'bi-journal',
            'bi-calendar', 'bi-calendar-event', 'bi-calendar-check', 'bi-alarm', 'bi-bell',
            'bi-heart', 'bi-heart-fill', 'bi-emoji-smile', 'bi-hand-thumbs-up', 'bi-trophy',
            'bi-shield-check', 'bi-lock', 'bi-unlock', 'bi-key', 'bi-safe',
            'bi-code-slash', 'bi-terminal', 'bi-bug', 'bi-cpu', 'bi-database',
            'bi-cart', 'bi-bag', 'bi-gift', 'bi-currency-dollar', 'bi-credit-card'
        ];

        let currentIconPickerStateId = null;
        let iconPickerElement = null;

        function openIconPicker(stateId, btnElement) {
            closeIconPicker();

            currentIconPickerStateId = stateId;
            const stateItem = btnElement.closest('.state-item');
            const currentIcon = stateItem.dataset.icon || '';

            const picker = document.createElement('div');
            picker.className = 'icon-picker-popup';
            picker.id = 'icon-picker-popup';

            // Custom icon input
            let html = '<div class="icon-picker-custom">';
            html += '<input type="text" id="custom-icon-input" placeholder="bi-icon-name" value="' + escapeHtml(currentIcon) + '">';
            html += '<button onclick="applyCustomIcon()">Apply</button>';
            html += '</div>';

            // Icon grid
            html += '<div class="icon-picker-grid">';
            stateIcons.forEach(icon => {
                const isSelected = icon === currentIcon ? ' selected' : '';
                html += `<button class="icon-picker-item${isSelected}" data-icon="${icon}" onclick="selectStateIcon('${icon}')"><i class="bi ${icon}"></i></button>`;
            });
            html += '</div>';
            html += '<button class="icon-picker-clear" onclick="selectStateIcon(\'\')">Remove icon</button>';

            picker.innerHTML = html;

            // Position near the button
            const rect = btnElement.getBoundingClientRect();
            picker.style.left = Math.min(rect.left, window.innerWidth - 300) + 'px';
            picker.style.top = (rect.bottom + 5) + 'px';

            document.body.appendChild(picker);
            iconPickerElement = picker;

            // Close on outside click
            setTimeout(() => {
                document.addEventListener('click', handleIconPickerOutsideClick);
            }, 0);
        }

        function handleIconPickerOutsideClick(e) {
            const picker = document.getElementById('icon-picker-popup');
            if (picker && !picker.contains(e.target) && !e.target.closest('.state-icon-btn')) {
                closeIconPicker();
            }
        }

        function closeIconPicker() {
            const picker = document.getElementById('icon-picker-popup');
            if (picker) {
                picker.remove();
            }
            document.removeEventListener('click', handleIconPickerOutsideClick);
            currentIconPickerStateId = null;
            iconPickerElement = null;
        }

        function applyCustomIcon() {
            const input = document.getElementById('custom-icon-input');
            if (input) {
                let icon = input.value.trim();
                // Add bi- prefix if not present
                if (icon && !icon.startsWith('bi-')) {
                    icon = 'bi-' + icon;
                }
                selectStateIcon(icon);
            }
        }

        async function selectStateIcon(icon) {
            if (currentIconPickerStateId === null) return;

            const stateId = currentIconPickerStateId;

            try {
                const response = await fetch(`/tasks/api/states/${stateId}/update/`, {
                    method: 'PATCH',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-CSRFToken': csrfToken
                    },
                    body: JSON.stringify({ bootstrap_icon: icon })
                });

                const data = await response.json();
                if (data.success) {
                    // Update the state item in settings
                    const stateItem = document.querySelector(`.state-item[data-state-id="${stateId}"]`);
                    if (stateItem) {
                        stateItem.dataset.icon = icon;
                        const iconBtn = stateItem.querySelector('.state-icon-btn i');
                        iconBtn.className = 'bi ' + (icon || 'bi-plus-circle-dotted');
                        if (!icon) {
                            iconBtn.classList.add('bi-plus-circle-dotted');
                        }
                    }

                    // Update state group icon in tasks panel
                    const stateGroup = document.querySelector(`.state-group[data-state-id="${stateId}"]`);
                    if (stateGroup) {
                        const leftDiv = stateGroup.querySelector('.state-group-left');
                        if (leftDiv) {
                            // Remove existing icon if present
                            const existingIcon = leftDiv.querySelector('.state-group-icon');
                            if (existingIcon) existingIcon.remove();

                            // Add new icon if provided
                            if (icon) {
                                const newIcon = document.createElement('i');
                                newIcon.className = `bi ${icon} state-group-icon`;
                                leftDiv.insertBefore(newIcon, leftDiv.firstChild);
                            }
                        }
                    }

                    // Update local states list
                    const state = statesList.find(s => s.id === stateId);
                    if (state) state.bootstrap_icon = icon;

                    closeIconPicker();
                } else {
                    showAlertModal(data.error || 'Failed to update icon', 'Error');
                }
            } catch (error) {
                console.error('Error updating state icon:', error);
            }
        }

        // Add new state on Enter
        document.getElementById('new-state-input').addEventListener('keypress', async function(e) {
            if (e.key === 'Enter' && this.value.trim()) {
                const name = this.value.trim();
                this.value = '';

                try {
                    const response = await fetch('/tasks/api/states/create/', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'X-CSRFToken': csrfToken
                        },
                        body: JSON.stringify({ name })
                    });

                    const data = await response.json();
                    if (data.success) {
                        addStateToList(data.state);
                        statesList.push(data.state);
                    } else {
                        showAlertModal(data.error || 'Failed to create state', 'Error');
                    }
                } catch (error) {
                    console.error('Error creating state:', error);
                }
            }
        });

        function addStateToList(state) {
            // Remove "no states" message if present
            const noStates = document.getElementById('no-states');
            if (noStates) {
                noStates.remove();
            }

            const li = document.createElement('li');
            li.className = 'state-item';
            li.dataset.stateId = state.id;
            li.dataset.stateName = state.name;
            li.dataset.order = state.order;
            li.dataset.icon = state.bootstrap_icon || '';
            li.draggable = true;
            li.innerHTML = `
                <div class="state-item-left">
                    <i class="bi bi-grip-vertical state-drag-handle"></i>
                    <span class="state-name" onclick="editStateName(${state.id}, this)">${escapeHtml(state.name)}</span>
                </div>
                <div class="state-item-right">
                    <button class="state-icon-btn" onclick="openIconPicker(${state.id}, this)" title="Choose icon">
                        <i class="bi bi-plus-circle-dotted"></i>
                    </button>
                    <button class="state-delete" onclick="deleteState(${state.id}, this)" title="Delete state">
                        <i class="bi bi-x-lg"></i>
                    </button>
                </div>
            `;

            // Append to end of list in settings panel
            const stateList = document.getElementById('state-list');
            stateList.appendChild(li);

            // Setup drag events for new item
            setupDragEvents(li);

            // Add state group to tasks panel
            const tasksContent = document.getElementById('tasks-content');
            if (tasksContent) {
                const stateGroup = document.createElement('div');
                stateGroup.className = 'state-group collapsed';
                stateGroup.dataset.stateId = state.id;
                stateGroup.innerHTML = `
                    <div class="state-group-header" onclick="toggleStateGroup(this)">
                        <div class="state-group-left">
                            ${state.bootstrap_icon ? `<i class="bi ${state.bootstrap_icon} state-group-icon"></i>` : ''}
                            <span class="state-group-name">${escapeHtml(state.name)}</span>
                        </div>
                        <div class="state-group-right">
                            <span class="state-group-count" id="panel-count-${state.id}">0</span>
                            <i class="bi bi-chevron-down state-group-toggle"></i>
                        </div>
                    </div>
                    <div class="state-group-body" data-state-id="${state.id}"></div>
                `;
                tasksContent.appendChild(stateGroup);

                // Setup drag-drop handlers for the new state group
                setupStateGroupDragHandlers(stateGroup);
            }

            // Add metric pill to collapsed header
            const metricsContainer = document.getElementById('tasks-collapsed-metrics');
            if (metricsContainer) {
                const pill = document.createElement('span');
                pill.className = 'metric-pill';
                pill.dataset.stateId = state.id;
                pill.innerHTML = `${escapeHtml(state.name)}: <span class="metric-count">0</span>`;
                metricsContainer.appendChild(pill);
            }

            // Update inbox/terminal labels
            updateStateTypeLabels();
        }

        async function toggleTerminalState(stateId, button) {
            // Toggle the terminal state for a given state
            const stateItem = button.closest('.state-item');
            const isCurrentlyTerminal = stateItem.dataset.isTerminal === 'true';

            // If already terminal, don't allow un-setting (must have one terminal state)
            if (isCurrentlyTerminal) {
                showToast('At least one state must be marked as terminal', {
                    duration: 3000,
                    icon: 'bi-info-circle'
                });
                return;
            }

            try {
                const response = await fetch(`/tasks/api/states/${stateId}/update/`, {
                    method: 'PATCH',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-CSRFToken': csrfToken
                    },
                    body: JSON.stringify({ is_terminal: true })
                });

                const data = await response.json();
                if (data.success) {
                    // Update all state items - remove terminal from others
                    document.querySelectorAll('.state-item').forEach(item => {
                        item.classList.remove('terminal-state');
                        item.dataset.isTerminal = 'false';
                        const termBtn = item.querySelector('.state-terminal-btn');
                        if (termBtn) {
                            termBtn.classList.remove('active');
                            termBtn.title = 'Set as terminal state';
                            termBtn.querySelector('i').className = 'bi bi-check-circle';
                        }
                    });

                    // Set the new terminal state
                    stateItem.classList.add('terminal-state');
                    stateItem.dataset.isTerminal = 'true';
                    button.classList.add('active');
                    button.title = 'Terminal state (completed)';
                    button.querySelector('i').className = 'bi bi-check-circle-fill';

                    // Refresh UI
                    updateTerminalStateGroup();
                    updateStateTypeLabels();
                    renderDeadlineDropdown();
                    updateDeadlineWarningIcon();

                    showToast(`"${stateItem.dataset.stateName}" set as terminal state`, {
                        duration: 2000,
                        icon: 'bi-check-circle'
                    });
                } else {
                    showAlertModal(data.error || 'Failed to update state', 'Error');
                }
            } catch (error) {
                console.error('Error updating terminal state:', error);
                showAlertModal('Failed to update state', 'Error');
            }
        }

        let deleteStateId = null;
        let deleteStateButton = null;

        async function deleteState(stateId, button) {
            deleteStateId = stateId;
            deleteStateButton = button;

            try {
                // Get state info including task count
                const response = await fetch(`/tasks/api/states/${stateId}/info/`);
                const data = await response.json();

                if (!data.success) {
                    showAlertModal(data.error || 'Failed to get state info', 'Error');
                    return;
                }

                const { state, total_states } = data;
                const modal = document.getElementById('delete-state-modal');
                const modalTitle = document.getElementById('delete-state-modal-title');
                const modalBody = document.getElementById('delete-state-modal-body');
                const selectContainer = document.getElementById('delete-state-modal-select-container');
                const select = document.getElementById('delete-state-move-to');
                const confirmBtn = document.getElementById('delete-state-confirm-btn');
                const okBtn = document.getElementById('delete-state-ok-btn');

                // Reset modal state
                selectContainer.style.display = 'none';
                confirmBtn.style.display = 'none';
                okBtn.style.display = 'none';

                // Check if this is the last state
                if (total_states <= 1) {
                    modalTitle.textContent = 'Cannot Delete State';
                    modalBody.textContent = 'You must have at least one state. Create another state before deleting this one.';
                    okBtn.style.display = 'inline-block';
                    modal.classList.add('active');
                    return;
                }

                // Check if state has tasks
                if (state.task_count > 0) {
                    modalTitle.textContent = 'Delete State';
                    modalBody.innerHTML = `The state "<strong>${escapeHtml(state.name)}</strong>" contains <strong>${state.task_count} task${state.task_count > 1 ? 's' : ''}</strong>. Select a state to move these tasks to:`;

                    // Populate select with other states
                    select.innerHTML = '';
                    statesList.filter(s => s.id !== stateId).forEach(s => {
                        const option = document.createElement('option');
                        option.value = s.id;
                        option.textContent = s.name;
                        select.appendChild(option);
                    });

                    selectContainer.style.display = 'block';
                    confirmBtn.style.display = 'inline-block';
                    confirmBtn.onclick = () => confirmDeleteState(true);
                } else {
                    modalTitle.textContent = 'Delete State';
                    modalBody.innerHTML = `Are you sure you want to delete the state "<strong>${escapeHtml(state.name)}</strong>"?`;
                    confirmBtn.style.display = 'inline-block';
                    confirmBtn.onclick = () => confirmDeleteState(false);
                }

                modal.classList.add('active');
            } catch (error) {
                console.error('Error getting state info:', error);
            }
        }

        function closeDeleteStateModal() {
            document.getElementById('delete-state-modal').classList.remove('active');
            deleteStateId = null;
            deleteStateButton = null;
        }

        async function confirmDeleteState(moveTasks) {
            if (!deleteStateId) return;

            try {
                const moveToStateId = moveTasks ? document.getElementById('delete-state-move-to').value : null;

                const response = await fetch(`/tasks/api/states/${deleteStateId}/delete/`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-CSRFToken': csrfToken
                    },
                    body: JSON.stringify({ move_to_state_id: moveToStateId ? parseInt(moveToStateId) : null })
                });

                const data = await response.json();
                if (data.success) {
                    // If tasks were moved, update the UI
                    if (moveTasks && moveToStateId) {
                        // Move task cards in the UI
                        const sourceBody = document.querySelector(`.state-group-body[data-state-id="${deleteStateId}"]`);
                        const targetBody = document.querySelector(`.state-group-body[data-state-id="${moveToStateId}"]`);
                        if (sourceBody && targetBody) {
                            const cards = sourceBody.querySelectorAll('.task-card');
                            cards.forEach(card => targetBody.appendChild(card));
                        }
                    }

                    // Remove from state list in settings panel
                    if (deleteStateButton) {
                        const stateItem = deleteStateButton.closest('.state-item');
                        if (stateItem) stateItem.remove();
                    }

                    // Remove state group from tasks panel
                    const stateGroup = document.querySelector(`.state-group[data-state-id="${deleteStateId}"]`);
                    if (stateGroup) stateGroup.remove();

                    // Remove metric pill
                    const metricPill = document.querySelector(`.metric-pill[data-state-id="${deleteStateId}"]`);
                    if (metricPill) metricPill.remove();

                    // Update local list
                    statesList = statesList.filter(s => s.id !== deleteStateId);

                    // Update counts
                    updateStateCounts();

                    // Update inbox/terminal labels
                    updateStateTypeLabels();

                    closeDeleteStateModal();
                } else {
                    showAlertModal(data.error || 'Failed to delete state', 'Error');
                }
            } catch (error) {
                console.error('Error deleting state:', error);
            }
        }

        function updateStateCounts() {
            document.querySelectorAll('.state-group').forEach(group => {
                const stateId = group.dataset.stateId;
                const body = group.querySelector('.state-group-body');
                const count = body ? body.querySelectorAll('.task-card').length : 0;
                const countEl = document.getElementById(`panel-count-${stateId}`);
                if (countEl) countEl.textContent = count;

                // Update metric pill
                const metricPill = document.querySelector(`.metric-pill[data-state-id="${stateId}"] .metric-count`);
                if (metricPill) metricPill.textContent = count;
            });
        }

        // ========== Drag and Drop for States ==========

        let draggedItem = null;

        function setupDragEvents(item) {
            item.addEventListener('dragstart', handleDragStart);
            item.addEventListener('dragend', handleDragEnd);
            item.addEventListener('dragover', handleDragOver);
            item.addEventListener('dragleave', handleDragLeave);
            item.addEventListener('drop', handleDrop);
        }

        function handleDragStart(e) {
            draggedItem = this;
            this.classList.add('dragging');
            e.dataTransfer.effectAllowed = 'move';
        }

        function handleDragEnd(e) {
            this.classList.remove('dragging');
            document.querySelectorAll('.state-item').forEach(item => {
                item.classList.remove('drag-over-top', 'drag-over-bottom');
            });
            document.getElementById('state-list').classList.remove('drag-over-bottom');
            draggedItem = null;
        }

        function handleDragOver(e) {
            e.preventDefault();
            if (this === draggedItem) return;

            const rect = this.getBoundingClientRect();
            const midpoint = rect.top + rect.height / 2;

            // Clear all indicators first
            document.querySelectorAll('.state-item').forEach(item => {
                item.classList.remove('drag-over-top', 'drag-over-bottom');
            });

            // Show indicator on top or bottom half
            if (e.clientY < midpoint) {
                this.classList.add('drag-over-top');
            } else {
                this.classList.add('drag-over-bottom');
            }
        }

        function handleDragLeave(e) {
            this.classList.remove('drag-over-top', 'drag-over-bottom');
        }

        function handleDrop(e) {
            e.preventDefault();
            this.classList.remove('drag-over-top', 'drag-over-bottom');

            if (this === draggedItem) return;

            const stateList = document.getElementById('state-list');
            const rect = this.getBoundingClientRect();
            const midpoint = rect.top + rect.height / 2;
            const dropOnTop = e.clientY < midpoint;

            if (dropOnTop) {
                // Insert before this item
                stateList.insertBefore(draggedItem, this);
            } else {
                // Insert after this item
                if (this.nextSibling) {
                    stateList.insertBefore(draggedItem, this.nextSibling);
                } else {
                    stateList.appendChild(draggedItem);
                }
            }

            // Save new order
            saveStateOrder();
        }

        // Allow dropping at the end of the list by handling drops on the container
        const stateListContainer = document.getElementById('state-list');
        stateListContainer.addEventListener('dragover', function(e) {
            e.preventDefault();
            // Only show bottom indicator if cursor is below all items
            const items = [...this.querySelectorAll('.state-item:not(#no-states):not(.dragging)')];
            if (items.length > 0) {
                const lastItem = items[items.length - 1];
                const lastItemRect = lastItem.getBoundingClientRect();
                if (e.clientY > lastItemRect.bottom) {
                    this.classList.add('drag-over-bottom');
                } else {
                    this.classList.remove('drag-over-bottom');
                }
            }
        });

        stateListContainer.addEventListener('dragleave', function(e) {
            this.classList.remove('drag-over-bottom');
        });

        stateListContainer.addEventListener('drop', function(e) {
            if (!draggedItem) return;

            // Check if we're dropping at the bottom (not on a specific item)
            const items = [...this.querySelectorAll('.state-item:not(#no-states):not(.dragging)')];
            if (items.length > 0) {
                const lastItem = items[items.length - 1];
                const lastItemRect = lastItem.getBoundingClientRect();
                if (e.clientY > lastItemRect.bottom) {
                    e.preventDefault();
                    this.classList.remove('drag-over-bottom');
                    this.appendChild(draggedItem);
                    saveStateOrder();
                }
            }
        });

        async function saveStateOrder() {
            const stateList = document.getElementById('state-list');
            const items = [...stateList.querySelectorAll('.state-item:not(#no-states)')];
            const order = items.map(item => parseInt(item.dataset.stateId));

            try {
                const response = await fetch('/tasks/api/states/reorder/', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-CSRFToken': csrfToken
                    },
                    body: JSON.stringify({ order })
                });

                const data = await response.json();
                if (data.success) {
                    // Update local order values
                    items.forEach((item, index) => {
                        item.dataset.order = index;
                        const state = statesList.find(s => s.id === parseInt(item.dataset.stateId));
                        if (state) state.order = index;
                    });

                    // Reorder the state groups in the Tasks panel to match
                    const tasksContent = document.getElementById('tasks-content');
                    if (tasksContent) {
                        const stateGroups = [...tasksContent.querySelectorAll('.state-group')];
                        order.forEach(stateId => {
                            const group = stateGroups.find(g => parseInt(g.dataset.stateId) === stateId);
                            if (group) {
                                tasksContent.appendChild(group);
                            }
                        });
                    }

                    // Reorder the metric pills in the collapsed Tasks header
                    const metricsContainer = document.getElementById('tasks-collapsed-metrics');
                    if (metricsContainer) {
                        const pills = [...metricsContainer.querySelectorAll('.metric-pill')];
                        order.forEach(stateId => {
                            const pill = pills.find(p => parseInt(p.dataset.stateId) === stateId);
                            if (pill) {
                                metricsContainer.appendChild(pill);
                            }
                        });
                    }

                    // Update inbox/terminal labels
                    updateStateTypeLabels();
                }
            } catch (error) {
                console.error('Error saving state order:', error);
            }
        }

        // Initialize drag events for existing items
        document.querySelectorAll('.state-item:not(#no-states)').forEach(item => {
            setupDragEvents(item);
        });

        // ========== Kanban Board ==========

        // Update column counts
        function updateKanbanCounts() {
            document.querySelectorAll('.kanban-column-body').forEach(body => {
                const stateId = body.dataset.stateId;
                const count = body.querySelectorAll('.kanban-card').length;
                const countEl = document.getElementById(`count-state-${stateId}`);
                if (countEl) countEl.textContent = count;
            });
        }

        // Initialize counts on load
        updateKanbanCounts();

        // Make kanban cards clickable
        document.querySelectorAll('.kanban-card').forEach(card => {
            card.addEventListener('click', function(e) {
                if (e.target.closest('.kanban-card')) {
                    openKanbanPanel(this.dataset.taskId);
                }
            });
        });

        async function fetchAndOpenPanel(taskId) {
            currentTaskId = taskId;

            // Fetch task details from server
            try {
                const response = await fetch(`/tasks/api/${taskId}/`);
                const data = await response.json();

                if (data.success) {
                    document.getElementById('panel-title').value = data.task.title;
                    document.getElementById('panel-critical').checked = data.task.critical;

                    // If task has no details, auto-populate with default template
                    let detailsContent = data.task.details || '';
                    if (!detailsContent.trim()) {
                        const defaultTemplate = detailTemplates.find(t => t.is_default);
                        if (defaultTemplate) {
                            detailsContent = defaultTemplate.content;
                            // Auto-save the template content to the task
                            fetch(`/tasks/api/${taskId}/update/`, {
                                method: 'PATCH',
                                headers: {
                                    'Content-Type': 'application/json',
                                    'X-CSRFToken': csrfToken
                                },
                                body: JSON.stringify({ details: detailsContent })
                            });
                        }
                    }
                    document.getElementById('panel-details').value = detailsContent;

                    // Update "Mark as done" button state
                    const markDoneBtn = document.getElementById('panel-mark-done');
                    const terminalStateId = getTerminalStateId();
                    const isAlreadyDone = data.task.state_id === terminalStateId;
                    markDoneBtn.dataset.stateId = data.task.state_id || '';

                    if (isAlreadyDone) {
                        markDoneBtn.classList.add('is-done');
                        markDoneBtn.querySelector('span').textContent = 'Task Complete!';
                        markDoneBtn.querySelector('i').className = 'bi bi-check-circle-fill';
                    } else {
                        markDoneBtn.classList.remove('is-done');
                        markDoneBtn.querySelector('span').textContent = 'Task Complete!';
                        markDoneBtn.querySelector('i').className = 'bi bi-check-circle';
                    }

                    // Always start in view mode
                    showMarkdownPreview();

                    // Load deadline data
                    updatePresetButtonStates(data.task.deadline);
                    updatePanelDeadlineStatus(data.task.deadline);

                    // Update local map with latest data
                    taskDeadlinesMap[taskId] = {
                        deadline: data.task.deadline,
                        deadline_dismissed: data.task.deadline_dismissed,
                        state_id: data.task.state_id,
                        critical: data.task.critical || false
                    };
                }
            } catch (error) {
                console.error('Error fetching task:', error);
            }

            // Render panel tags
            renderPanelTags(taskId);

            // Render scheduled dates
            renderPanelScheduledDates(taskId);

            document.getElementById('panel-overlay').classList.add('active');
            document.getElementById('slide-panel').classList.add('active');

            // Scroll panel to top
            const panelBody = document.querySelector('#slide-panel .panel-body');
            if (panelBody) {
                panelBody.scrollTop = 0;
            }

            setTimeout(autoResizeTitle, 10);
        }

        async function openKanbanPanel(taskId) {
            await fetchAndOpenPanel(taskId);
        }

        async function openTaskPanel(taskId) {
            const card = document.querySelector(`.task-card[data-task-id="${taskId}"]`);
            if (!card) return;
            await fetchAndOpenPanel(taskId);
        }

        // Kanban drag and drop
        let draggedKanbanCard = null;
        let dropIndicator = null;

        // Create drop indicator element
        function createDropIndicator() {
            const indicator = document.createElement('div');
            indicator.className = 'kanban-drop-indicator';
            indicator.style.cssText = 'height: 3px; background: #6B9080; border-radius: 2px; margin: 0.25rem 0;';
            return indicator;
        }

        function setupKanbanCardDrag(card) {
            card.addEventListener('dragstart', function(e) {
                draggedKanbanCard = this;
                this.classList.add('dragging');
                e.dataTransfer.effectAllowed = 'move';
                e.dataTransfer.setData('text/plain', this.dataset.taskId);
                // Delay to allow drag image to be captured
                setTimeout(() => {
                    this.style.opacity = '0.4';
                }, 0);
            });

            card.addEventListener('dragend', function(e) {
                this.classList.remove('dragging');
                this.style.opacity = '1';
                document.querySelectorAll('.kanban-column-body').forEach(body => {
                    body.classList.remove('drag-over');
                });
                // Remove any drop indicator
                if (dropIndicator && dropIndicator.parentElement) {
                    dropIndicator.remove();
                }
                dropIndicator = null;
                draggedKanbanCard = null;
            });
        }

        // Get drop position within column
        function getDropPosition(columnBody, y) {
            const cards = [...columnBody.querySelectorAll('.kanban-card:not(.dragging)')];

            for (const card of cards) {
                const rect = card.getBoundingClientRect();
                const midpoint = rect.top + rect.height / 2;
                if (y < midpoint) {
                    return { element: card, position: 'before' };
                }
            }
            return { element: null, position: 'end' };
        }

        // Setup drag events for existing kanban cards
        document.querySelectorAll('.kanban-card').forEach(card => {
            setupKanbanCardDrag(card);
        });

        // Setup drop zones on column bodies
        document.querySelectorAll('.kanban-column-body').forEach(body => {
            body.addEventListener('dragover', function(e) {
                e.preventDefault();
                if (!draggedKanbanCard) return;

                this.classList.add('drag-over');

                // Show drop indicator
                const { element, position } = getDropPosition(this, e.clientY);

                if (!dropIndicator) {
                    dropIndicator = createDropIndicator();
                }

                if (position === 'end') {
                    this.appendChild(dropIndicator);
                } else if (element) {
                    element.parentElement.insertBefore(dropIndicator, element);
                }
            });

            body.addEventListener('dragleave', function(e) {
                if (!this.contains(e.relatedTarget)) {
                    this.classList.remove('drag-over');
                    if (dropIndicator && dropIndicator.parentElement === this) {
                        dropIndicator.remove();
                    }
                }
            });

            body.addEventListener('drop', async function(e) {
                e.preventDefault();
                this.classList.remove('drag-over');

                if (!draggedKanbanCard) return;

                const newStateId = parseInt(this.dataset.stateId);
                const taskId = parseInt(draggedKanbanCard.dataset.taskId);
                const oldBody = draggedKanbanCard.parentElement;
                const changedColumn = (oldBody !== this);

                // Get drop position
                const { element, position } = getDropPosition(this, e.clientY);

                // Remove drop indicator
                if (dropIndicator && dropIndicator.parentElement) {
                    dropIndicator.remove();
                }

                // Move card to new position
                if (position === 'end') {
                    this.appendChild(draggedKanbanCard);
                } else if (element) {
                    element.parentElement.insertBefore(draggedKanbanCard, element);
                }

                updateKanbanCounts();

                // Get new order of all cards in this column
                const cardIds = [...this.querySelectorAll('.kanban-card')].map(c => parseInt(c.dataset.taskId));

                // Update state if changed columns
                if (changedColumn) {
                    try {
                        const response = await fetch(`/tasks/api/${taskId}/update/`, {
                            method: 'PATCH',
                            headers: {
                                'Content-Type': 'application/json',
                                'X-CSRFToken': csrfToken
                            },
                            body: JSON.stringify({ state_id: newStateId })
                        });

                        const data = await response.json();
                        if (!data.success) {
                            console.error('Failed to update task state');
                            oldBody.appendChild(draggedKanbanCard);
                            updateKanbanCounts();
                            return;
                        }

                        // Update task everywhere (including calendar)
                        if (data.task) {
                            handleTaskStateChange(data.task);
                        }
                    } catch (error) {
                        console.error('Error updating task state:', error);
                        oldBody.appendChild(draggedKanbanCard);
                        updateKanbanCounts();
                        return;
                    }
                }

                // Save new order
                try {
                    await fetch('/tasks/api/tasks/reorder/', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'X-CSRFToken': csrfToken
                        },
                        body: JSON.stringify({ task_ids: cardIds })
                    });
                } catch (error) {
                    console.error('Error saving task order:', error);
                }
            });
        });

        function handleTaskStateChange(task) {
            // Update deadline map with new state
            if (taskDeadlinesMap[task.id]) {
                taskDeadlinesMap[task.id].state_id = task.state_id;
                if (task.deadline !== undefined) {
                    taskDeadlinesMap[task.id].deadline = task.deadline;
                }
                if (task.deadline_dismissed !== undefined) {
                    taskDeadlinesMap[task.id].deadline_dismissed = task.deadline_dismissed;
                }
                if (task.critical !== undefined) {
                    taskDeadlinesMap[task.id].critical = task.critical;
                }
            }

            // Update the updated_at map (for near-abandoned calculations)
            if (task.updated_at) {
                taskUpdatedAtMap[task.id] = task.updated_at;
            }

            // Refresh the warnings dropdown and icon
            renderDeadlineDropdown();
            updateDeadlineWarningIcon();

            const kanbanCard = document.querySelector(`.kanban-card[data-task-id="${task.id}"]`);

            if (task.state_id) {
                const targetColumn = document.querySelector(`.kanban-column-body[data-state-id="${task.state_id}"]`);
                if (targetColumn) {
                    if (kanbanCard) {
                        // Move to correct column if needed
                        if (kanbanCard.parentElement !== targetColumn) {
                            targetColumn.appendChild(kanbanCard);
                        }
                        // Update card content
                        updateKanbanCard(kanbanCard, task);
                    } else {
                        // Create new kanban card
                        const card = createKanbanCard(task);
                        targetColumn.appendChild(card);
                    }
                }
            }
            updateKanbanCounts();

            // Update task cards in states view
            const statesTaskCard = document.querySelector(`#states-content .task-card[data-task-id="${task.id}"]`);
            if (statesTaskCard) {
                // Update title
                const titleEl = statesTaskCard.querySelector('.task-card-title');
                if (titleEl) titleEl.textContent = task.title;
                // Update critical class
                statesTaskCard.classList.toggle('critical', task.critical);
                // Move to correct state group if state changed
                const targetStateId = task.state_id || 'none';
                const targetBody = document.querySelector(`#states-content .state-group-body[data-state-id="${targetStateId}"]`);
                if (targetBody && statesTaskCard.parentElement !== targetBody) {
                    targetBody.appendChild(statesTaskCard);
                    updatePanelCounts();
                }
            }

            // Update task cards in tags view - add completed class for strikethrough
            const terminalStateId = getTerminalStateId();
            const isCompleted = task.state_id === terminalStateId;
            const isAbandoned = abandonedStateId && task.state_id === abandonedStateId;

            document.querySelectorAll(`#tags-content .task-card[data-task-id="${task.id}"]`).forEach(card => {
                const titleEl = card.querySelector('.task-card-title');
                if (titleEl) titleEl.textContent = task.title;
                card.classList.toggle('critical', task.critical);
                // Add completed class for strikethrough - task will be hidden on page reload
                card.classList.toggle('completed', isCompleted || isAbandoned);
            });

            // Update task cards in schedules view - add completed class for strikethrough
            document.querySelectorAll(`#schedules-content .task-card[data-task-id="${task.id}"]`).forEach(card => {
                const titleEl = card.querySelector('.task-card-title');
                if (titleEl) titleEl.textContent = task.title;
                card.classList.toggle('critical', task.critical);
                // Add completed class for strikethrough - task will be hidden on page reload
                card.classList.toggle('completed', isCompleted || isAbandoned);
            });

            // Update calendar scheduled tasks - add/remove completed class
            document.querySelectorAll(`.calendar-scheduled-task[data-task-id="${task.id}"]`).forEach(calTask => {
                calTask.classList.toggle('completed', isCompleted);
            });

            // Update the terminal state group (for Delete Completed Tasks link visibility)
            updateTerminalStateGroup();
        }

        function createKanbanCard(task) {
            const card = document.createElement('div');
            card.className = 'kanban-card' + (task.critical ? ' critical' : '');
            card.dataset.taskId = task.id;
            card.draggable = true;

            // Build tags HTML
            const tags = task.tags || taskTagsMap[task.id] || [];
            const tagsHtml = tags.length > 0
                ? `<div class="task-card-tags">${tags.map(t => `<span class="task-tag-pill">${escapeHtml(t.name)}</span>`).join('')}</div>`
                : '';

            card.innerHTML = `
                <div class="kanban-card-title" title="${escapeHtml(task.title)}">${escapeHtml(task.title)}</div>
                ${tagsHtml}
            `;
            card.addEventListener('click', function() {
                openKanbanPanel(task.id);
            });
            setupKanbanCardDrag(card);
            setupKanbanCardContextMenu(card);
            return card;
        }

        function updateKanbanCard(card, task) {
            card.className = 'kanban-card' + (task.critical ? ' critical' : '');

            // Update title
            const title = card.querySelector('.kanban-card-title');
            title.textContent = task.title;
            title.title = task.title;

            // Update tags
            const tags = task.tags || taskTagsMap[task.id] || [];
            updateTaskCardTags(task.id, tags);

            // Update critical class
            if (task.critical) {
                card.classList.add('critical');
            } else {
                card.classList.remove('critical');
            }
        }

        // ========== Right-Click Context Menu ==========

        let contextMenuTaskId = null;
        let pendingTagChanges = { toAdd: [], toRemove: [] };

        function showGroupContextMenu(e, groupElement) {
            e.preventDefault();
            e.stopPropagation();

            // Remove any existing menus
            closeContextMenu();
            const tasksPanelMenu = document.getElementById('tasks-panel-context-menu');
            if (tasksPanelMenu) tasksPanelMenu.remove();

            // Build simple menu HTML
            const menuHtml = `
                <div class="task-context-menu-item" id="group-select-all">
                    <i class="bi bi-check2-square"></i>
                    Select All
                </div>
            `;

            // Create and position menu
            const menu = document.createElement('div');
            menu.className = 'task-context-menu';
            menu.id = 'context-menu';
            menu.innerHTML = menuHtml;
            document.body.appendChild(menu);

            // Position menu at click location
            const menuWidth = 180;
            const menuHeight = 40;
            let x = e.clientX;
            let y = e.clientY;

            // Adjust if menu would go off screen
            if (x + menuWidth > window.innerWidth) {
                x = window.innerWidth - menuWidth - 10;
            }
            if (y + menuHeight > window.innerHeight) {
                y = window.innerHeight - menuHeight - 10;
            }

            menu.style.left = x + 'px';
            menu.style.top = y + 'px';

            // Add click handler for Select All
            menu.querySelector('#group-select-all').addEventListener('click', () => {
                closeContextMenu();
                // Expand the group if collapsed
                if (groupElement.classList.contains('collapsed')) {
                    groupElement.classList.remove('collapsed');
                }
                selectAllTasksInGroup(groupElement);
            });

            // Close menu when clicking elsewhere
            setTimeout(() => {
                document.addEventListener('click', closeContextMenuOnClickOutside);
                document.addEventListener('contextmenu', closeContextMenuOnClickOutside);
            }, 10);
        }

        function closeContextMenuOnClickOutside(e) {
            const menu = document.getElementById('context-menu');
            if (menu && !menu.contains(e.target)) {
                closeContextMenu();
            }
        }

        function showContextMenu(e, taskId, openPanelFn) {
            e.preventDefault();
            contextMenuTaskId = taskId;
            pendingTagChanges = { toAdd: [], toRemove: [] };  // Reset pending changes

            // Remove any existing menu
            closeContextMenu();

            // Find the card (could be kanban-card or task-card)
            let card = document.querySelector(`.kanban-card[data-task-id="${taskId}"]`);
            if (!card) {
                card = document.querySelector(`.task-card[data-task-id="${taskId}"]`);
            }
            const isCritical = card ? card.classList.contains('critical') : false;
            const isScheduled = (taskSchedulesMap[taskId] || []).length > 0;
            const taskTags = taskTagsMap[taskId] || [];
            const terminalStateId = getTerminalStateId();
            const taskData = taskDeadlinesMap[taskId];
            const isCompleted = taskData && taskData.state_id === terminalStateId;

            // Build menu HTML
            let menuHtml = `
                <div class="task-context-menu-item" onclick="${openPanelFn}(${taskId}); closeContextMenu();">
                    <i class="bi bi-pencil"></i>
                    Edit Task
                </div>
                <div class="task-context-menu-divider"></div>
                ${!isCompleted ? `
                <div class="task-context-menu-item" onclick="markTaskComplete(${taskId})">
                    <i class="bi bi-check-circle"></i>
                    Mark Complete
                </div>
                ` : ''}
                <div class="task-context-menu-item" onclick="toggleTaskCritical(${taskId})">
                    <i class="bi bi-exclamation-circle${isCritical ? '-fill' : ''}"></i>
                    ${isCritical ? 'Unmark Critical' : 'Mark Critical'}
                </div>
                ${isScheduled ? `
                <div class="task-context-menu-item" onclick="confirmRemoveFromCalendar(${taskId}); closeContextMenu();">
                    <i class="bi bi-calendar-x"></i>
                    Remove from Calendar
                </div>
                ` : ''}
                <div class="task-context-menu-divider"></div>
                <div class="task-context-menu-submenu">
                    <div class="task-context-menu-item">
                        <i class="bi bi-tags"></i>
                        Tags
                        <span class="submenu-arrow"><i class="bi bi-chevron-right"></i></span>
                    </div>
                    <div class="task-context-menu-submenu-content">
                        <div class="task-context-menu-item" onclick="event.stopPropagation(); promptNewTag(${taskId});">
                            <i class="bi bi-plus-circle"></i>
                            Create New Tag...
                        </div>
                        <div class="task-context-menu-divider"></div>
            `;

            // Show existing tags with checkmarks for assigned ones
            if (tagsList.length === 0) {
                menuHtml += `<div class="task-context-menu-item" style="color: #999; font-style: italic;">No tags yet</div>`;
            } else {
                tagsList.forEach(tag => {
                    const hasTag = taskTags.some(t => t.id === tag.id);
                    menuHtml += `
                        <div class="task-context-menu-item tag-toggle-item${hasTag ? ' active' : ''}" data-tag-id="${tag.id}" data-has-tag="${hasTag}" onclick="event.stopPropagation(); toggleTagLocally(this, ${tag.id})">
                            <i class="bi bi-${hasTag ? 'check-square-fill' : 'square'}"></i>
                            ${escapeHtml(tag.name)}
                        </div>
                    `;
                });
            }

            // Add "Remove all tags" option if task has tags
            if (taskTags.length > 0) {
                menuHtml += `
                        <div class="task-context-menu-divider"></div>
                        <div class="task-context-menu-item" onclick="event.stopPropagation(); removeAllTagsFromTask(${taskId});">
                            <i class="bi bi-x-circle" style="color: #dc3545;"></i>
                            <span style="color: #dc3545;">Remove all tags</span>
                        </div>
                `;
            }

            menuHtml += `
                        <div class="task-context-menu-divider"></div>
                        <div class="task-context-menu-item save-tags-btn" onclick="event.stopPropagation(); savePendingTags(${taskId});">
                            <i class="bi bi-check2"></i>
                            Save Tags
                        </div>
                    </div>
                </div>
                <div class="task-context-menu-divider"></div>
                <div class="task-context-menu-item danger" onclick="deleteTaskFromMenu(${taskId})">
                    <i class="bi bi-trash"></i>
                    Delete Task
                </div>
            `;

            const menu = document.createElement('div');
            menu.className = 'task-context-menu';
            menu.id = 'task-context-menu';
            menu.innerHTML = menuHtml;

            // Position the menu
            document.body.appendChild(menu);

            // Adjust position to keep menu in viewport
            const menuRect = menu.getBoundingClientRect();
            let x = e.clientX;
            let y = e.clientY;

            if (x + menuRect.width > window.innerWidth) {
                x = window.innerWidth - menuRect.width - 10;
            }
            if (y + menuRect.height > window.innerHeight) {
                y = window.innerHeight - menuRect.height - 10;
            }

            menu.style.left = x + 'px';
            menu.style.top = y + 'px';

            // Close on outside click
            setTimeout(() => {
                document.addEventListener('click', closeContextMenu);
                document.addEventListener('contextmenu', closeContextMenu);
            }, 0);
        }

        function closeContextMenu() {
            // Remove both types of context menus
            const taskMenu = document.getElementById('task-context-menu');
            if (taskMenu) {
                taskMenu.remove();
            }
            const groupMenu = document.getElementById('context-menu');
            if (groupMenu) {
                groupMenu.remove();
            }
            document.removeEventListener('click', closeContextMenu);
            document.removeEventListener('contextmenu', closeContextMenu);
            document.removeEventListener('click', closeContextMenuOnClickOutside);
            document.removeEventListener('contextmenu', closeContextMenuOnClickOutside);
            contextMenuTaskId = null;
        }

        // Multi-select context menu
        function showMultiSelectContextMenu(e) {
            e.preventDefault();
            closeContextMenu();

            const count = selectedTaskIds.size;

            // Build menu HTML for multi-select
            let menuHtml = `
                <div class="task-context-menu-item" style="color: #6c757d; font-style: italic; cursor: default;">
                    <i class="bi bi-check2-square"></i>
                    ${count} tasks selected
                </div>
                <div class="task-context-menu-divider"></div>
                <div class="task-context-menu-item" onclick="event.stopPropagation(); batchMarkCritical(true)">
                    <i class="bi bi-exclamation-circle"></i>
                    Mark All Critical
                </div>
                <div class="task-context-menu-item" onclick="event.stopPropagation(); batchMarkCritical(false)">
                    <i class="bi bi-exclamation-circle-fill"></i>
                    Unmark All Critical
                </div>
                <div class="task-context-menu-divider"></div>
                <div class="task-context-menu-submenu">
                    <div class="task-context-menu-item">
                        <i class="bi bi-tags"></i>
                        Tags
                        <span class="submenu-arrow"><i class="bi bi-chevron-right"></i></span>
                    </div>
                    <div class="task-context-menu-submenu-content">
            `;

            // Add tag options
            if (tagsList.length === 0) {
                menuHtml += `<div class="task-context-menu-item" style="color: #999; font-style: italic;">No tags yet</div>`;
            } else {
                // Add tags section
                tagsList.forEach(tag => {
                    menuHtml += `
                        <div class="task-context-menu-item" onclick="event.stopPropagation(); batchAddTag(${tag.id})">
                            <i class="bi bi-plus-circle" style="color: #6B9080;"></i>
                            ${escapeHtml(tag.name)}
                        </div>
                    `;
                });

                // Remove tags section
                menuHtml += `<div class="task-context-menu-divider"></div>`;
                tagsList.forEach(tag => {
                    menuHtml += `
                        <div class="task-context-menu-item" onclick="event.stopPropagation(); batchRemoveTag(${tag.id})">
                            <i class="bi bi-dash-circle" style="color: #dc3545;"></i>
                            ${escapeHtml(tag.name)}
                        </div>
                    `;
                });

                // Remove all tags option
                menuHtml += `
                    <div class="task-context-menu-divider"></div>
                    <div class="task-context-menu-item" onclick="event.stopPropagation(); batchRemoveAllTags()">
                        <i class="bi bi-x-circle" style="color: #dc3545;"></i>
                        Remove all tags
                    </div>
                `;
            }

            menuHtml += `
                    </div>
                </div>
                <div class="task-context-menu-divider"></div>
                <div class="task-context-menu-item danger" onclick="event.stopPropagation(); batchDeleteTasks()">
                    <i class="bi bi-trash"></i>
                    Delete ${count} Tasks
                </div>
            `;

            const menu = document.createElement('div');
            menu.className = 'task-context-menu';
            menu.id = 'task-context-menu';
            menu.innerHTML = menuHtml;

            document.body.appendChild(menu);

            // Position the menu
            const menuRect = menu.getBoundingClientRect();
            let x = e.clientX;
            let y = e.clientY;

            if (x + menuRect.width > window.innerWidth) {
                x = window.innerWidth - menuRect.width - 10;
            }
            if (y + menuRect.height > window.innerHeight) {
                y = window.innerHeight - menuRect.height - 10;
            }

            menu.style.left = x + 'px';
            menu.style.top = y + 'px';

            setTimeout(() => {
                document.addEventListener('click', closeContextMenu);
                document.addEventListener('contextmenu', closeContextMenu);
            }, 0);
        }

        // Batch operations
        async function batchMarkCritical(critical) {
            const taskIds = Array.from(selectedTaskIds);

            for (const taskId of taskIds) {
                try {
                    const response = await fetch(`/tasks/api/${taskId}/update/`, {
                        method: 'PATCH',
                        headers: {
                            'Content-Type': 'application/json',
                            'X-CSRFToken': csrfToken
                        },
                        body: JSON.stringify({ critical })
                    });

                    const data = await response.json();
                    if (data.success) {
                        // Update UI
                        const cards = document.querySelectorAll(`.task-card[data-task-id="${taskId}"], .kanban-card[data-task-id="${taskId}"]`);
                        cards.forEach(card => {
                            if (critical) {
                                card.classList.add('critical');
                                // Add icon if not present
                                let icons = card.querySelector('.task-card-icons');
                                if (!icons) {
                                    icons = document.createElement('div');
                                    icons.className = 'task-card-icons';
                                    card.appendChild(icons);
                                }
                                if (!icons.querySelector('.task-critical-icon')) {
                                    const icon = document.createElement('i');
                                    icon.className = 'bi bi-exclamation-circle-fill task-critical-icon';
                                    icon.title = 'Critical: High priority task requiring immediate attention';
                                    icons.insertBefore(icon, icons.firstChild);
                                }
                            } else {
                                card.classList.remove('critical');
                                const icon = card.querySelector('.task-critical-icon');
                                if (icon) icon.remove();
                            }
                        });
                    }
                } catch (error) {
                    console.error('Error updating task:', error);
                }
            }

            closeContextMenu();
            clearTaskSelection();
        }

        async function batchAddTag(tagId) {
            const taskIds = Array.from(selectedTaskIds);

            for (const taskId of taskIds) {
                // Check if task already has this tag
                const currentTags = taskTagsMap[taskId] || [];
                const hasTag = currentTags.some(t => t.id === tagId);

                if (!hasTag) {
                    try {
                        const response = await fetch(`/tasks/api/${taskId}/tags/add/`, {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                                'X-CSRFToken': csrfToken
                            },
                            body: JSON.stringify({ tag_id: tagId })
                        });

                        const data = await response.json();
                        if (data.success) {
                            taskTagsMap[taskId] = data.task_tags;
                            updateTaskCardTags(taskId, data.task_tags);
                        }
                    } catch (error) {
                        console.error('Error adding tag:', error);
                    }
                }
            }

            closeContextMenu();
            clearTaskSelection();
        }

        async function batchRemoveTag(tagId) {
            const taskIds = Array.from(selectedTaskIds);

            for (const taskId of taskIds) {
                // Check if task has this tag
                const currentTags = taskTagsMap[taskId] || [];
                const hasTag = currentTags.some(t => t.id === tagId);

                if (hasTag) {
                    try {
                        const response = await fetch(`/tasks/api/${taskId}/tags/remove/`, {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                                'X-CSRFToken': csrfToken
                            },
                            body: JSON.stringify({ tag_id: tagId })
                        });

                        const data = await response.json();
                        if (data.success) {
                            taskTagsMap[taskId] = data.task_tags;
                            updateTaskCardTags(taskId, data.task_tags);
                        }
                    } catch (error) {
                        console.error('Error removing tag:', error);
                    }
                }
            }

            closeContextMenu();
            clearTaskSelection();
        }

        async function batchRemoveAllTags() {
            const taskIds = Array.from(selectedTaskIds);

            for (const taskId of taskIds) {
                const currentTags = taskTagsMap[taskId] || [];

                // Remove each tag from the task
                for (const tag of currentTags) {
                    try {
                        const response = await fetch(`/tasks/api/${taskId}/tags/remove/`, {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                                'X-CSRFToken': csrfToken
                            },
                            body: JSON.stringify({ tag_id: tag.id })
                        });

                        const data = await response.json();
                        if (data.success) {
                            taskTagsMap[taskId] = data.task_tags;
                        }
                    } catch (error) {
                        console.error('Error removing tag:', error);
                    }
                }

                // Update UI after all tags removed
                updateTaskCardTags(taskId, []);
            }

            closeContextMenu();
            clearTaskSelection();
        }

        async function removeAllTagsFromTask(taskId) {
            const currentTags = taskTagsMap[taskId] || [];

            if (currentTags.length === 0) {
                closeContextMenu();
                return;
            }

            // Remove each tag from the task
            for (const tag of currentTags) {
                try {
                    const response = await fetch(`/tasks/api/${taskId}/tags/remove/`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'X-CSRFToken': csrfToken
                        },
                        body: JSON.stringify({ tag_id: tag.id })
                    });

                    const data = await response.json();
                    if (data.success) {
                        taskTagsMap[taskId] = data.task_tags;
                    }
                } catch (error) {
                    console.error('Error removing tag:', error);
                }
            }

            // Update UI after all tags removed
            updateTaskCardTags(taskId, []);
            closeContextMenu();
        }

        async function batchDeleteTasks() {
            const count = selectedTaskIds.size;
            // Copy taskIds BEFORE showing modal - modal cleanup can trigger clearTaskSelection
            const taskIds = Array.from(selectedTaskIds);

            const confirmed = await showConfirmModal(
                `Are you sure you want to delete ${count} tasks? This cannot be undone.`,
                'Delete Tasks',
                'Delete'
            );

            if (!confirmed) {
                closeContextMenu();
                return;
            }

            for (const taskId of taskIds) {
                try {
                    await fetch(`/tasks/api/${taskId}/delete/`, {
                        method: 'DELETE',
                        headers: { 'X-CSRFToken': csrfToken }
                    });

                    // Remove from UI
                    document.querySelectorAll(`[data-task-id="${taskId}"]`).forEach(el => el.remove());

                    // Clean up maps
                    delete taskTagsMap[taskId];
                    delete taskSchedulesMap[taskId];
                    delete taskDeadlinesMap[taskId];
                } catch (error) {
                    console.error('Error deleting task:', error);
                }
            }

            updatePanelCounts();
            updateDeadlineWarningIcon();
            closeContextMenu();
            clearTaskSelection();
        }

        function toggleTagLocally(element, tagId) {
            const currentlyHasTag = element.dataset.hasTag === 'true';
            const newHasTag = !currentlyHasTag;

            // Update visual state
            element.dataset.hasTag = newHasTag.toString();
            element.classList.toggle('active', newHasTag);
            const icon = element.querySelector('i');
            icon.className = `bi bi-${newHasTag ? 'check-square-fill' : 'square'}`;

            // Track the change
            if (newHasTag) {
                // Adding tag - remove from toRemove if present, add to toAdd
                pendingTagChanges.toRemove = pendingTagChanges.toRemove.filter(id => id !== tagId);
                if (!pendingTagChanges.toAdd.includes(tagId)) {
                    pendingTagChanges.toAdd.push(tagId);
                }
            } else {
                // Removing tag - remove from toAdd if present, add to toRemove
                pendingTagChanges.toAdd = pendingTagChanges.toAdd.filter(id => id !== tagId);
                if (!pendingTagChanges.toRemove.includes(tagId)) {
                    pendingTagChanges.toRemove.push(tagId);
                }
            }
        }

        async function savePendingTags(taskId) {
            const originalTags = taskTagsMap[taskId] || [];
            const originalTagIds = originalTags.map(t => t.id);

            // Calculate final tag state
            let finalTagIds = [...originalTagIds];

            // Remove tags
            pendingTagChanges.toRemove.forEach(tagId => {
                finalTagIds = finalTagIds.filter(id => id !== tagId);
            });

            // Add tags
            pendingTagChanges.toAdd.forEach(tagId => {
                if (!finalTagIds.includes(tagId)) {
                    finalTagIds.push(tagId);
                }
            });

            // Apply all changes
            try {
                // Remove tags first
                for (const tagId of pendingTagChanges.toRemove) {
                    if (originalTagIds.includes(tagId)) {
                        await fetch(`/tasks/api/${taskId}/tags/remove/`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json', 'X-CSRFToken': csrfToken },
                            body: JSON.stringify({ tag_id: tagId })
                        });
                    }
                }

                // Add new tags
                for (const tagId of pendingTagChanges.toAdd) {
                    if (!originalTagIds.includes(tagId)) {
                        await fetch(`/tasks/api/${taskId}/tags/add/`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json', 'X-CSRFToken': csrfToken },
                            body: JSON.stringify({ tag_id: tagId })
                        });
                    }
                }

                // Build final tags array
                const finalTags = tagsList.filter(t => finalTagIds.includes(t.id));
                taskTagsMap[taskId] = finalTags;
                updateTaskCardTags(taskId, finalTags);

            } catch (error) {
                console.error('Error saving tags:', error);
            }

            closeContextMenu();
        }

        function updateTaskCardTags(taskId, tags) {
            // Update both task-card and kanban-card in states view
            const taskCard = document.querySelector(`#states-content .task-card[data-task-id="${taskId}"]`);
            const kanbanCard = document.querySelector(`.kanban-card[data-task-id="${taskId}"]`);

            [taskCard, kanbanCard].forEach(card => {
                if (!card) return;

                // Remove existing tags container
                let tagsContainer = card.querySelector('.task-card-tags');
                if (tagsContainer) tagsContainer.remove();

                // Add new tags if any
                if (tags && tags.length > 0) {
                    tagsContainer = document.createElement('div');
                    tagsContainer.className = 'task-card-tags';
                    tags.forEach(tag => {
                        const pill = document.createElement('span');
                        pill.className = 'task-tag-pill';
                        pill.textContent = tag.name;
                        tagsContainer.appendChild(pill);
                    });
                    card.appendChild(tagsContainer);
                }
            });

            // Rebuild tag groups if currently viewing by tags (with highlight on the affected task)
            if (currentGroupBy === 'tags') {
                buildTagGroups(taskId);
            }
        }

        async function toggleTaskTag(taskId, tagId, hasTag) {
            try {
                const url = hasTag
                    ? `/tasks/api/${taskId}/tags/remove/`
                    : `/tasks/api/${taskId}/tags/add/`;
                const response = await fetch(url, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-CSRFToken': csrfToken
                    },
                    body: JSON.stringify({ tag_id: tagId })
                });

                const data = await response.json();
                if (data.success) {
                    taskTagsMap[taskId] = data.task_tags;
                    updateTaskCardTags(taskId, data.task_tags);
                }
            } catch (error) {
                console.error('Error toggling task tag:', error);
            }
            closeContextMenu();
        }

        async function promptNewTag(taskId) {
            closeContextMenu();
            const name = await showPromptModal('Enter the name for the new tag:', 'New Tag', 'Tag name');
            if (!name || !name.trim()) return;

            try {
                const response = await fetch(`/tasks/api/${taskId}/tags/add/`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-CSRFToken': csrfToken
                    },
                    body: JSON.stringify({ name: name.trim() })
                });

                const data = await response.json();
                if (data.success) {
                    taskTagsMap[taskId] = data.task_tags;
                    updateTaskCardTags(taskId, data.task_tags);
                    // Also add to tagsList if it's a new tag
                    const newTag = data.task_tags.find(t => t.name === name.trim());
                    if (newTag && !tagsList.some(t => t.id === newTag.id)) {
                        tagsList.push(newTag);
                    }
                }
            } catch (error) {
                console.error('Error adding tag:', error);
            }
        }

        async function deleteTag(tagId) {
            try {
                const response = await fetch(`/tasks/api/tags/${tagId}/delete/`, {
                    method: 'DELETE',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-CSRFToken': csrfToken
                    }
                });

                const data = await response.json();
                if (data.success) {
                    // Remove from tagsList
                    tagsList = tagsList.filter(t => t.id !== tagId);

                    // Remove from all tasks in taskTagsMap
                    Object.keys(taskTagsMap).forEach(taskId => {
                        taskTagsMap[taskId] = taskTagsMap[taskId].filter(t => t.id !== tagId);
                        // Update UI for each task
                        updateTaskCardTags(taskId, taskTagsMap[taskId]);
                    });

                    // Remove from active filters if present
                    activeFilters.tags = activeFilters.tags.filter(id => id !== tagId);

                    // Refresh filter tags list
                    populateFilterTags(filterTagsSearch.value);

                    // Reapply filters
                    applyFilters();
                }
            } catch (error) {
                console.error('Error deleting tag:', error);
            }
        }

        async function renameTag(tagId, currentName) {
            const newName = await showPromptModal(`Rename tag "${currentName}":`, 'Rename Tag', currentName);
            if (!newName || newName.trim() === '' || newName.trim() === currentName) return;

            try {
                const response = await fetch(`/tasks/api/tags/${tagId}/rename/`, {
                    method: 'PATCH',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-CSRFToken': csrfToken
                    },
                    body: JSON.stringify({ name: newName.trim() })
                });

                const data = await response.json();
                if (data.success) {
                    // Update tagsList
                    const tagIndex = tagsList.findIndex(t => t.id === tagId);
                    if (tagIndex !== -1) {
                        tagsList[tagIndex].name = data.tag.name;
                    }

                    // Update all tasks in taskTagsMap
                    Object.keys(taskTagsMap).forEach(taskId => {
                        const taskTags = taskTagsMap[taskId];
                        const tagToUpdate = taskTags.find(t => t.id === tagId);
                        if (tagToUpdate) {
                            tagToUpdate.name = data.tag.name;
                            updateTaskCardTags(taskId, taskTags);
                        }
                    });

                    // Refresh filter tags list
                    populateFilterTags(filterTagsSearch.value);

                    // Re-render tag groups if grouping by tags
                    const groupBy = document.querySelector('input[name="group-by"]:checked')?.value;
                    if (groupBy === 'tags') {
                        renderTagGroups();
                    }
                } else {
                    await showAlertModal(data.error || 'Failed to rename tag');
                }
            } catch (error) {
                console.error('Error renaming tag:', error);
            }
        }

        // Panel tags functionality
        function renderPanelTags(taskId) {
            const container = document.getElementById('panel-tags-container');
            if (!container) return;

            const taskTags = taskTagsMap[taskId] || [];

            container.innerHTML = '';

            // Render existing tags with remove button
            taskTags.forEach(tag => {
                const tagEl = document.createElement('span');
                tagEl.className = 'panel-tag';
                tagEl.innerHTML = `
                    ${escapeHtml(tag.name)}
                    <span class="remove-tag" data-tag-id="${tag.id}" title="Remove tag">
                        <i class="bi bi-x"></i>
                    </span>
                `;
                tagEl.querySelector('.remove-tag').addEventListener('click', async (e) => {
                    e.stopPropagation();
                    await togglePanelTag(taskId, tag.id, true);
                });
                container.appendChild(tagEl);
            });

            // Add tag dropdown
            const dropdown = document.createElement('div');
            dropdown.className = 'panel-tag-dropdown';
            dropdown.innerHTML = `
                <button class="panel-tag-add" id="panel-tag-add-btn">
                    <i class="bi bi-plus"></i> Add tag
                </button>
                <div class="panel-tag-dropdown-menu" id="panel-tag-dropdown-menu">
                    <input type="text" class="panel-tag-search" id="panel-tag-search" placeholder="Search or create...">
                    <div id="panel-tag-options"></div>
                </div>
            `;
            container.appendChild(dropdown);

            // Set up dropdown events
            const addBtn = dropdown.querySelector('#panel-tag-add-btn');
            const menu = dropdown.querySelector('#panel-tag-dropdown-menu');
            const searchInput = dropdown.querySelector('#panel-tag-search');
            const optionsContainer = dropdown.querySelector('#panel-tag-options');

            addBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                isInteractingWithTags = true;
                menu.classList.toggle('show');
                if (menu.classList.contains('show')) {
                    searchInput.value = '';
                    renderPanelTagOptions(taskId, '', optionsContainer);
                    searchInput.focus();
                } else {
                    isInteractingWithTags = false;
                }
            });

            searchInput.addEventListener('input', () => {
                renderPanelTagOptions(taskId, searchInput.value, optionsContainer);
            });

            searchInput.addEventListener('click', (e) => e.stopPropagation());

            // Close dropdown when clicking outside
            document.addEventListener('click', function closePanelTagDropdown(e) {
                if (!dropdown.contains(e.target)) {
                    menu.classList.remove('show');
                    isInteractingWithTags = false;
                }
            });
        }

        function renderPanelScheduledDates(taskId) {
            const section = document.getElementById('panel-scheduled-section');
            const container = document.getElementById('panel-scheduled-dates');
            if (!section || !container) return;

            const schedules = taskSchedulesMap[taskId] || [];

            if (schedules.length === 0) {
                section.style.display = 'none';
                return;
            }

            section.style.display = 'block';

            // Remove existing chips
            const existingChips = container.querySelectorAll('.scheduled-date-chip');
            existingChips.forEach(chip => chip.remove());

            // Get today's date for comparison
            const today = new Date();
            today.setHours(0, 0, 0, 0);

            // Collect unique dates from schedules and sort them
            const uniqueDates = [];
            const seenDates = new Set();

            schedules.forEach(schedule => {
                const scheduleDate = new Date(schedule.start_time);
                const dateKey = scheduleDate.toISOString().split('T')[0];
                if (!seenDates.has(dateKey)) {
                    seenDates.add(dateKey);
                    uniqueDates.push(scheduleDate);
                }
            });

            // Sort by date
            uniqueDates.sort((a, b) => a - b);

            // Render date chips
            uniqueDates.forEach(date => {
                const chip = document.createElement('span');
                chip.className = 'scheduled-date-chip';
                chip.style.cursor = 'pointer';

                const dateOnly = new Date(date);
                dateOnly.setHours(0, 0, 0, 0);
                const isToday = dateOnly.getTime() === today.getTime();

                if (isToday) {
                    chip.classList.add('is-today');
                }

                // Format the date
                const options = { weekday: 'short', month: 'short', day: 'numeric' };
                const formattedDate = isToday ? 'Today' : dateOnly.toLocaleDateString('en-US', options);

                chip.innerHTML = formattedDate;

                // Click handler to jump to calendar date
                chip.addEventListener('click', function() {
                    // Close the task details panel
                    closePanel();

                    // Check if calendar panel is minimized - if so, switch to focus mode
                    const calendarPanel = document.getElementById('calendar-panel');
                    if (calendarPanel && calendarPanel.classList.contains('minimized')) {
                        applyFocusLayout('calendar');
                    }

                    // Navigate to the date
                    currentCalendarDate = new Date(dateOnly);
                    refreshCalendar();

                    // Highlight the task on the calendar with yellow animation
                    setTimeout(() => {
                        const calendarTasks = document.querySelectorAll(`.calendar-scheduled-task[data-task-id="${taskId}"]`);
                        calendarTasks.forEach(taskEl => {
                            taskEl.classList.add('highlight-new');
                            setTimeout(() => {
                                taskEl.classList.remove('highlight-new');
                            }, 4500);
                        });
                    }, 100);
                });

                // Append chip to container (button is in separate div below)
                container.appendChild(chip);
            });
        }

        function renderPanelTagOptions(taskId, searchTerm, container) {
            const taskTags = taskTagsMap[taskId] || [];
            const taskTagIds = taskTags.map(t => t.id);
            const searchLower = searchTerm.toLowerCase().trim();

            container.innerHTML = '';

            // Filter tags based on search
            const filteredTags = tagsList.filter(tag =>
                tag.name.toLowerCase().includes(searchLower)
            );

            // Render tag options
            filteredTags.forEach(tag => {
                const hasTag = taskTagIds.includes(tag.id);
                const item = document.createElement('button');
                item.className = 'panel-tag-dropdown-item' + (hasTag ? ' checked' : '');
                item.textContent = tag.name;
                item.addEventListener('click', async (e) => {
                    e.stopPropagation();
                    await togglePanelTag(taskId, tag.id, hasTag);
                });
                container.appendChild(item);
            });

            // Add "Create new tag" option if search doesn't match exactly
            const exactMatch = tagsList.some(t => t.name.toLowerCase() === searchLower);
            if (searchLower && !exactMatch) {
                const createItem = document.createElement('button');
                createItem.className = 'panel-tag-dropdown-item new-tag';
                createItem.innerHTML = `<i class="bi bi-plus"></i> Create "${escapeHtml(searchTerm)}"`;
                createItem.addEventListener('click', async (e) => {
                    e.stopPropagation();
                    await createAndAddPanelTag(taskId, searchTerm);
                });
                container.appendChild(createItem);
            }

            // Show message if no tags exist
            if (filteredTags.length === 0 && !searchLower) {
                const emptyMsg = document.createElement('div');
                emptyMsg.style.cssText = 'padding: 0.5rem 0.75rem; color: #6c757d; font-size: 0.85rem;';
                emptyMsg.textContent = 'No tags yet. Type to create one.';
                container.appendChild(emptyMsg);
            }
        }

        async function togglePanelTag(taskId, tagId, hasTag) {
            try {
                const url = hasTag
                    ? `/tasks/api/${taskId}/tags/remove/`
                    : `/tasks/api/${taskId}/tags/add/`;
                const response = await fetch(url, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-CSRFToken': csrfToken
                    },
                    body: JSON.stringify({ tag_id: tagId })
                });

                const data = await response.json();
                if (data.success) {
                    taskTagsMap[taskId] = data.task_tags;
                    updateTaskCardTags(taskId, data.task_tags);
                    renderPanelTags(taskId);
                }
            } catch (error) {
                console.error('Error toggling panel tag:', error);
            }
        }

        async function createAndAddPanelTag(taskId, tagName) {
            try {
                const response = await fetch(`/tasks/api/${taskId}/tags/add/`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-CSRFToken': csrfToken
                    },
                    body: JSON.stringify({ name: tagName.trim() })
                });

                const data = await response.json();
                if (data.success) {
                    taskTagsMap[taskId] = data.task_tags;
                    updateTaskCardTags(taskId, data.task_tags);
                    // Add new tag to tagsList
                    const newTag = data.task_tags.find(t => t.name === tagName.trim());
                    if (newTag && !tagsList.some(t => t.id === newTag.id)) {
                        tagsList.push(newTag);
                    }
                    renderPanelTags(taskId);
                }
            } catch (error) {
                console.error('Error creating panel tag:', error);
            }
        }

        async function toggleTaskCritical(taskId) {
            closeContextMenu();

            // Find the card (could be kanban-card, task-card, or calendar-scheduled-task)
            let card = document.querySelector(`.kanban-card[data-task-id="${taskId}"]`);
            let taskCard = document.querySelector(`.task-card[data-task-id="${taskId}"]`);
            let scheduledTask = document.querySelector(`.calendar-scheduled-task[data-task-id="${taskId}"]`);
            const isCritical = (card && card.classList.contains('critical')) ||
                              (taskCard && taskCard.classList.contains('critical')) ||
                              (scheduledTask && scheduledTask.classList.contains('critical'));

            try {
                const response = await fetch(`/tasks/api/${taskId}/update/`, {
                    method: 'PATCH',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-CSRFToken': csrfToken
                    },
                    body: JSON.stringify({ critical: !isCritical })
                });

                const data = await response.json();
                if (data.success) {
                    // Update the kanban card
                    if (card) {
                        updateKanbanCard(card, data.task);
                    }
                    // Update the task card
                    if (taskCard) {
                        if (data.task.critical) {
                            taskCard.classList.add('critical');
                            // Add critical icon if not present
                            let iconsDiv = taskCard.querySelector('.task-card-icons');
                            if (!iconsDiv) {
                                iconsDiv = document.createElement('div');
                                iconsDiv.className = 'task-card-icons';
                                taskCard.querySelector('.task-card-content').appendChild(iconsDiv);
                            }
                            if (!iconsDiv.querySelector('.task-critical-icon')) {
                                const icon = document.createElement('i');
                                icon.className = 'bi bi-exclamation-circle-fill task-critical-icon';
                                icon.title = 'Critical: High priority task requiring immediate attention';
                                iconsDiv.appendChild(icon);
                            }
                        } else {
                            taskCard.classList.remove('critical');
                            // Remove critical icon
                            const criticalIcon = taskCard.querySelector('.task-critical-icon');
                            if (criticalIcon) {
                                criticalIcon.remove();
                                // Remove icons div if empty
                                const iconsDiv = taskCard.querySelector('.task-card-icons');
                                if (iconsDiv && iconsDiv.children.length === 0) {
                                    iconsDiv.remove();
                                }
                            }
                        }
                    }
                    // Update the calendar scheduled task
                    if (scheduledTask) {
                        if (data.task.critical) {
                            scheduledTask.classList.add('critical');
                        } else {
                            scheduledTask.classList.remove('critical');
                        }
                    }
                }
            } catch (error) {
                console.error('Error toggling task critical:', error);
            }
        }

        // Toggle "Done for Today" status for a task (calendar only)
        async function toggleDoneForToday(taskId) {
            closeContextMenu();

            // Check current done_for_day status for the current calendar date
            const doneForDay = taskDoneForDayMap[taskId];
            const calendarDateStr = currentCalendarDate.toISOString().split('T')[0];
            const isDoneForToday = doneForDay === calendarDateStr;

            try {
                const endpoint = isDoneForToday
                    ? `/tasks/api/${taskId}/done-for-today/unmark/`
                    : `/tasks/api/${taskId}/done-for-today/`;

                const body = isDoneForToday
                    ? {}
                    : { date: calendarDateStr };

                const response = await fetch(endpoint, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-CSRFToken': csrfToken
                    },
                    body: JSON.stringify(body)
                });

                const data = await response.json();
                if (data.success) {
                    // Update the local map
                    taskDoneForDayMap[taskId] = data.task.done_for_day;
                    // Re-render calendar tasks to show/hide the icon
                    renderScheduledTasks();
                }
            } catch (error) {
                console.error('Error toggling done for today:', error);
            }
        }

        async function markTaskComplete(taskId) {
            closeContextMenu();

            const terminalStateId = getTerminalStateId();
            if (!terminalStateId) return;

            // Check if already in terminal state
            const taskData = taskDeadlinesMap[taskId];
            if (taskData && taskData.state_id === terminalStateId) return;

            try {
                const response = await fetch(`/tasks/api/${taskId}/update/`, {
                    method: 'PATCH',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-CSRFToken': csrfToken
                    },
                    body: JSON.stringify({ state_id: terminalStateId })
                });

                const data = await response.json();
                if (data.success) {
                    handleTaskStateChange(data.task);
                }
            } catch (error) {
                console.error('Error marking task complete:', error);
            }
        }

        async function deleteTaskFromMenu(taskId) {
            closeContextMenu();
            const confirmed = await showConfirmModal('Are you sure you want to delete this task?', 'Delete Task', 'Delete');
            if (!confirmed) return;
            await deleteTask(taskId);
        }

        // Add right-click handler to kanban cards
        function setupKanbanCardContextMenu(card) {
            card.addEventListener('contextmenu', function(e) {
                showContextMenu(e, parseInt(this.dataset.taskId), 'openKanbanPanel');
            });
        }

        // Setup for existing cards
        document.querySelectorAll('.kanban-card').forEach(card => {
            setupKanbanCardContextMenu(card);
        });

        // ========== Filter Functionality ==========

        // ========== Cookie Helpers ==========
        function setCookie(name, value, days = 365) {
            const expires = new Date(Date.now() + days * 864e5).toUTCString();
            document.cookie = name + '=' + encodeURIComponent(JSON.stringify(value)) + '; expires=' + expires + '; path=/';
        }

        function getCookie(name) {
            const value = document.cookie.split('; ').find(row => row.startsWith(name + '='));
            if (value) {
                try {
                    return JSON.parse(decodeURIComponent(value.split('=')[1]));
                } catch (e) {
                    return null;
                }
            }
            return null;
        }

        let showCompletedTasks = false;  // Default to hiding completed tasks
        let searchText = '';  // Current search query for tasks
        let hideRollups = false;  // Default to showing rollup metrics

        function saveFilterSettings() {
            setCookie('taskFilters', {
                critical: activeFilters.critical,
                today: activeFilters.today,
                tags: activeFilters.tags,
                groupBy: currentGroupBy,
                showCompleted: showCompletedTasks,
                hideRollups: hideRollups,
                abandonedDays: abandonedDays,
                autoAbandonEnabled: autoAbandonEnabled,
                abandonExcludedTagIds: abandonExcludedTagIds,
                abandonExcludedStateIds: abandonExcludedStateIds
            });
        }

        function updateRollupsVisibility() {
            const tasksMetrics = document.getElementById('tasks-collapsed-metrics');
            const calendarMetrics = document.getElementById('calendar-collapsed-metrics');
            // Remove the initial-hide class (used to prevent flash on page load)
            document.documentElement.classList.remove('hide-rollups-initial');
            if (tasksMetrics) {
                tasksMetrics.style.display = hideRollups ? 'none' : '';
            }
            if (calendarMetrics) {
                calendarMetrics.style.display = hideRollups ? 'none' : '';
            }
        }

        const filterIcon = document.getElementById('filter-icon');
        const filterDropdown = document.getElementById('filter-dropdown');
        const filterBadge = document.getElementById('filter-badge');
        const filterCritical = document.getElementById('filter-critical');
        const filterClear = document.getElementById('filter-clear');
        const filterTagsList = document.getElementById('filter-tags-list');
        const filterTagsSearch = document.getElementById('filter-tags-search');

        let activeFilters = {
            critical: false,
            today: false,
            tags: []  // Array of tag IDs to filter by
        };

        // Get tag counts from taskTagsMap
        function getTagCounts() {
            const counts = {};
            Object.values(taskTagsMap).forEach(tags => {
                tags.forEach(tag => {
                    counts[tag.id] = (counts[tag.id] || 0) + 1;
                });
            });
            return counts;
        }

        // Get count of tasks with no tags
        function getUntaggedCount() {
            let count = 0;
            // Count tasks that have no tags or empty tags array
            document.querySelectorAll('.kanban-card, .task-card').forEach(card => {
                const taskId = parseInt(card.dataset.taskId);
                const tags = taskTagsMap[taskId] || [];
                if (tags.length === 0) {
                    count++;
                }
            });
            return count;
        }

        // Populate filter tags list (top 5 by count + search)
        function populateFilterTags(searchTerm = '') {
            const tagCounts = getTagCounts();
            const searchLower = searchTerm.toLowerCase();

            // Sort tags by count (descending), then by name
            const sortedTags = [...tagsList].sort((a, b) => {
                const countDiff = (tagCounts[b.id] || 0) - (tagCounts[a.id] || 0);
                if (countDiff !== 0) return countDiff;
                return a.name.localeCompare(b.name);
            });

            // Filter tags based on search term
            let tagsToShow;
            if (searchTerm) {
                // Show all matching tags when searching
                tagsToShow = sortedTags.filter(tag =>
                    tag.name.toLowerCase().includes(searchLower)
                );
            } else {
                // Show top 5 tags by count
                tagsToShow = sortedTags.slice(0, 5);
            }

            // Build HTML
            filterTagsList.innerHTML = '';

            // Always show "Untagged" option first (unless searching and it doesn't match)
            const showUntagged = !searchTerm || 'untagged'.includes(searchLower);
            if (showUntagged) {
                const untaggedCount = getUntaggedCount();
                const isUntaggedChecked = activeFilters.tags.includes('untagged');
                const untaggedLabel = document.createElement('label');
                untaggedLabel.className = 'filter-option';
                untaggedLabel.style.position = 'relative';
                untaggedLabel.innerHTML = `
                    <input type="checkbox" class="filter-tag-checkbox" data-tag-id="untagged" ${isUntaggedChecked ? 'checked' : ''}>
                    <span class="task-tag-pill" style="font-size: 0.75rem;">Untagged</span>
                    <span style="color: #6c757d; font-size: 0.7rem; margin-left: auto;">(${untaggedCount})</span>
                `;
                filterTagsList.appendChild(untaggedLabel);

                // Add event listener for untagged checkbox
                const untaggedCheckbox = untaggedLabel.querySelector('.filter-tag-checkbox');
                untaggedCheckbox.addEventListener('change', function() {
                    if (this.checked) {
                        if (!activeFilters.tags.includes('untagged')) {
                            activeFilters.tags.push('untagged');
                        }
                    } else {
                        activeFilters.tags = activeFilters.tags.filter(id => id !== 'untagged');
                    }
                    applyFilters();
                    saveFilterSettings();
                });
            }

            if (tagsToShow.length === 0 && !showUntagged) {
                filterTagsList.innerHTML = '<div style="color: #6c757d; font-size: 0.8rem; padding: 0.25rem 0;">No matching tags</div>';
                return;
            }

            tagsToShow.forEach(tag => {
                const count = tagCounts[tag.id] || 0;
                const isChecked = activeFilters.tags.includes(tag.id);
                const label = document.createElement('label');
                label.className = 'filter-option';
                label.style.position = 'relative';
                label.innerHTML = `
                    <input type="checkbox" class="filter-tag-checkbox" data-tag-id="${tag.id}" ${isChecked ? 'checked' : ''}>
                    <span class="task-tag-pill" style="font-size: 0.75rem;">${escapeHtml(tag.name)}</span>
                    <i class="bi bi-pencil rename-tag-btn" data-tag-id="${tag.id}" data-tag-name="${escapeHtml(tag.name)}" style="margin-left: 0.3rem; cursor: pointer; color: #6c757d; opacity: 0.6; transition: opacity 0.2s; font-size: 0.65rem;" title="Rename tag"></i>
                    <i class="bi bi-x-circle delete-tag-btn" data-tag-id="${tag.id}" style="margin-left: 0.15rem; cursor: pointer; color: #dc3545; opacity: 0.6; transition: opacity 0.2s; font-size: 0.65rem;" title="Delete tag"></i>
                    <span style="color: #6c757d; font-size: 0.7rem; margin-left: auto;">(${count})</span>
                `;
                filterTagsList.appendChild(label);

                // Add rename button hover effect and click handler
                const renameBtn = label.querySelector('.rename-tag-btn');
                renameBtn.addEventListener('mouseenter', function() {
                    this.style.opacity = '1';
                });
                renameBtn.addEventListener('mouseleave', function() {
                    this.style.opacity = '0.6';
                });
                renameBtn.addEventListener('click', async function(e) {
                    e.preventDefault();
                    e.stopPropagation();
                    const tagId = parseInt(this.dataset.tagId);
                    const currentName = this.dataset.tagName;
                    await renameTag(tagId, currentName);
                });

                // Add delete button hover effect
                const deleteBtn = label.querySelector('.delete-tag-btn');
                deleteBtn.addEventListener('mouseenter', function() {
                    this.style.opacity = '1';
                });
                deleteBtn.addEventListener('mouseleave', function() {
                    this.style.opacity = '0.6';
                });
                deleteBtn.addEventListener('click', async function(e) {
                    e.preventDefault();
                    e.stopPropagation();
                    const tagId = parseInt(this.dataset.tagId);
                    const tagName = tag.name;

                    const confirmed = await showConfirmModal(`Delete tag "${tagName}"? This will remove it from all tasks.`);
                    if (confirmed) {
                        await deleteTag(tagId);
                    }
                });

                // Add event listener
                const checkbox = label.querySelector('.filter-tag-checkbox');
                checkbox.addEventListener('change', function() {
                    const tagId = parseInt(this.dataset.tagId);
                    if (this.checked) {
                        if (!activeFilters.tags.includes(tagId)) {
                            activeFilters.tags.push(tagId);
                        }
                    } else {
                        activeFilters.tags = activeFilters.tags.filter(id => id !== tagId);
                    }
                    applyFilters();
                    saveFilterSettings();
                });
            });

            // Show hint if more tags exist and not searching
            if (!searchTerm && sortedTags.length > 5) {
                const hint = document.createElement('div');
                hint.style.cssText = 'color: #6c757d; font-size: 0.75rem; padding: 0.25rem 0; text-align: center;';
                hint.textContent = `+ ${sortedTags.length - 5} more tags (use search)`;
                filterTagsList.appendChild(hint);
            }
        }

        // Search tags
        filterTagsSearch.addEventListener('input', function() {
            populateFilterTags(this.value.trim());
        });

        // Initial population
        populateFilterTags();

        // Saved Views functionality
        const savedViewsList = document.getElementById('saved-views-list');
        const saveViewBtn = document.getElementById('save-view-btn');

        function renderSavedViews() {
            savedViewsList.innerHTML = '';

            // Always show "All Tasks" option first
            const allTasksItem = document.createElement('div');
            allTasksItem.className = 'saved-view-item' + (currentActiveViewId === null ? ' active' : '');
            allTasksItem.innerHTML = `
                <span class="view-check"><i class="bi bi-check2"></i></span>
                <span class="view-name"><i class="bi bi-list-task" style="margin-right: 0.3rem; opacity: 0.7;"></i>Show All Tasks</span>
            `;
            allTasksItem.addEventListener('click', (e) => {
                e.stopPropagation(); // Prevent document click handler from closing dropdown
                clearViewAndFilters();
            });
            savedViewsList.appendChild(allTasksItem);

            // Show saved views
            savedViews.forEach(view => {
                const item = document.createElement('div');
                item.className = 'saved-view-item' + (currentActiveViewId === view.id ? ' active' : '');
                item.innerHTML = `
                    <span class="view-check"><i class="bi bi-check2"></i></span>
                    <span class="view-name">${escapeHtml(view.name)}</span>
                    <span class="view-delete" data-view-id="${view.id}" title="Delete view">
                        <i class="bi bi-x"></i>
                    </span>
                `;
                item.querySelector('.view-name').addEventListener('click', (e) => {
                    e.stopPropagation(); // Prevent document click handler from closing dropdown
                    applyView(view);
                });
                item.querySelector('.view-delete').addEventListener('click', (e) => {
                    e.stopPropagation();
                    deleteView(view.id);
                });
                savedViewsList.appendChild(item);
            });
        }

        function clearViewAndFilters(preserveGroupBy = false) {
            currentActiveViewId = null;

            // Reset all filters to defaults
            activeFilters.critical = false;
            activeFilters.today = false;
            activeFilters.tags = [];

            document.getElementById('filter-critical').checked = false;
            document.getElementById('filter-today').checked = false;
            document.getElementById('filter-critical-label').classList.remove('checked');
            document.getElementById('filter-today-label').classList.remove('checked');

            // Reset show completed
            showCompletedTasks = false;
            document.getElementById('show-completed-toggle').checked = false;
            // show-completed is now a regular checkbox

            // Reset hide rollups
            if (document.getElementById('hide-rollups-toggle')) {
                document.getElementById('hide-rollups-toggle').checked = false;
            }

            // Reset group by to states only if not preserving and not in a filtered view
            // Tags and Schedules views always filter completed/abandoned, so preserve that setting
            const isFilteredView = currentGroupBy === 'tags' || currentGroupBy === 'schedules';
            if (!preserveGroupBy && !isFilteredView) {
                const statesRadio = document.querySelector('input[name="group-by"][value="states"]');
                if (statesRadio) {
                    statesRadio.checked = true;
                    statesRadio.dispatchEvent(new Event('change'));
                }
            }

            // Clear tag filters
            populateFilterTags();

            applyFilters();
            saveFilterSettings();
            updateGroupByLabels();
            renderSavedViews();
            // Dropdown stays open so user can see all settings update

            // If in a filtered view, rebuild the groups to reflect cleared filters
            if (isFilteredView) {
                if (currentGroupBy === 'tags') {
                    buildTagGroups();
                } else if (currentGroupBy === 'schedules') {
                    buildScheduleGroups();
                }
            }
        }

        function getCurrentViewSettings() {
            const groupBy = document.querySelector('input[name="group-by"]:checked')?.value || 'states';
            const checkedTagIds = [];
            document.querySelectorAll('#filter-tags-list input[type="checkbox"]:checked').forEach(cb => {
                const tagIdStr = cb.dataset.tagId;
                if (tagIdStr === 'untagged') {
                    checkedTagIds.push('untagged');
                } else {
                    const tagId = parseInt(tagIdStr);
                    if (!isNaN(tagId)) {
                        checkedTagIds.push(tagId);
                    }
                }
            });
            return {
                group_by: groupBy,
                filter_critical: activeFilters.critical || false,
                filter_today: activeFilters.today || false,
                filter_tags: checkedTagIds,
                show_completed: showCompletedTasks || false,
                hide_rollups: document.getElementById('hide-rollups-toggle')?.checked || false
            };
        }

        function applyView(view) {
            // Set this view as active
            currentActiveViewId = view.id;

            const settings = view.settings;

            // Apply group by
            if (settings.group_by) {
                const radio = document.querySelector(`input[name="group-by"][value="${settings.group_by}"]`);
                if (radio) {
                    radio.checked = true;
                    radio.dispatchEvent(new Event('change'));
                }
            }

            // Apply filters
            activeFilters.critical = settings.filter_critical || false;
            activeFilters.today = settings.filter_today || false;
            // Filter out any null/undefined values that may have been saved
            activeFilters.tags = (settings.filter_tags || []).filter(id => id != null);

            document.getElementById('filter-critical').checked = activeFilters.critical;
            document.getElementById('filter-today').checked = activeFilters.today;

            // Update visual states
            document.getElementById('filter-critical-label').classList.toggle('checked', activeFilters.critical);
            document.getElementById('filter-today-label').classList.toggle('checked', activeFilters.today);

            // Apply show completed
            showCompletedTasks = settings.show_completed || false;
            document.getElementById('show-completed-toggle').checked = showCompletedTasks;
            // show-completed is now a regular checkbox, no pill styling

            // Apply hide rollups
            if (document.getElementById('hide-rollups-toggle')) {
                document.getElementById('hide-rollups-toggle').checked = settings.hide_rollups || false;
            }

            // Apply tag filters
            populateFilterTags();
            if (settings.filter_tags && settings.filter_tags.length > 0) {
                settings.filter_tags.forEach(tagId => {
                    const cb = document.querySelector(`#filter-tags-list input[data-tag-id="${tagId}"]`);
                    if (cb) cb.checked = true;
                });
            }

            applyFilters();
            saveFilterSettings();
            updateGroupByLabels();
            renderSavedViews(); // Re-render to show active state
            // Keep dropdown open so user can see what settings were applied
        }

        async function saveCurrentView() {
            const name = await showPromptModal('Enter a name for this view:', 'Save View', 'View name');
            if (!name || !name.trim()) return;

            const settings = getCurrentViewSettings();

            try {
                const response = await fetch('/tasks/api/views/create/', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-CSRFToken': csrfToken
                    },
                    body: JSON.stringify({
                        name: name.trim(),
                        settings: settings
                    })
                });

                const data = await response.json();
                if (data.success) {
                    savedViews.push(data.view);
                    // Auto-apply the newly created view
                    applyView(data.view);
                }
            } catch (error) {
                console.error('Error saving view:', error);
            }
        }

        async function deleteView(viewId) {
            const view = savedViews.find(v => v.id === viewId);
            const viewName = view ? view.name : 'this view';
            const confirmed = await showConfirmModal(`Delete "${viewName}"?`, 'Delete View', 'Delete');
            if (!confirmed) return;

            try {
                const response = await fetch(`/tasks/api/views/${viewId}/delete/`, {
                    method: 'DELETE',
                    headers: { 'X-CSRFToken': csrfToken }
                });

                const data = await response.json();
                if (data.success) {
                    savedViews = savedViews.filter(v => v.id !== viewId);
                    // If we deleted the active view, reset to All Tasks
                    if (currentActiveViewId === viewId) {
                        currentActiveViewId = null;
                    }
                    renderSavedViews();
                }
            } catch (error) {
                console.error('Error deleting view:', error);
            }
        }

        saveViewBtn.addEventListener('click', saveCurrentView);
        renderSavedViews();

        // Toggle filter dropdown
        filterIcon.addEventListener('click', function(e) {
            e.stopPropagation();
            // Close other dropdowns if open
            closeDeadlineDropdown();
            closeSettingsDropdown();
            filterDropdown.classList.toggle('active');
            filterIcon.classList.toggle('active', filterDropdown.classList.contains('active'));
        });

        // Close filter dropdown on outside click
        document.addEventListener('click', function(e) {
            if (!filterDropdown.contains(e.target) && e.target !== filterIcon) {
                filterDropdown.classList.remove('active');
                filterIcon.classList.remove('active');
            }
        });

        // Handle collapsible sections in filter dropdown
        document.querySelectorAll('.filter-section-title, .saved-views-header').forEach(header => {
            header.addEventListener('click', function(e) {
                // Don't toggle if clicking on info icon
                if (e.target.closest('.settings-info-icon')) return;

                const section = this.closest('.filter-section, .saved-views-section');
                section.classList.toggle('collapsed');
            });
        });

        // Position fixed tooltips in filter dropdown and settings dropdown
        document.querySelectorAll('.filter-section-title .has-tooltip, .settings-section-header .has-tooltip').forEach(tooltipWrapper => {
            tooltipWrapper.addEventListener('mouseenter', function() {
                const tooltip = this.querySelector('.custom-tooltip');
                if (tooltip) {
                    const rect = this.getBoundingClientRect();
                    tooltip.style.left = rect.left + 'px';
                    tooltip.style.top = (rect.bottom + 5) + 'px';
                }
            });
        });

        // Toggle deadline warning dropdown
        const deadlineWarningIcon = document.getElementById('deadline-warning-icon');
        const deadlineDropdown = document.getElementById('deadline-dropdown');

        deadlineWarningIcon.addEventListener('click', function(e) {
            e.stopPropagation();
            // Close other dropdowns if open
            filterDropdown.classList.remove('active');
            filterIcon.classList.remove('active');
            closeSettingsDropdown();
            // Toggle deadline dropdown
            const isActive = deadlineDropdown.classList.contains('active');
            if (isActive) {
                closeDeadlineDropdown();
            } else {
                renderDeadlineDropdown();
                deadlineDropdown.classList.add('active');
            }
        });

        // Close deadline dropdown on outside click
        document.addEventListener('click', function(e) {
            if (!deadlineDropdown.contains(e.target) && e.target !== deadlineWarningIcon) {
                closeDeadlineDropdown();
            }
        });

        // Handle critical filter change
        filterCritical.addEventListener('change', function() {
            activeFilters.critical = this.checked;
            document.getElementById('filter-critical-label').classList.toggle('checked', this.checked);
            applyFilters();
            saveFilterSettings();
        });

        const filterToday = document.getElementById('filter-today');
        filterToday.addEventListener('change', function() {
            activeFilters.today = this.checked;
            document.getElementById('filter-today-label').classList.toggle('checked', this.checked);
            applyFilters();
            saveFilterSettings();
        });

        // Handle show completed toggle
        document.getElementById('show-completed-toggle').addEventListener('change', function() {
            showCompletedTasks = this.checked;
            // show-completed is now a regular checkbox
            applyFilters();
            saveFilterSettings();
        });

        // Update group-by label styling
        function updateGroupByLabels() {
            const statesChecked = document.getElementById('group-by-states').checked;
            const tagsChecked = document.getElementById('group-by-tags').checked;
            const schedulesChecked = document.getElementById('group-by-schedules').checked;
            document.getElementById('group-by-states-label').classList.toggle('checked', statesChecked);
            document.getElementById('group-by-tags-label').classList.toggle('checked', tagsChecked);
            document.getElementById('group-by-schedules-label').classList.toggle('checked', schedulesChecked);
        }
        document.querySelectorAll('input[name="group-by"]').forEach(radio => {
            radio.addEventListener('change', updateGroupByLabels);
        });
        updateGroupByLabels(); // Initial state

        // Tag filter changes are handled dynamically in populateFilterTags()

        // Clear all filters - reset to "All Tasks" view
        filterClear.addEventListener('click', function(e) {
            e.stopPropagation(); // Prevent document click handler from closing dropdown
            // Clear search field as well
            filterTagsSearch.value = '';
            // Use the same function that "All Tasks" uses
            clearViewAndFilters();
        });

        // Clear filters link in filter summary
        const clearFiltersLink = document.getElementById('clear-filters-link');
        if (clearFiltersLink) {
            clearFiltersLink.addEventListener('click', function() {
                // If search is active, clear search; otherwise clear filters
                if (searchText) {
                    clearSearch();
                } else {
                    clearViewAndFilters();
                }
            });
        }

        // Position tooltip below the info icon on hover
        const filterInfoWrapper = document.querySelector('.filter-info-wrapper');
        const filterInfoIcon = document.getElementById('filter-info-icon');
        const filterTooltip = document.getElementById('filter-info-tooltip');

        if (filterInfoWrapper && filterInfoIcon && filterTooltip) {
            filterInfoWrapper.addEventListener('mouseenter', function() {
                const rect = filterInfoIcon.getBoundingClientRect();
                filterTooltip.style.top = (rect.bottom) + 'px';
                filterTooltip.style.left = (rect.left + rect.width / 2) + 'px';
            });
        }

        // Tasks search functionality
        const tasksSearchBar = document.getElementById('tasks-search-bar');
        const tasksSearchIcon = document.getElementById('tasks-search-icon');
        const tasksSearchInput = document.getElementById('tasks-search-input');
        const tasksSearchBtn = document.getElementById('tasks-search-btn');
        const tasksSearchResults = document.getElementById('tasks-search-results');
        const tasksSearchClear = document.getElementById('tasks-search-clear');

        // Toggle search bar expansion - click anywhere in bar to expand
        if (tasksSearchBar) {
            tasksSearchBar.addEventListener('click', function(e) {
                if (!tasksSearchBar.classList.contains('expanded')) {
                    tasksSearchBar.classList.add('expanded');
                    tasksSearchInput.focus();
                }
            });
        }

        function clearSearch() {
            searchText = '';
            tasksSearchInput.value = '';
            tasksSearchResults.textContent = '';
            tasksSearchBar.classList.remove('expanded');
            applyFilters();
        }

        if (tasksSearchClear) {
            tasksSearchClear.addEventListener('click', function(e) {
                e.stopPropagation();
                clearSearch();
            });
        }

        function performSearch() {
            const query = tasksSearchInput.value.trim();

            // If search is cleared, reset everything
            if (!query) {
                clearSearch();
                return;
            }

            // First, find all cards that match the search (ignoring current filters)
            const allCards = document.querySelectorAll('.kanban-card, .task-card');
            const matchingCards = [];

            allCards.forEach(card => {
                const titleEl = card.querySelector('.task-card-title, .kanban-card-title');
                const title = titleEl ? titleEl.textContent.toLowerCase() : '';
                if (title.includes(query.toLowerCase())) {
                    matchingCards.push(card);
                }
            });

            // Check if any filters would hide matching cards - if so, clear filters
            const hasActiveFilters = activeFilters.critical || activeFilters.today || activeFilters.tags.length > 0 || (currentGroupBy === 'tags' && !showCompletedTasks);

            if (hasActiveFilters && matchingCards.length > 0) {
                // Clear all filters to show all matching results
                activeFilters.critical = false;
                activeFilters.today = false;
                activeFilters.tags = [];
                showCompletedTasks = true;
                filterCritical.checked = false;
                filterToday.checked = false;
                document.getElementById('show-completed-toggle').checked = true;
                populateFilterTags();
                saveFilterSettings();
            }

            // Now apply the search
            searchText = query;
            applyFilters();

            // Show result count
            tasksSearchResults.textContent = matchingCards.length === 1 ? '1 result' : `${matchingCards.length} results`;

            // Auto-expand collapsed groups containing results and highlight cards
            matchingCards.forEach(card => {
                // Find parent state-group and expand if collapsed
                const stateGroup = card.closest('.state-group');
                if (stateGroup && stateGroup.classList.contains('collapsed')) {
                    stateGroup.classList.remove('collapsed');
                }

                // Remove any existing highlight and re-add for animation
                card.classList.remove('highlight-new');
                // Force reflow to restart animation
                void card.offsetWidth;
                card.classList.add('highlight-new');

                // Remove highlight class after animation completes
                setTimeout(() => {
                    card.classList.remove('highlight-new');
                }, 4500);
            });
        }

        if (tasksSearchBtn) {
            tasksSearchBtn.addEventListener('click', function(e) {
                e.stopPropagation();
                performSearch();
            });
        }

        if (tasksSearchInput) {
            tasksSearchInput.addEventListener('click', function(e) {
                e.stopPropagation();
            });
            tasksSearchInput.addEventListener('keydown', function(e) {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    performSearch();
                }
                if (e.key === 'Escape') {
                    clearSearch();
                }
            });
        }

        if (tasksSearchResults) {
            tasksSearchResults.addEventListener('click', function(e) {
                e.stopPropagation();
            });
        }

        // ========== Group By Functionality ==========
        let currentGroupBy = 'states';  // 'states' or 'tags'

        document.querySelectorAll('input[name="group-by"]').forEach(radio => {
            radio.addEventListener('change', function() {
                currentGroupBy = this.value;
                switchGroupBy(currentGroupBy);
                saveFilterSettings();
            });
        });

        function switchGroupBy(groupBy) {
            const statesContent = document.getElementById('states-content');
            const tagsContent = document.getElementById('tags-content');
            const schedulesContent = document.getElementById('schedules-content');
            const tasksCollapsedMetrics = document.getElementById('tasks-collapsed-metrics');
            const completedLabel = document.getElementById('show-completed-label');

            if (groupBy === 'states') {
                statesContent.style.display = '';
                tagsContent.style.display = 'none';
                schedulesContent.style.display = 'none';
                // Show state-based metrics in collapsed view
                updateCollapsedMetricsForStates();
                // Hide completed filter (only applies to tags view)
                if (completedLabel) completedLabel.style.display = 'none';
            } else if (groupBy === 'tags') {
                statesContent.style.display = 'none';
                tagsContent.style.display = '';
                schedulesContent.style.display = 'none';
                buildTagGroups();
                // Show tag-based metrics in collapsed view
                updateCollapsedMetricsForTags();
                // Show completed filter (only applies to tags view)
                if (completedLabel) completedLabel.style.display = '';
            } else if (groupBy === 'schedules') {
                statesContent.style.display = 'none';
                tagsContent.style.display = 'none';
                schedulesContent.style.display = '';
                buildScheduleGroups();
                // Show schedule-based metrics in collapsed view
                updateCollapsedMetricsForSchedules();
                // Hide completed filter (not applicable to schedules view)
                if (completedLabel) completedLabel.style.display = 'none';
            }
            updatePanelCounts();
            updateGroupByLabels();
            applyFilters(); // Re-apply filters when switching views
        }

        // Update collapsed metrics to show states (excluding terminal state)
        function updateCollapsedMetricsForStates() {
            const tasksCollapsedMetrics = document.getElementById('tasks-collapsed-metrics');
            const terminalStateId = getTerminalStateId();
            // Rebuild with state metrics, excluding terminal state
            let html = '';
            {% for state in states %}
            if ({{ state.id }} !== terminalStateId) {
                html += '<span class="metric-pill" data-state-id="{{ state.id }}">{{ state.name }}: <span class="metric-count">0</span></span>';
            }
            {% endfor %}
            tasksCollapsedMetrics.innerHTML = html;
            updatePanelCounts();
        }

        // Update collapsed metrics to show top 3 tags
        function updateCollapsedMetricsForTags() {
            const tasksCollapsedMetrics = document.getElementById('tasks-collapsed-metrics');

            // Count tasks per tag
            const tagCounts = {};
            Object.entries(taskTagsMap).forEach(([taskId, tags]) => {
                tags.forEach(tag => {
                    tagCounts[tag.id] = tagCounts[tag.id] || { name: tag.name, count: 0 };
                    tagCounts[tag.id].count++;
                });
            });

            // Sort by count and take top 3
            const topTags = Object.entries(tagCounts)
                .sort((a, b) => b[1].count - a[1].count)
                .slice(0, 3);

            let html = '';
            topTags.forEach(([tagId, tag]) => {
                html += `<span class="metric-pill" data-tag-id="${tagId}">${escapeHtml(tag.name)}: <span class="metric-count">${tag.count}</span></span>`;
            });

            tasksCollapsedMetrics.innerHTML = html || '<span class="metric-pill">No tags</span>';
        }

        // Toggle for showing/hiding completed tasks
        document.getElementById('show-completed-toggle').addEventListener('change', function() {
            showCompletedTasks = this.checked;
            applyFilters();
            if (currentGroupBy === 'tags') {
                buildTagGroups();
            }
            saveFilterSettings();
        });

        // Toggle for hiding rollup metrics in collapsed panels
        document.getElementById('hide-rollups-toggle').addEventListener('change', function() {
            hideRollups = this.checked;
            updateRollupsVisibility();
            saveFilterSettings();
        });

        // Load saved filter settings from cookies on page load
        (function loadFilterSettings() {
            const saved = getCookie('taskFilters');
            if (saved) {
                // Restore critical filter
                if (saved.critical) {
                    activeFilters.critical = true;
                    filterCritical.checked = true;
                    document.getElementById('filter-critical-label').classList.add('checked');
                }

                // Restore today filter
                if (saved.today) {
                    activeFilters.today = true;
                    filterToday.checked = true;
                    document.getElementById('filter-today-label').classList.add('checked');
                }

                // Restore tag filters (filter out any null/undefined values from old data)
                if (saved.tags && saved.tags.length > 0) {
                    activeFilters.tags = saved.tags.filter(id => id != null);
                    populateFilterTags();  // Re-populate to reflect saved checked states
                }

                // Restore group by
                if (saved.groupBy) {
                    currentGroupBy = saved.groupBy;
                    const radio = document.querySelector(`input[name="group-by"][value="${saved.groupBy}"]`);
                    if (radio) {
                        radio.checked = true;
                    }
                }

                // Restore show completed toggle
                if (saved.showCompleted !== undefined) {
                    showCompletedTasks = saved.showCompleted;
                    const toggle = document.getElementById('show-completed-toggle');
                    toggle.checked = saved.showCompleted;
                }

                // Restore hide rollups toggle
                if (saved.hideRollups !== undefined) {
                    hideRollups = saved.hideRollups;
                    const toggle = document.getElementById('hide-rollups-toggle');
                    toggle.checked = saved.hideRollups;
                    updateRollupsVisibility();
                }

                // Load abandoned settings
                if (saved.abandonedDays !== undefined) {
                    abandonedDays = saved.abandonedDays;
                    const input = document.getElementById('abandoned-days-input');
                    if (input) input.value = abandonedDays;
                }
                if (saved.autoAbandonEnabled !== undefined) {
                    autoAbandonEnabled = saved.autoAbandonEnabled;
                    const toggle = document.getElementById('auto-abandon-enabled');
                    if (toggle) toggle.checked = autoAbandonEnabled;
                    // Update visibility of days input based on enabled state
                    const daysRow = document.getElementById('abandoned-days-row');
                    if (daysRow) daysRow.style.opacity = autoAbandonEnabled ? '1' : '0.5';
                    const excludeTagsRow = document.getElementById('abandon-exclude-tags-row');
                    const excludeStatesRow = document.getElementById('abandon-exclude-states-row');
                    if (excludeTagsRow) excludeTagsRow.style.opacity = autoAbandonEnabled ? '1' : '0.5';
                    if (excludeStatesRow) excludeStatesRow.style.opacity = autoAbandonEnabled ? '1' : '0.5';
                }
                if (saved.abandonExcludedTagIds !== undefined && Array.isArray(saved.abandonExcludedTagIds)) {
                    abandonExcludedTagIds = saved.abandonExcludedTagIds;
                    abandonExcludedTagIds.forEach(tagId => {
                        const chip = document.querySelector(`#abandon-exclude-tags-chips .abandon-exclusion-chip[data-tag-id="${tagId}"]`);
                        if (chip) chip.classList.add('active');
                    });
                }
                if (saved.abandonExcludedStateIds !== undefined && Array.isArray(saved.abandonExcludedStateIds)) {
                    abandonExcludedStateIds = saved.abandonExcludedStateIds;
                    abandonExcludedStateIds.forEach(stateId => {
                        const chip = document.querySelector(`#abandon-exclude-states-chips .abandon-exclusion-chip[data-state-id="${stateId}"]`);
                        if (chip) chip.classList.add('active');
                    });
                }

                // Switch to tags or schedules view if needed (after showCompleted is set)
                if (saved.groupBy === 'tags') {
                    switchGroupBy('tags');
                } else if (saved.groupBy === 'schedules') {
                    switchGroupBy('schedules');
                }

                // Update group by label styling
                updateGroupByLabels();

                // Apply the restored filters
                applyFilters();
            }
        })();

        function buildTagGroups(highlightTaskId = null) {
            const tagsContent = document.getElementById('tags-content');

            // Remember which groups were expanded before rebuilding
            const expandedTagIds = [];
            tagsContent.querySelectorAll('.state-group:not(.collapsed)').forEach(group => {
                expandedTagIds.push(group.dataset.tagId);
            });

            tagsContent.innerHTML = '';

            // Get the terminal state ID to filter completed tasks
            const terminalStateId = getTerminalStateId();

            // Get all tasks from the state groups
            const allTasks = [];
            document.querySelectorAll('#states-content .task-card').forEach(card => {
                const taskId = parseInt(card.dataset.taskId);
                const title = card.querySelector('.task-card-title').textContent;
                const isCritical = card.classList.contains('critical');
                const tags = taskTagsMap[taskId] || [];

                // Check if task is in terminal state
                const stateGroup = card.closest('.state-group');
                const rawStateId = stateGroup ? stateGroup.dataset.stateId : null;
                const taskStateId = rawStateId === 'none' ? null : (rawStateId ? parseInt(rawStateId) : null);
                const isCompleted = taskStateId === terminalStateId;

                // Skip completed tasks if showCompletedTasks is false
                if (!showCompletedTasks && isCompleted) {
                    return;
                }

                // Skip abandoned tasks (they don't appear in tag groups)
                if (abandonedStateId && taskStateId === abandonedStateId) {
                    return;
                }

                // Get state name for the state pill
                const stateName = stateGroup ? stateGroup.querySelector('.state-group-name')?.textContent : null;

                allTasks.push({ id: taskId, title, isCritical, isCompleted, tags, stateName, element: card });
            });

            // Group tasks by tag
            const tagGroups = {};
            const untaggedTasks = [];

            allTasks.forEach(task => {
                if (task.tags.length === 0) {
                    untaggedTasks.push(task);
                } else {
                    task.tags.forEach(tag => {
                        if (!tagGroups[tag.id]) {
                            tagGroups[tag.id] = { name: tag.name, tasks: [] };
                        }
                        tagGroups[tag.id].tasks.push(task);
                    });
                }
            });

            // Create tag group elements (sorted by tag name)
            const sortedTagIds = Object.keys(tagGroups).sort((a, b) =>
                tagGroups[a].name.localeCompare(tagGroups[b].name)
            );

            sortedTagIds.forEach(tagId => {
                const group = tagGroups[tagId];
                // If highlighting a task, put it at the top of each group it belongs to
                if (highlightTaskId) {
                    group.tasks.sort((a, b) => {
                        if (a.id === highlightTaskId) return -1;
                        if (b.id === highlightTaskId) return 1;
                        return 0;
                    });
                }
                const groupEl = createTagGroup(tagId, group.name, group.tasks);
                tagsContent.appendChild(groupEl);
            });

            // Create Untagged group at the bottom only if there are untagged tasks
            if (untaggedTasks.length > 0) {
                if (highlightTaskId) {
                    untaggedTasks.sort((a, b) => {
                        if (a.id === highlightTaskId) return -1;
                        if (b.id === highlightTaskId) return 1;
                        return 0;
                    });
                }
                const untaggedGroup = createTagGroup('untagged', 'Untagged', untaggedTasks);
                tagsContent.appendChild(untaggedGroup);
            }

            // Restore previously expanded groups
            expandedTagIds.forEach(tagId => {
                const group = tagsContent.querySelector(`.state-group[data-tag-id="${tagId}"]`);
                if (group) {
                    group.classList.remove('collapsed');
                }
            });

            // If highlighting a task, expand its groups and apply visual feedback
            if (highlightTaskId) {
                const taskCards = tagsContent.querySelectorAll(`.task-card[data-task-id="${highlightTaskId}"]`);
                taskCards.forEach(card => {
                    // Expand the parent group (if not already expanded)
                    const group = card.closest('.state-group');
                    if (group) {
                        group.classList.remove('collapsed');
                    }
                    // Apply highlight animation (same as new task highlight)
                    card.classList.add('highlight-new');
                    setTimeout(() => {
                        card.classList.remove('highlight-new');
                    }, 4500);
                });
            }
        }

        function createTagGroup(tagId, tagName, tasks) {
            const group = document.createElement('div');
            group.className = 'state-group collapsed';
            group.dataset.tagId = tagId;

            group.innerHTML = `
                <div class="state-group-header" onclick="toggleStateGroup(this)">
                    <div class="state-group-left">
                        <i class="bi bi-tag state-group-icon"></i>
                        <span class="state-group-name">${escapeHtml(tagName)}</span>
                    </div>
                    <div class="state-group-right">
                        <span class="state-group-count">${tasks.length}</span>
                        <i class="bi bi-chevron-down state-group-toggle"></i>
                    </div>
                </div>
                <div class="state-group-body" data-tag-id="${tagId}"></div>
            `;

            const body = group.querySelector('.state-group-body');
            tasks.forEach(task => {
                const card = document.createElement('div');
                const schedules = taskSchedulesMap[task.id] || [];
                const isScheduled = schedules.length > 0;
                card.className = 'task-card' + (task.isCritical ? ' critical' : '') + (isScheduled ? ' scheduled' : '') + (task.isCompleted ? ' completed' : '');
                card.dataset.taskId = task.id;

                // In Tags view: show State + Scheduled pills (not Tags - already grouping by tags)
                const schedulePillHtml = getSchedulePillHtml(schedules);
                const criticalIconHtml = task.isCritical ? '<i class="bi bi-exclamation-circle-fill task-critical-icon" title="Critical: High priority task requiring immediate attention"></i>' : '';
                const statePillHtml = task.stateName ? `<span class="task-state-pill">${escapeHtml(task.stateName)}</span>` : '';
                const hasIcons = task.isCritical || task.stateName || schedulePillHtml;
                const iconsHtml = hasIcons ? `<div class="task-card-icons">${statePillHtml}${schedulePillHtml}${criticalIconHtml}</div>` : '';

                card.innerHTML = `
                    <div class="task-card-content">
                        <i class="bi bi-grip-vertical task-card-drag-handle"></i>
                        <div class="task-card-title">${escapeHtml(task.title)}</div>
                        ${iconsHtml}
                    </div>
                `;

                // Setup event handlers
                setupTaskCardDragEvents(card);
                card.addEventListener('contextmenu', function(e) {
                    e.preventDefault();
                    showContextMenu(e, parseInt(this.dataset.taskId), 'openTaskPanel');
                });
                body.appendChild(card);
            });

            // Setup drag-drop for tag group body
            setupTagGroupDragDrop(body, tagId, tagName);

            // Also setup drag-drop for the header (for dropping on collapsed groups)
            const header = group.querySelector('.state-group-header');
            setupTagGroupHeaderDragDrop(header, group, tagId, tagName);

            // Right-click to show context menu with Select All option
            header.addEventListener('contextmenu', function(e) {
                showGroupContextMenu(e, group);
            });

            return group;
        }

        // Setup drag-drop handlers for tag group headers
        function setupTagGroupHeaderDragDrop(header, group, tagId, tagName) {
            header.addEventListener('dragover', function(e) {
                e.preventDefault();
                if (!draggedTaskCard) return;
                e.dataTransfer.dropEffect = 'move';
                this.classList.add('drag-over');
            });

            header.addEventListener('dragleave', function(e) {
                this.classList.remove('drag-over');
            });

            header.addEventListener('drop', async function(e) {
                e.preventDefault();
                e.stopPropagation();
                this.classList.remove('drag-over');
                if (!draggedTaskCard) return;

                // Get all task IDs to process (batch or single)
                const taskIds = draggedTaskCards.length > 0
                    ? draggedTaskCards.map(c => parseInt(c.dataset.taskId))
                    : [parseInt(draggedTaskCard.dataset.taskId)];

                for (const taskId of taskIds) {
                    const currentTags = taskTagsMap[taskId] || [];

                    if (tagId === 'untagged') {
                        // Dropping into Untagged - remove all tags
                        for (const tag of currentTags) {
                            try {
                                await fetch(`/tasks/api/${taskId}/tags/remove/`, {
                                    method: 'POST',
                                    headers: {
                                        'Content-Type': 'application/json',
                                        'X-CSRFToken': csrfToken
                                    },
                                    body: JSON.stringify({ tag_id: tag.id })
                                });
                            } catch (error) {
                                console.error('Error removing tag:', error);
                            }
                        }
                        taskTagsMap[taskId] = [];
                    } else {
                        // Dropping into a tag group - add this tag if not already present
                        const numericTagId = parseInt(tagId);
                        const hasTag = currentTags.some(t => t.id === numericTagId);
                        if (!hasTag) {
                            try {
                                const response = await fetch(`/tasks/api/${taskId}/tags/add/`, {
                                    method: 'POST',
                                    headers: {
                                        'Content-Type': 'application/json',
                                        'X-CSRFToken': csrfToken
                                    },
                                    body: JSON.stringify({ tag_id: numericTagId })
                                });
                                const data = await response.json();
                                if (data.success) {
                                    taskTagsMap[taskId] = data.task_tags;
                                }
                            } catch (error) {
                                console.error('Error adding tag:', error);
                            }
                        }
                    }
                }

                // Rebuild tag groups to reflect changes
                buildTagGroups();
            });
        }

        // Setup drag-drop handlers for tag groups
        function setupTagGroupDragDrop(body, tagId, tagName) {
            body.addEventListener('dragover', function(e) {
                e.preventDefault();
                if (!draggedTaskCard) return;
                e.dataTransfer.dropEffect = 'move';
                this.classList.add('drag-over');
            });

            body.addEventListener('dragleave', function(e) {
                if (!this.contains(e.relatedTarget)) {
                    this.classList.remove('drag-over');
                }
            });

            body.addEventListener('drop', async function(e) {
                e.preventDefault();
                this.classList.remove('drag-over');
                if (!draggedTaskCard) return;

                // Get all task IDs to process (batch or single)
                const taskIds = draggedTaskCards.length > 0
                    ? draggedTaskCards.map(c => parseInt(c.dataset.taskId))
                    : [parseInt(draggedTaskCard.dataset.taskId)];

                for (const taskId of taskIds) {
                    const currentTags = taskTagsMap[taskId] || [];

                    if (tagId === 'untagged') {
                        // Dropping into Untagged - remove all tags
                        for (const tag of currentTags) {
                            try {
                                await fetch(`/tasks/api/${taskId}/tags/remove/`, {
                                    method: 'POST',
                                    headers: {
                                        'Content-Type': 'application/json',
                                        'X-CSRFToken': csrfToken
                                    },
                                    body: JSON.stringify({ tag_id: tag.id })
                                });
                            } catch (error) {
                                console.error('Error removing tag:', error);
                            }
                        }
                        taskTagsMap[taskId] = [];
                    } else {
                        // Dropping into a tag group - add this tag if not already present
                        const numericTagId = parseInt(tagId);
                        const hasTag = currentTags.some(t => t.id === numericTagId);
                        if (!hasTag) {
                            try {
                                const response = await fetch(`/tasks/api/${taskId}/tags/add/`, {
                                    method: 'POST',
                                    headers: {
                                        'Content-Type': 'application/json',
                                        'X-CSRFToken': csrfToken
                                    },
                                    body: JSON.stringify({ tag_id: numericTagId })
                                });
                                const data = await response.json();
                                if (data.success) {
                                    taskTagsMap[taskId] = data.task_tags;
                                }
                            } catch (error) {
                                console.error('Error adding tag:', error);
                            }
                        }
                    }
                }

                // Rebuild tag groups to reflect changes
                buildTagGroups();
            });
        }

        // Build schedule groups: Today, Tomorrow, Future, Not Scheduled
        // Always filters out terminal (completed) and abandoned tasks
        function buildScheduleGroups(highlightTaskId = null) {
            const schedulesContent = document.getElementById('schedules-content');

            // Remember which groups were expanded before rebuilding
            const expandedGroupIds = [];
            schedulesContent.querySelectorAll('.state-group:not(.collapsed)').forEach(group => {
                expandedGroupIds.push(group.dataset.scheduleGroup);
            });

            schedulesContent.innerHTML = '';

            // Get terminal and abandoned state IDs
            const terminalStateId = getTerminalStateId();

            // Get all tasks from the state groups, excluding terminal and abandoned
            const allTasks = [];
            document.querySelectorAll('#states-content .task-card').forEach(card => {
                const taskId = parseInt(card.dataset.taskId);
                const title = card.querySelector('.task-card-title').textContent;
                const isCritical = card.classList.contains('critical');
                const tags = taskTagsMap[taskId] || [];

                // Check if task is in terminal or abandoned state
                const stateGroup = card.closest('.state-group');
                const rawStateId = stateGroup ? stateGroup.dataset.stateId : null;
                const taskStateId = rawStateId === 'none' ? null : (rawStateId ? parseInt(rawStateId) : null);
                const isCompleted = taskStateId === terminalStateId;
                const isAbandoned = abandonedStateId && taskStateId === abandonedStateId;

                // Always skip completed and abandoned tasks in this view
                if (isCompleted || isAbandoned) {
                    return;
                }

                // Get state name for the state pill
                const stateName = stateGroup ? stateGroup.querySelector('.state-group-name')?.textContent : null;

                allTasks.push({ id: taskId, title, isCritical, isCompleted: false, tags, stateName, element: card });
            });

            // Group tasks by schedule category
            const scheduleGroups = {
                today: { name: 'Today', icon: 'bi-sun', tasks: [] },
                tomorrow: { name: 'Tomorrow', icon: 'bi-sunrise', tasks: [] },
                future: { name: 'Future', icon: 'bi-calendar3', tasks: [] },
                unscheduled: { name: 'Not Scheduled', icon: 'bi-calendar-x', tasks: [] }
            };

            allTasks.forEach(task => {
                const schedules = taskSchedulesMap[task.id] || [];
                const scheduleLabel = getScheduleLabel(schedules);

                if (scheduleLabel === 'today') {
                    scheduleGroups.today.tasks.push(task);
                } else if (scheduleLabel === 'tomorrow') {
                    scheduleGroups.tomorrow.tasks.push(task);
                } else if (scheduleLabel === 'future') {
                    scheduleGroups.future.tasks.push(task);
                } else {
                    // No schedule or only past schedules
                    scheduleGroups.unscheduled.tasks.push(task);
                }
            });

            // Create group elements in order
            const groupOrder = ['today', 'tomorrow', 'future', 'unscheduled'];
            groupOrder.forEach(groupId => {
                const group = scheduleGroups[groupId];
                // If highlighting a task, put it at the top of each group it belongs to
                if (highlightTaskId) {
                    group.tasks.sort((a, b) => {
                        if (a.id === highlightTaskId) return -1;
                        if (b.id === highlightTaskId) return 1;
                        return 0;
                    });
                }
                const groupEl = createScheduleGroup(groupId, group.name, group.icon, group.tasks);
                schedulesContent.appendChild(groupEl);
            });

            // Restore previously expanded groups
            expandedGroupIds.forEach(groupId => {
                const group = schedulesContent.querySelector(`.state-group[data-schedule-group="${groupId}"]`);
                if (group) {
                    group.classList.remove('collapsed');
                }
            });

            // If highlighting a task, expand its group and apply visual feedback
            if (highlightTaskId) {
                const taskCard = schedulesContent.querySelector(`.task-card[data-task-id="${highlightTaskId}"]`);
                if (taskCard) {
                    const group = taskCard.closest('.state-group');
                    if (group) {
                        group.classList.remove('collapsed');
                    }
                    // Use same highlight animation as Tags view
                    taskCard.classList.add('highlight-new');
                    setTimeout(() => taskCard.classList.remove('highlight-new'), 4500);
                }
            }

            // Update counts and apply filters
            updatePanelCounts();
            applyFilters();
        }

        // Create a schedule group element
        function createScheduleGroup(groupId, groupName, iconClass, tasks) {
            const group = document.createElement('div');
            group.className = 'state-group collapsed';
            group.dataset.scheduleGroup = groupId;

            group.innerHTML = `
                <div class="state-group-header" onclick="toggleStateGroup(this)">
                    <div class="state-group-left">
                        <i class="bi ${iconClass} state-group-icon"></i>
                        <span class="state-group-name">${escapeHtml(groupName)}</span>
                    </div>
                    <div class="state-group-right">
                        <span class="state-group-count">${tasks.length}</span>
                        <i class="bi bi-chevron-down state-group-toggle"></i>
                    </div>
                </div>
                <div class="state-group-body" data-schedule-group="${groupId}"></div>
            `;

            const body = group.querySelector('.state-group-body');
            tasks.forEach(task => {
                const card = document.createElement('div');
                const schedules = taskSchedulesMap[task.id] || [];
                const isScheduled = schedules.length > 0;
                card.className = 'task-card' + (task.isCritical ? ' critical' : '') + (isScheduled ? ' scheduled' : '');
                card.dataset.taskId = task.id;

                // Show tag pills
                const tagsHtml = task.tags.length > 0
                    ? `<div class="task-card-tags">${task.tags.map(t => `<span class="task-tag-pill">${escapeHtml(t.name)}</span>`).join('')}</div>`
                    : '';

                // Don't show schedule pill in this view since we're already grouping by schedule
                const criticalIconHtml = task.isCritical ? '<i class="bi bi-exclamation-circle-fill task-critical-icon" title="Critical: High priority task requiring immediate attention"></i>' : '';
                const statePillHtml = task.stateName ? `<span class="task-state-pill">${escapeHtml(task.stateName)}</span>` : '';
                const hasIcons = task.isCritical || task.stateName;
                const iconsHtml = hasIcons ? `<div class="task-card-icons">${statePillHtml}${criticalIconHtml}</div>` : '';

                card.innerHTML = `
                    <div class="task-card-content">
                        <i class="bi bi-grip-vertical task-card-drag-handle"></i>
                        <div class="task-card-title">${escapeHtml(task.title)}</div>
                        ${tagsHtml}
                        ${iconsHtml}
                    </div>
                `;

                // Setup event handlers
                setupTaskCardDragEvents(card);
                card.addEventListener('contextmenu', function(e) {
                    e.preventDefault();
                    showContextMenu(e, parseInt(this.dataset.taskId), 'openTaskPanel');
                });
                body.appendChild(card);
            });

            // Right-click to show context menu with Select All option
            const header = group.querySelector('.state-group-header');
            header.addEventListener('contextmenu', function(e) {
                showGroupContextMenu(e, group);
            });

            return group;
        }

        // Update collapsed metrics for schedule view
        function updateCollapsedMetricsForSchedules() {
            const tasksCollapsedMetrics = document.getElementById('tasks-collapsed-metrics');
            const terminalStateId = getTerminalStateId();

            // Count tasks by schedule category (excluding completed and abandoned)
            let todayCount = 0;
            let tomorrowCount = 0;
            let futureCount = 0;
            let unscheduledCount = 0;

            document.querySelectorAll('#states-content .task-card').forEach(card => {
                const taskId = parseInt(card.dataset.taskId);
                const stateGroup = card.closest('.state-group');
                const rawStateId = stateGroup ? stateGroup.dataset.stateId : null;
                const taskStateId = rawStateId === 'none' ? null : (rawStateId ? parseInt(rawStateId) : null);

                // Skip completed and abandoned
                if (taskStateId === terminalStateId) return;
                if (abandonedStateId && taskStateId === abandonedStateId) return;

                const schedules = taskSchedulesMap[taskId] || [];
                const scheduleLabel = getScheduleLabel(schedules);

                if (scheduleLabel === 'today') todayCount++;
                else if (scheduleLabel === 'tomorrow') tomorrowCount++;
                else if (scheduleLabel === 'future') futureCount++;
                else unscheduledCount++;
            });

            tasksCollapsedMetrics.innerHTML = `
                <span class="metric-pill" data-schedule-group="today">Today: <span class="metric-count">${todayCount}</span></span>
                <span class="metric-pill" data-schedule-group="tomorrow">Tomorrow: <span class="metric-count">${tomorrowCount}</span></span>
                <span class="metric-pill" data-schedule-group="unscheduled">Unscheduled: <span class="metric-count">${unscheduledCount}</span></span>
            `;
        }

        function applyFilters() {
            // Determine which container to filter based on current view
            let containerSelector;
            if (currentGroupBy === 'tags') {
                containerSelector = '#tags-content';
            } else if (currentGroupBy === 'schedules') {
                containerSelector = '#schedules-content';
            } else {
                containerSelector = '#states-content';
            }

            // Filter cards only in the active view container (plus kanban cards which are separate)
            const allCards = document.querySelectorAll(`${containerSelector} .task-card, .kanban-card`);
            let visibleCount = 0;
            // Track unique task IDs for accurate counts in views where tasks appear in multiple groups
            const visibleTaskIds = new Set();

            allCards.forEach(card => {
                let show = true;
                const taskId = parseInt(card.dataset.taskId);

                // Filter by critical
                if (activeFilters.critical && !card.classList.contains('critical')) {
                    show = false;
                }

                // Filter by today (only show tasks scheduled for today)
                if (show && activeFilters.today) {
                    const schedules = taskSchedulesMap[taskId] || [];
                    const hasScheduleToday = schedules.some(s => isScheduledForToday(s.start_time));
                    if (!hasScheduleToday) {
                        show = false;
                    }
                }

                // Filter by tags (task must have at least one of the selected tags, or be untagged if 'untagged' is selected)
                if (show && activeFilters.tags.length > 0) {
                    const taskTags = taskTagsMap[taskId] || [];
                    const taskTagIds = taskTags.map(t => t.id);
                    const includeUntagged = activeFilters.tags.includes('untagged');
                    const regularTagFilters = activeFilters.tags.filter(t => t !== 'untagged');

                    let matches = false;
                    // Check if task matches any regular tag filters
                    if (regularTagFilters.length > 0 && regularTagFilters.some(tagId => taskTagIds.includes(tagId))) {
                        matches = true;
                    }
                    // Check if task is untagged and untagged filter is selected
                    if (includeUntagged && taskTags.length === 0) {
                        matches = true;
                    }
                    if (!matches) {
                        show = false;
                    }
                }

                // Filter by completed tasks (terminal state) - only in Tags view
                if (show && !showCompletedTasks && currentGroupBy === 'tags') {
                    const taskStateId = parseInt(card.closest('.state-group, .kanban-column')?.dataset?.stateId);
                    const terminalStateId = getTerminalStateId();
                    if (terminalStateId && taskStateId === terminalStateId) {
                        show = false;
                    }
                }

                // Filter by search text
                if (show && searchText) {
                    const titleEl = card.querySelector('.task-card-title, .kanban-card-title');
                    const title = titleEl ? titleEl.textContent.toLowerCase() : '';
                    if (!title.includes(searchText.toLowerCase())) {
                        show = false;
                    }
                }

                card.style.display = show ? '' : 'none';
                if (show) {
                    visibleCount++;
                    visibleTaskIds.add(taskId);
                }
            });

            // Update filter badge - no longer showing dot, using filter summary instead
            const hasActiveFilters = activeFilters.critical || activeFilters.today || activeFilters.tags.length > 0 || searchText;
            // Badge display removed - filter summary bar now shows active filters
            if (!hasActiveFilters && !filterDropdown.classList.contains('active')) {
                filterIcon.classList.remove('active');
            }

            // Update filter summary
            const filterSummary = document.getElementById('filter-summary');
            const visibleTaskCount = document.getElementById('visible-task-count');
            const totalTaskCount = document.getElementById('total-task-count');
            const filterInfoIcon = document.getElementById('filter-info-icon');

            // Check if in Tags or Schedules view (which always filter completed/abandoned)
            const isFilteredView = currentGroupBy === 'tags' || currentGroupBy === 'schedules';

            if (filterSummary && visibleTaskCount && totalTaskCount) {
                // For Tags and Schedules views, count unique tasks (not card instances)
                // since tasks can appear in multiple groups
                let totalTasks;
                let displayVisibleCount;

                if (isFilteredView) {
                    // Count unique tasks that are not completed/abandoned
                    const terminalStateId = getTerminalStateId();
                    const uniqueTotalTaskIds = new Set();
                    allCards.forEach(card => {
                        const taskId = parseInt(card.dataset.taskId);
                        const stateGroup = card.closest('.state-group, .kanban-column');
                        const rawStateId = stateGroup ? stateGroup.dataset.stateId : null;
                        const taskStateId = rawStateId === 'none' ? null : (rawStateId ? parseInt(rawStateId) : null);
                        const isCompleted = taskStateId === terminalStateId;
                        const isAbandoned = abandonedStateId && taskStateId === abandonedStateId;
                        if (!isCompleted && !isAbandoned) {
                            uniqueTotalTaskIds.add(taskId);
                        }
                    });
                    totalTasks = uniqueTotalTaskIds.size;
                    displayVisibleCount = visibleTaskIds.size;
                } else {
                    totalTasks = allCards.length;
                    displayVisibleCount = visibleCount;
                }

                visibleTaskCount.textContent = displayVisibleCount;
                totalTaskCount.textContent = totalTasks;

                // Show filter summary if there are active filters OR if in a filtered view
                // But hide it if the tasks panel is collapsed or minimized
                const tasksPanel = document.getElementById('tasks-panel');
                const isPanelCollapsed = tasksPanel && (tasksPanel.classList.contains('collapsed') || tasksPanel.classList.contains('minimized'));
                const showFilterSummary = ((hasActiveFilters && displayVisibleCount < totalTasks) || isFilteredView) && !isPanelCollapsed;

                if (showFilterSummary) {
                    filterSummary.classList.add('active');

                    // Build tooltip describing active filters
                    const filterTooltip = document.getElementById('filter-info-tooltip');
                    if (filterTooltip) {
                        const filterDescriptions = [];

                        // Always show this message first for Tags and Schedules views
                        if (isFilteredView) {
                            filterDescriptions.push('Completed and abandoned tasks hidden');
                        }

                        if (activeFilters.critical) {
                            filterDescriptions.push('Critical tasks only');
                        }
                        if (activeFilters.today) {
                            filterDescriptions.push('Tasks scheduled for today');
                        }
                        if (activeFilters.tags.length > 0) {
                            const tagNames = activeFilters.tags.map(tagId => {
                                if (tagId === 'untagged') return 'Untagged';
                                const tag = tagsList.find(t => t.id === tagId);
                                return tag ? tag.name : tagId;
                            });
                            filterDescriptions.push('Tags: ' + tagNames.join(', '));
                        }
                        if (searchText) {
                            filterDescriptions.push('Search: "' + searchText + '"');
                        }

                        if (filterDescriptions.length > 0) {
                            filterTooltip.innerHTML = 'Active filters:<br>' + filterDescriptions.map(d => '- ' + d).join('<br>');
                        } else {
                            filterTooltip.innerHTML = 'No additional filters active';
                        }
                    }

                    // Update clear filters link text based on whether search is active
                    const clearFiltersLink = document.getElementById('clear-filters-link');
                    if (clearFiltersLink) {
                        clearFiltersLink.textContent = searchText ? 'Clear search' : 'Clear filters';
                    }
                } else {
                    filterSummary.classList.remove('active');
                }
            }

            // Update counts for both layouts
            updateKanbanCounts();
            if (typeof updatePanelCounts === 'function') {
                updatePanelCounts();
            }
        }

        // Helper function to check if a calendar time is today
        function isScheduledForToday(calendarTimeStr) {
            if (!calendarTimeStr) return false;
            const calendarDate = new Date(calendarTimeStr);
            const today = new Date();
            return calendarDate.getFullYear() === today.getFullYear() &&
                   calendarDate.getMonth() === today.getMonth() &&
                   calendarDate.getDate() === today.getDate();
        }

        // Get schedule label for a task's schedules: "today", "tomorrow", "future", or null (past only)
        function getScheduleLabel(schedules) {
            if (!schedules || schedules.length === 0) return null;

            const now = new Date();
            const today = new Date(now.getFullYear(), now.getMonth(), now.getDate());
            const tomorrow = new Date(today.getTime() + 24 * 60 * 60 * 1000);
            const dayAfterTomorrow = new Date(today.getTime() + 2 * 24 * 60 * 60 * 1000);

            let hasToday = false;
            let hasTomorrow = false;
            let hasFuture = false;

            for (const schedule of schedules) {
                const scheduleDate = new Date(schedule.start_time);
                const scheduleDateOnly = new Date(scheduleDate.getFullYear(), scheduleDate.getMonth(), scheduleDate.getDate());

                if (scheduleDateOnly.getTime() === today.getTime()) {
                    hasToday = true;
                } else if (scheduleDateOnly.getTime() === tomorrow.getTime()) {
                    hasTomorrow = true;
                } else if (scheduleDateOnly >= dayAfterTomorrow) {
                    hasFuture = true;
                }
                // Past dates are ignored
            }

            // Return the most urgent/relevant label
            if (hasToday) return 'today';
            if (hasTomorrow) return 'tomorrow';
            if (hasFuture) return 'future';
            return null; // Only past dates
        }

        // Generate schedule pill HTML
        function getSchedulePillHtml(schedules) {
            const label = getScheduleLabel(schedules);
            if (!label) return '';

            const displayText = label.charAt(0).toUpperCase() + label.slice(1);
            return `<span class="task-schedule-pill ${label}">${displayText}</span>`;
        }

        // Override updateKanbanCounts to respect filters
        const originalUpdateKanbanCounts = updateKanbanCounts;
        updateKanbanCounts = function() {
            document.querySelectorAll('.kanban-column-body').forEach(body => {
                const stateId = body.dataset.stateId;
                const count = body.querySelectorAll('.kanban-card:not([style*="display: none"])').length;
                const countEl = document.getElementById(`count-state-${stateId}`);
                if (countEl) countEl.textContent = count;
            });
        };

        // ========== Two-Panel Layout ==========

        // Panel collapse/expand
        const tasksPanel = document.getElementById('tasks-panel');
        const calendarPanel = document.getElementById('calendar-panel');
        const notesPanel = document.getElementById('notes-panel');
        const tasksPanelHeader = document.getElementById('tasks-panel-header');
        const calendarPanelHeader = document.getElementById('calendar-panel-header');
        const notesPanelHeader = document.getElementById('notes-panel-header');
        const tasksPanelWrapper = document.getElementById('tasks-panel-wrapper');

        // All panels for iteration
        const allPanels = [tasksPanel, calendarPanel, notesPanel].filter(p => p);

        // Sync wrapper class with tasks panel collapsed state
        function updateTasksPanelWrapperState() {
            if (tasksPanelWrapper) {
                const isCollapsed = tasksPanel.classList.contains('collapsed');
                const isMinimized = tasksPanel.classList.contains('minimized');
                tasksPanelWrapper.classList.toggle('panel-collapsed', isCollapsed);
                tasksPanelWrapper.classList.toggle('panel-minimized', isMinimized);
            }
        }

        // Old vertical collapse code removed - now using horizontal layout system

        // Right-click context menu for Tasks panel
        function expandAllStateGroups() {
            document.querySelectorAll('#states-content .state-group.collapsed').forEach(group => {
                group.classList.remove('collapsed');
            });
            closeTasksPanelContextMenu();
        }

        function collapseAllStateGroups() {
            document.querySelectorAll('#states-content .state-group:not(.collapsed)').forEach(group => {
                group.classList.add('collapsed');
            });
            closeTasksPanelContextMenu();
        }

        function closeTasksPanelContextMenu() {
            const menu = document.getElementById('tasks-panel-context-menu');
            if (menu) menu.remove();
        }

        tasksPanel.addEventListener('contextmenu', function(e) {
            // Only show on the panel body, not on task cards or state headers
            if (e.target.closest('.task-card') || e.target.closest('.kanban-card') || e.target.closest('.state-group-header')) return;

            e.preventDefault();
            closeTasksPanelContextMenu();
            closeContextMenu(); // Close any task context menu

            const menuHtml = `
                <div class="task-context-menu-item" onclick="expandAllStateGroups()">
                    <i class="bi bi-arrows-expand"></i>
                    Expand All States
                </div>
                <div class="task-context-menu-item" onclick="collapseAllStateGroups()">
                    <i class="bi bi-arrows-collapse"></i>
                    Collapse All States
                </div>
            `;

            const menu = document.createElement('div');
            menu.className = 'task-context-menu';
            menu.id = 'tasks-panel-context-menu';
            menu.innerHTML = menuHtml;
            document.body.appendChild(menu);

            // Position the menu
            const menuRect = menu.getBoundingClientRect();
            let x = e.clientX;
            let y = e.clientY;

            if (x + menuRect.width > window.innerWidth) {
                x = window.innerWidth - menuRect.width - 10;
            }
            if (y + menuRect.height > window.innerHeight) {
                y = window.innerHeight - menuRect.height - 10;
            }

            menu.style.left = x + 'px';
            menu.style.top = y + 'px';

            // Close on click outside
            setTimeout(() => {
                document.addEventListener('click', closeTasksPanelContextMenu, { once: true });
            }, 0);
        });

        // Old vertical collapse code removed - now using horizontal layout system

        // Panel expand/minimize (horizontal)
        const tasksExpandBtn = document.getElementById('tasks-expand-btn');
        const calendarExpandBtn = document.getElementById('calendar-expand-btn');
        const notesExpandBtn = document.getElementById('notes-expand-btn');

        // Helper to clear all expansion classes from a panel
        function clearPanelClasses(panel) {
            panel.classList.remove('fully-expanded', 'half-expanded', 'minimized', 'expanded', 'collapsed');
        }

        // Get panels that are NOT minimized (i.e., visible/expanded)
        function getVisiblePanels() {
            return allPanels.filter(p => !p.classList.contains('minimized'));
        }

        // Apply correct classes based on how many panels are visible
        // States: 1 visible = fully-expanded, 2 visible = half-expanded each
        function applyPanelStates() {
            const visiblePanels = getVisiblePanels();

            allPanels.forEach(panel => {
                clearPanelClasses(panel);

                if (visiblePanels.includes(panel)) {
                    if (visiblePanels.length === 1) {
                        panel.classList.add('fully-expanded');
                    } else {
                        panel.classList.add('half-expanded');
                    }
                } else {
                    panel.classList.add('minimized');
                }
            });

            // Hide filter summary when Tasks panel is minimized or collapsed
            const tasksPanel = document.getElementById('tasks-panel');
            const filterSummary = document.getElementById('filter-summary');
            if (tasksPanel && filterSummary) {
                if (tasksPanel.classList.contains('minimized') || tasksPanel.classList.contains('collapsed')) {
                    filterSummary.style.display = 'none';
                } else {
                    // Show filter summary only if filters are active
                    const hasActiveFilters = document.querySelectorAll('#state-filter-options .filter-option.active, #tag-filter-options .filter-option.active').length > 0;
                    filterSummary.style.display = hasActiveFilters ? 'flex' : 'none';
                }
            }
        }

        // Toggle panel expansion
        // Click on expanded panel  make it fully expanded (minimize others)
        // Click on minimized panel  add it to visible group
        function togglePanelExpand(panel) {
            const isMinimized = panel.classList.contains('minimized');
            const visiblePanels = getVisiblePanels();

            if (isMinimized) {
                // Clicking on minimized panel - add it to visible group
                if (visiblePanels.length >= 2) {
                    // Already 2 visible - this one becomes fully expanded alone
                    allPanels.forEach(p => clearPanelClasses(p));
                    allPanels.forEach(p => p.classList.add('minimized'));
                    panel.classList.remove('minimized');
                } else {
                    // 1 visible - add this one (now 2 visible, half-expanded each)
                    panel.classList.remove('minimized');
                }
            } else {
                // Clicking on visible (expanded) panel
                if (visiblePanels.length === 2) {
                    // Two are visible - make this one fully expanded alone
                    allPanels.forEach(p => clearPanelClasses(p));
                    allPanels.forEach(p => p.classList.add('minimized'));
                    panel.classList.remove('minimized');
                } else if (visiblePanels.length === 1) {
                    // Only this one visible - add the first minimized one
                    const minimizedPanels = allPanels.filter(p => p.classList.contains('minimized'));
                    if (minimizedPanels.length > 0) {
                        minimizedPanels[0].classList.remove('minimized');
                    }
                }
            }

            applyPanelStates();
        }

        // Old expand button handlers removed - now using layout modal system instead

        // Old panel initialization disabled - now handled by restoreLayout() function
        // function initializePanelStates() {
        //     allPanels.forEach(p => clearPanelClasses(p));
        //
        //     // Set initial state: Tasks and Calendar half-expanded, Notes minimized
        //     tasksPanel.classList.add('half-expanded');
        //     calendarPanel.classList.add('half-expanded');
        //     if (notesPanel) {
        //         notesPanel.classList.add('minimized');
        //     }
        // }

        // initializePanelStates();
        updateTasksPanelWrapperState();

        // State group collapse/expand
        function toggleStateGroup(header) {
            const group = header.closest('.state-group');
            group.classList.toggle('collapsed');
        }

        // Generate hourly calendar (7am to 6pm)
        function generateHourlyCalendar() {
            const grid = document.getElementById('hourly-grid');
            if (!grid) return;

            grid.innerHTML = '';

            for (let hour = 7; hour <= 18; hour++) {
                const hourRow = document.createElement('div');
                hourRow.className = 'hour-row';
                hourRow.dataset.hour = hour;

                const ampm = hour >= 12 ? 'PM' : 'AM';
                const displayHour = hour > 12 ? hour - 12 : hour;

                hourRow.innerHTML = `
                    <div class="hour-label">${displayHour}${ampm}</div>
                    <div class="hour-content" data-hour="${hour}"></div>
                `;

                grid.appendChild(hourRow);
            }

            // Add current time indicator line
            const timeLine = document.createElement('div');
            timeLine.className = 'current-time-line';
            timeLine.id = 'current-time-line';
            grid.appendChild(timeLine);

            // Add NOW label
            const nowLabel = document.createElement('div');
            nowLabel.className = 'current-time-now-label';
            nowLabel.id = 'current-time-now-label';
            nowLabel.textContent = 'NOW';
            grid.appendChild(nowLabel);
        }

        // Update current time line position
        function updateCurrentTimeLine() {
            const timeLine = document.getElementById('current-time-line');
            const nowLabel = document.getElementById('current-time-now-label');
            const grid = document.getElementById('hourly-grid');
            if (!timeLine || !grid) return;

            const now = new Date();
            const currentHour = now.getHours();
            const currentMinutes = now.getMinutes();

            // Hide line if outside calendar hours (7am-6pm)
            if (currentHour < 7 || currentHour >= 19) {
                timeLine.style.display = 'none';
                if (nowLabel) nowLabel.style.display = 'none';
                return;
            }

            // Show line
            timeLine.style.display = 'block';
            if (nowLabel) nowLabel.style.display = 'block';

            // Calculate position
            // Each hour row is 60px tall (from min-height in CSS)
            const hourRowHeight = 60;
            const hoursSince7am = currentHour - 7;
            const minuteOffset = (currentMinutes / 60) * hourRowHeight;
            const topPosition = (hoursSince7am * hourRowHeight) + minuteOffset;

            timeLine.style.top = `${topPosition}px`;

            // Position NOW label
            if (nowLabel) {
                nowLabel.style.top = `${topPosition - 1}px`;
            }
        }

        // Set today's date in calendar header
        function setCalendarDate() {
            const dateEl = document.getElementById('calendar-date-text');
            if (!dateEl) return;

            const today = new Date();
            const options = { weekday: 'long', month: 'long', day: 'numeric' };
            dateEl.textContent = today.toLocaleDateString('en-US', options);
        }

        // Calendar events from database (UTC ISO timestamps)
        const calendarEvents = {{ calendar_events|safe }};

        // Time blocks from database (UTC ISO timestamps)
        let timeBlocks = {{ time_blocks|safe }};

        // Task detail templates from database
        let detailTemplates = {{ detail_templates|safe }};

        // Gap-fill feature: track modifier key state for Cmd/Ctrl + hover
        let isModifierKeyHeld = false;
        let currentGapPreview = null;  // { startTime: Date, endTime: Date }

        // State for calendar event drag
        let currentDragCalendarEventId = null;

        // Render calendar events on the hourly grid (using browser's local timezone)
        function renderCalendarEvents() {
            // Remove existing event elements before re-rendering
            document.querySelectorAll('.hour-event').forEach(el => el.remove());

            if (!calendarEvents || calendarEvents.length === 0) return;

            // Get current calendar date boundaries in local timezone
            const todayStart = new Date(currentCalendarDate);
            const todayEnd = new Date(todayStart.getTime() + 24 * 60 * 60 * 1000);

            calendarEvents.forEach(event => {
                // Skip all-day events for now (could add a separate section)
                if (event.is_all_day) return;

                // Use override times if present, otherwise use original times
                const startDate = event.override_start ? new Date(event.override_start) : new Date(event.start);
                const endDate = event.override_end ? new Date(event.override_end) : new Date(event.end);

                // Skip events that don't overlap with current calendar date (in local timezone)
                if (endDate <= todayStart || startDate >= todayEnd) return;

                // Get local hours and minutes
                const startHourLocal = startDate.getHours();
                const startMinuteLocal = startDate.getMinutes();
                const endHourLocal = endDate.getHours();
                const endMinuteLocal = endDate.getMinutes();

                // Find the starting hour row (clamp to visible range 7-18)
                const startHour = Math.max(7, Math.min(18, startHourLocal));
                const endHour = Math.max(7, Math.min(19, endHourLocal + (endMinuteLocal > 0 ? 1 : 0)));

                // Skip events that end before 7am or start after 6pm
                if (endHourLocal < 7 || startHourLocal > 18) return;

                const hourContent = document.querySelector(`.hour-content[data-hour="${startHour}"]`);
                if (!hourContent) return;

                // Calculate position and height
                const minuteOffset = startHourLocal >= 7 ? startMinuteLocal : 0;
                const topPercent = (minuteOffset / 60) * 100;

                // Calculate duration in hours (for height)
                const startMinutes = startHourLocal * 60 + startMinuteLocal;
                const endMinutes = endHourLocal * 60 + endMinuteLocal;
                let durationMinutes = endMinutes - startMinutes;

                // Clamp to visible range
                const visibleStartMinutes = Math.max(7 * 60, startMinutes);
                const visibleEndMinutes = Math.min(19 * 60, endMinutes);
                durationMinutes = visibleEndMinutes - visibleStartMinutes;

                // Minimum 30 minutes to ensure text isn't cut off
                durationMinutes = Math.max(30, durationMinutes);

                const durationHours = durationMinutes / 60;
                const heightPx = durationHours * 60; // 60px per hour

                // Create event element
                const eventEl = document.createElement('div');
                eventEl.className = 'hour-event';
                eventEl.dataset.eventId = event.id;
                eventEl.draggable = true;
                eventEl.style.position = 'absolute';
                eventEl.style.top = `${topPercent}%`;
                eventEl.style.left = '4px';
                eventEl.style.right = '4px';
                eventEl.style.height = `${heightPx}px`;
                eventEl.style.zIndex = '1';
                eventEl.style.borderRadius = '4px';
                eventEl.style.cursor = 'grab';

                // Show visual indicator if this event has been moved locally
                const hasOverride = event.override_start || event.override_end;

                // Format time for tooltip
                const formatTime = (date) => {
                    let hours = date.getHours();
                    const minutes = date.getMinutes();
                    const ampm = hours >= 12 ? 'PM' : 'AM';
                    hours = hours % 12 || 12;
                    const minutesStr = minutes < 10 ? '0' + minutes : minutes;
                    return `${hours}:${minutesStr} ${ampm}`;
                };

                const actualDurationMinutes = Math.round((endDate - startDate) / (1000 * 60));
                const timeInfo = `${formatTime(startDate)} to ${formatTime(endDate)} (${actualDurationMinutes} mins)`;
                const tooltipText = `${timeInfo}${event.location ? '\n' + event.location : ''}${hasOverride ? '\n(Moved locally - resets on next import)' : ''}`;

                eventEl.dataset.tooltip = tooltipText;

                eventEl.innerHTML = `
                    <div class="hour-event-content">
                        <span class="hour-event-subject">${event.subject}</span>
                        <button class="hour-event-hide-btn" title="Hide event (resets on next import)">
                            <i class="bi bi-x"></i>
                        </button>
                    </div>
                    ${hasOverride ? '<div class="hour-event-override-indicator" title="Moved locally - will reset on next import"></div>' : ''}
                `;

                // Add drag event handlers
                eventEl.addEventListener('dragstart', function(e) {
                    currentDragCalendarEventId = event.id;
                    e.dataTransfer.setData('text/plain', event.id);
                    e.dataTransfer.setData('application/x-calendar-event', 'true');
                    e.dataTransfer.effectAllowed = 'move';
                    this.style.opacity = '0.5';
                });

                eventEl.addEventListener('dragend', function(e) {
                    currentDragCalendarEventId = null;
                    this.style.opacity = '1';
                });

                // Add hide button handler
                const hideBtn = eventEl.querySelector('.hour-event-hide-btn');
                hideBtn.addEventListener('click', async function(e) {
                    e.stopPropagation();
                    await hideCalendarEvent(event.id);
                });

                hourContent.appendChild(eventEl);
            });
        }

        // Hide a calendar event (local override, resets on next import)
        async function hideCalendarEvent(eventId) {
            try {
                const response = await fetch(`/tasks/api/calendar-events/${eventId}/hide/`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-CSRFToken': csrfToken
                    }
                });

                const data = await response.json();
                if (data.success) {
                    // Remove from local array
                    const index = calendarEvents.findIndex(e => e.id === eventId);
                    if (index !== -1) {
                        calendarEvents.splice(index, 1);
                    }
                    renderCalendarEvents();
                }
            } catch (error) {
                console.error('Error hiding calendar event:', error);
            }
        }

        // Move a calendar event to a new time (local override, resets on next import)
        async function moveCalendarEvent(eventId, newStartTime, newEndTime) {
            try {
                const response = await fetch(`/tasks/api/calendar-events/${eventId}/move/`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-CSRFToken': csrfToken
                    },
                    body: JSON.stringify({
                        start_time: newStartTime.toISOString(),
                        end_time: newEndTime.toISOString()
                    })
                });

                const data = await response.json();
                if (data.success) {
                    // Update local array
                    const event = calendarEvents.find(e => e.id === eventId);
                    if (event) {
                        event.override_start = data.event.override_start;
                        event.override_end = data.event.override_end;
                    }
                    renderCalendarEvents();
                }
            } catch (error) {
                console.error('Error moving calendar event:', error);
            }
        }

        // ========== Gap-Fill Feature (Cmd/Ctrl + Hover) ==========

        // Get time at a specific position in an hour
        function getTimeAtPosition(hour, minute) {
            const calDate = new Date(currentCalendarDate);
            return new Date(calDate.getFullYear(), calDate.getMonth(), calDate.getDate(), hour, minute);
        }

        // Check if a specific time is occupied by any calendar item
        function isPositionOccupied(time) {
            const todayStart = new Date(currentCalendarDate);
            todayStart.setHours(0, 0, 0, 0);
            const todayEnd = new Date(todayStart.getTime() + 24 * 60 * 60 * 1000);

            // Check calendar events (use override times if present)
            for (const event of calendarEvents) {
                if (event.is_all_day) continue;
                const eventStart = event.override_start ? new Date(event.override_start) : new Date(event.start);
                const eventEnd = event.override_end ? new Date(event.override_end) : new Date(event.end);
                if (eventStart < todayEnd && eventEnd > todayStart) {
                    if (time >= eventStart && time < eventEnd) return true;
                }
            }

            // Check time blocks
            for (const block of timeBlocks) {
                const blockStart = new Date(block.start);
                const blockEnd = new Date(block.end);
                if (blockStart < todayEnd && blockEnd > todayStart) {
                    if (time >= blockStart && time < blockEnd) return true;
                }
            }

            // Check scheduled tasks
            for (const taskId in taskSchedulesMap) {
                for (const schedule of taskSchedulesMap[taskId]) {
                    const schedStart = new Date(schedule.start_time);
                    const schedEnd = new Date(schedule.end_time);
                    if (schedStart < todayEnd && schedEnd > todayStart) {
                        if (time >= schedStart && time < schedEnd) return true;
                    }
                }
            }

            return false;
        }

        // Find the gap (empty space) that contains the cursor time
        function findGapAtTime(cursorTime) {
            const todayStart = new Date(currentCalendarDate);
            todayStart.setHours(0, 0, 0, 0);
            const todayEnd = new Date(todayStart.getTime() + 24 * 60 * 60 * 1000);

            // Collect all item boundaries on current day
            const items = [];

            // Calendar events (use override times if present)
            calendarEvents.forEach(event => {
                if (event.is_all_day) return;
                const start = event.override_start ? new Date(event.override_start) : new Date(event.start);
                const end = event.override_end ? new Date(event.override_end) : new Date(event.end);
                if (start < todayEnd && end > todayStart) {
                    items.push({
                        start: new Date(Math.max(start.getTime(), todayStart.getTime())),
                        end: new Date(Math.min(end.getTime(), todayEnd.getTime()))
                    });
                }
            });

            // Time blocks
            timeBlocks.forEach(block => {
                const start = new Date(block.start);
                const end = new Date(block.end);
                if (start < todayEnd && end > todayStart) {
                    items.push({
                        start: new Date(Math.max(start.getTime(), todayStart.getTime())),
                        end: new Date(Math.min(end.getTime(), todayEnd.getTime()))
                    });
                }
            });

            // Scheduled tasks
            Object.values(taskSchedulesMap).forEach(schedules => {
                schedules.forEach(schedule => {
                    const start = new Date(schedule.start_time);
                    const end = new Date(schedule.end_time);
                    if (start < todayEnd && end > todayStart) {
                        items.push({
                            start: new Date(Math.max(start.getTime(), todayStart.getTime())),
                            end: new Date(Math.min(end.getTime(), todayEnd.getTime()))
                        });
                    }
                });
            });

            // Sort by start time
            items.sort((a, b) => a.start - b.start);

            // Use calendar visible bounds (7am to 7pm)
            const visibleStart = new Date(todayStart);
            visibleStart.setHours(7, 0, 0, 0);
            const visibleEnd = new Date(todayStart);
            visibleEnd.setHours(19, 0, 0, 0);  // 7PM

            // Find gap that contains cursorTime
            let gapStart = visibleStart;

            for (const item of items) {
                // Skip items outside visible range
                if (item.end <= visibleStart) continue;
                if (item.start >= visibleEnd) break;

                if (item.start > gapStart) {
                    // There's a gap between gapStart and item.start
                    if (cursorTime >= gapStart && cursorTime < item.start) {
                        return { start: gapStart, end: item.start };
                    }
                }
                // Move gapStart to end of this item (if it extends our current position)
                if (item.end > gapStart) {
                    gapStart = new Date(item.end);
                }
            }

            // Check final gap (from last item to end of visible day)
            if (cursorTime >= gapStart && cursorTime < visibleEnd) {
                return { start: gapStart, end: visibleEnd };
            }

            return null;
        }

        // Show the gap-fill preview
        function showGapPreview(startTime, endTime) {
            // Remove any existing preview
            clearGapPreview();

            // Store current gap info
            currentGapPreview = { startTime, endTime };

            const startHour = startTime.getHours();
            const startMinute = startTime.getMinutes();

            // Find the starting hour's container
            const hourContent = document.querySelector(`.hour-content[data-hour="${startHour}"]`);
            if (!hourContent) return;

            // Calculate total duration in minutes
            const durationMs = endTime - startTime;
            const durationMinutes = durationMs / (1000 * 60);

            // Calculate position and height as percentage of one hour (60 minutes)
            // Height can exceed 100% to span multiple hours
            const topPercent = (startMinute / 60) * 100;
            const heightPercent = (durationMinutes / 60) * 100;

            // Create a single preview element
            const preview = document.createElement('div');
            preview.className = 'gap-fill-preview';
            preview.style.top = `${topPercent}%`;
            preview.style.height = `${heightPercent}%`;
            preview.innerHTML = '<span class="gap-fill-label">Click to block</span>';

            hourContent.appendChild(preview);
        }

        // Clear the gap-fill preview
        function clearGapPreview() {
            document.querySelectorAll('.gap-fill-preview').forEach(el => el.remove());
            currentGapPreview = null;
        }

        // Create a time block to fill the gap
        async function createBlockedTimeForGap(startTime, endTime) {
            try {
                const response = await fetch('/tasks/api/time-blocks/create/', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-CSRFToken': csrfToken
                    },
                    body: JSON.stringify({
                        name: 'Blocked Time',
                        start_time: startTime.toISOString(),
                        end_time: endTime.toISOString()
                    })
                });

                const data = await response.json();
                if (data.success) {
                    timeBlocks.push(data.time_block);
                    renderTimeBlocks();
                    clearGapPreview();
                }
            } catch (error) {
                console.error('Error creating blocked time:', error);
            }
        }

        // ========== Time Blocks on Calendar ==========

        // State for time block resize
        let timeBlockResizeState = null;

        // Render time blocks on the calendar
        function renderTimeBlocks() {
            // Remove existing time block elements
            document.querySelectorAll('.calendar-time-block').forEach(el => el.remove());

            if (!timeBlocks || timeBlocks.length === 0) return;

            // Get current calendar date boundaries in local timezone
            const todayStart = new Date(currentCalendarDate);
            const todayEnd = new Date(todayStart.getTime() + 24 * 60 * 60 * 1000);

            timeBlocks.forEach(block => {
                const startDate = new Date(block.start);
                const endDate = new Date(block.end);

                // Skip blocks not for today
                if (endDate <= todayStart || startDate >= todayEnd) return;

                const startHour = startDate.getHours();
                const startMinute = startDate.getMinutes();

                // Skip if outside visible range (7am-6pm)
                if (startHour < 7 || startHour > 18) return;

                const hourContent = document.querySelector(`.hour-content[data-hour="${startHour}"]`);
                if (!hourContent) return;

                // Calculate duration and height
                const durationMinutes = (endDate - startDate) / (1000 * 60);
                const heightPercent = (durationMinutes / 60) * 100;

                // Create time block element
                const blockEl = document.createElement('div');
                blockEl.className = 'calendar-time-block';
                blockEl.dataset.blockId = block.id;
                blockEl.title = block.name;

                // Create content wrapper
                const contentWrapper = document.createElement('div');
                contentWrapper.className = 'time-block-content';

                // Add title text
                const titleSpan = document.createElement('span');
                titleSpan.className = 'time-block-title';
                titleSpan.textContent = block.name;
                contentWrapper.appendChild(titleSpan);

                // Add double-click to edit
                blockEl.addEventListener('dblclick', function(e) {
                    e.stopPropagation();
                    openEditTimeBlockModal(block.id);
                });

                // Add right-click context menu
                blockEl.addEventListener('contextmenu', function(e) {
                    e.preventDefault();
                    e.stopPropagation();
                    showTimeBlockContextMenu(e, block.id);
                });

                blockEl.appendChild(contentWrapper);

                // Add remove button
                const removeBtn = document.createElement('button');
                removeBtn.className = 'remove-btn';
                removeBtn.innerHTML = '<i class="bi bi-x"></i>';
                removeBtn.title = 'Remove event';
                removeBtn.addEventListener('click', async function(e) {
                    e.stopPropagation();
                    await deleteTimeBlock(block.id);
                });
                blockEl.appendChild(removeBtn);

                // Add top resize handle
                const resizeHandleTop = document.createElement('div');
                resizeHandleTop.className = 'time-block-resize-handle-top';
                resizeHandleTop.addEventListener('mousedown', function(e) {
                    e.stopPropagation();
                    e.preventDefault();
                    startTimeBlockResize(e, blockEl, block.id, startDate, endDate, 'top');
                });
                blockEl.appendChild(resizeHandleTop);

                // Add bottom resize handle
                const resizeHandle = document.createElement('div');
                resizeHandle.className = 'time-block-resize-handle';
                resizeHandle.addEventListener('mousedown', function(e) {
                    e.stopPropagation();
                    e.preventDefault();
                    startTimeBlockResize(e, blockEl, block.id, startDate, endDate, 'bottom');
                });
                blockEl.appendChild(resizeHandle);

                // Check if this time block starts exactly when any item ends
                // Events use heightPx - 4, so we need special pixel positioning for them
                // Time blocks and tasks use percentage positioning, so they align naturally
                let adjustedTopPx = null;

                // Check calendar events (need pixel adjustment for -4px gap)
                calendarEvents.forEach(event => {
                    const eventEnd = new Date(event.end);
                    if (Math.abs(eventEnd - startDate) < 1000) { // Within 1 second
                        // Found an adjacent event - calculate where it visually ends
                        const eventStart = new Date(event.start);
                        const eventStartHour = eventStart.getHours();
                        const eventStartMinute = eventStart.getMinutes();

                        // Event duration and visual height
                        const eventDurationMinutes = (eventEnd - eventStart) / (1000 * 60);
                        const eventHeightPx = (eventDurationMinutes / 60) * 60;

                        // Where the event starts in its hour (in pixels)
                        const eventTopPx = (eventStartMinute / 60) * 60;

                        // Where the event visually ends (in pixels from top of its start hour)
                        const eventVisualEndPx = eventTopPx + eventHeightPx;

                        // Calculate how many pixels into the current hour that is
                        const hoursDiff = startHour - eventStartHour;
                        adjustedTopPx = eventVisualEndPx - (hoursDiff * 60);
                    }
                });

                // Also check for adjacent time blocks (use pixel positioning to avoid percentage rounding gaps)
                if (adjustedTopPx === null) {
                    timeBlocks.forEach(otherBlock => {
                        if (otherBlock.id === block.id) return; // Skip self
                        const otherEnd = new Date(otherBlock.end);
                        const timeDiff = Math.abs(otherEnd - startDate);
                        if (timeDiff < 1000) { // Within 1 second
                            // Found an adjacent time block - use pixel positioning
                            const otherStart = new Date(otherBlock.start);
                            const otherStartHour = otherStart.getHours();
                            const otherStartMinute = otherStart.getMinutes();

                            // Time block duration and visual height (60px per hour)
                            const otherDurationMinutes = (otherEnd - otherStart) / (1000 * 60);
                            const otherHeightPx = (otherDurationMinutes / 60) * 60;

                            // Where the other block starts in its hour (in pixels)
                            const otherTopPx = (otherStartMinute / 60) * 60;

                            // Where the other block visually ends (in pixels from top of its start hour)
                            const otherVisualEndPx = otherTopPx + otherHeightPx;

                            // Calculate how many pixels into the current hour that is
                            const hoursDiff = startHour - otherStartHour;
                            adjustedTopPx = otherVisualEndPx - (hoursDiff * 60);
                        }
                    });
                }

                // Also check for adjacent scheduled tasks
                if (adjustedTopPx === null) {
                    Object.keys(taskSchedulesMap).forEach(taskId => {
                        const schedules = taskSchedulesMap[taskId] || [];
                        schedules.forEach(schedule => {
                            const scheduleEnd = new Date(schedule.end_time);
                            if (Math.abs(scheduleEnd - startDate) < 1000) { // Within 1 second
                                // Found an adjacent scheduled task - use pixel positioning
                                const scheduleStart = new Date(schedule.start_time);
                                const scheduleStartHour = scheduleStart.getHours();
                                const scheduleStartMinute = scheduleStart.getMinutes();

                                const scheduleDurationMinutes = (scheduleEnd - scheduleStart) / (1000 * 60);
                                const scheduleHeightPx = (scheduleDurationMinutes / 60) * 60;
                                const scheduleTopPx = (scheduleStartMinute / 60) * 60;
                                const scheduleVisualEndPx = scheduleTopPx + scheduleHeightPx;

                                const hoursDiff = startHour - scheduleStartHour;
                                adjustedTopPx = scheduleVisualEndPx - (hoursDiff * 60);
                            }
                        });
                    });
                }

                if (adjustedTopPx !== null && adjustedTopPx >= -4 && adjustedTopPx < 60) {
                    // Position time block exactly where adjacent item visually ends
                    // Allow small negative values (down to -4px) to close gaps from cascading offsets
                    blockEl.style.top = `${adjustedTopPx}px`;
                    blockEl.style.height = `${heightPercent}%`;
                } else {
                    // Normal percentage-based positioning
                    const topPercent = (startMinute / 60) * 100;
                    blockEl.style.top = `${topPercent}%`;
                    blockEl.style.height = `${heightPercent}%`;
                }

                blockEl.style.minHeight = '28px';

                // Make time block draggable
                blockEl.draggable = true;
                setupTimeBlockDragEvents(blockEl);

                hourContent.appendChild(blockEl);
            });
        }

        // Start resizing a time block
        function startTimeBlockResize(e, blockEl, blockId, startDate, endDate, edge) {
            const block = timeBlocks.find(b => b.id === blockId);
            if (!block) return;

            // Calculate initialTop from actual time data (not CSS which may be in pixels)
            const blockStartDate = new Date(block.start);
            const blockEndDate = new Date(block.end);
            const startMinute = blockStartDate.getMinutes();
            const initialTopPercent = (startMinute / 60) * 100;

            // Calculate height from actual duration
            const durationMinutes = (blockEndDate - blockStartDate) / (1000 * 60);
            const initialHeightPercent = (durationMinutes / 60) * 100;

            // Store the ACTUAL CSS top value for reverting (may be pixels or percentage)
            const initialCssTop = blockEl.style.top;
            const initialCssHeight = blockEl.style.height;

            timeBlockResizeState = {
                blockEl,
                blockId,
                startDate: new Date(startDate),
                endDate: new Date(endDate),
                initialTop: initialTopPercent,
                initialHeight: initialHeightPercent,
                initialCssTop: initialCssTop,
                initialCssHeight: initialCssHeight,
                startY: e.clientY,
                edge: edge // 'top' or 'bottom'
            };

            blockEl.classList.add('resizing');
            document.addEventListener('mousemove', handleTimeBlockResize);
            document.addEventListener('mouseup', endTimeBlockResize);
        }

        function handleTimeBlockResize(e) {
            if (!timeBlockResizeState) return;

            const { blockEl, blockId, startY, initialHeight, initialTop, edge } = timeBlockResizeState;
            const hourContent = blockEl.parentElement;
            const baseHour = parseInt(hourContent.dataset.hour);
            const hourHeight = 60; // pixels per hour
            const calDate = new Date(currentCalendarDate);

            // Get the calendar container for absolute positioning reference
            const hourlyGrid = document.getElementById('hourly-grid');
            if (!hourlyGrid) return;
            const gridRect = hourlyGrid.getBoundingClientRect();
            const mouseY = e.clientY - gridRect.top;

            // Calculate which hour and minute the mouse is over (7am = hour 7 at top)
            const totalMinutesFromTop = (mouseY / hourHeight) * 60;
            const targetHour = 7 + Math.floor(totalMinutesFromTop / 60);
            const targetMinute = totalMinutesFromTop % 60;

            // Get snap points for the target hour and find closest
            const targetHourClamped = Math.max(7, Math.min(18, targetHour));
            const snapPoints = getValidSnapPoints(targetHourClamped);
            const snappedMinute = findClosestSnapPoint(snapPoints, targetMinute);

            // Calculate the snapped absolute time
            const snappedHour = targetHourClamped;
            const snappedTime = new Date(calDate.getFullYear(), calDate.getMonth(), calDate.getDate(), snappedHour, snappedMinute);

            // Get the block's current start/end times
            const block = timeBlocks.find(b => b.id === blockId);
            if (!block) return;

            const blockStart = new Date(block.start);
            const blockEnd = new Date(block.end);

            let newStartDate, newEndDate;

            if (edge === 'bottom') {
                // Bottom edge - keep start, change end
                newStartDate = blockStart;
                newEndDate = snappedTime;

                // Ensure minimum 30 minute duration
                const minEndTime = new Date(newStartDate.getTime() + 30 * 60 * 1000);
                if (newEndDate < minEndTime) {
                    newEndDate = minEndTime;
                }

                // Clamp to visible range (7pm max)
                const maxEnd = new Date(calDate.getFullYear(), calDate.getMonth(), calDate.getDate(), 19, 0);
                if (newEndDate > maxEnd) {
                    newEndDate = maxEnd;
                }
            } else {
                // Top edge - keep end, change start
                newEndDate = blockEnd;
                newStartDate = snappedTime;

                // Ensure minimum 30 minute duration
                const maxStartTime = new Date(newEndDate.getTime() - 30 * 60 * 1000);
                if (newStartDate > maxStartTime) {
                    newStartDate = maxStartTime;
                }

                // Clamp to visible range (7am min)
                const minStart = new Date(calDate.getFullYear(), calDate.getMonth(), calDate.getDate(), 7, 0);
                if (newStartDate < minStart) {
                    newStartDate = minStart;
                }
            }

            // Check for overlaps
            if (hasOverlappingItem(newStartDate, newEndDate, 'timeblock-' + blockId)) {
                return; // Don't update visual if would overlap
            }

            // Calculate visual position relative to the block's parent hour
            const newStartHour = newStartDate.getHours();
            const newStartMinute = newStartDate.getMinutes();
            const newEndHour = newEndDate.getHours();
            const newEndMinute = newEndDate.getMinutes();

            // Calculate top and height as percentage of the parent hour
            const topMinuteOffset = (newStartHour - baseHour) * 60 + newStartMinute;
            const durationMinutes = (newEndDate - newStartDate) / (60 * 1000);

            const topPercent = (topMinuteOffset / 60) * 100;
            const heightPercent = (durationMinutes / 60) * 100;

            blockEl.style.top = `${topPercent}%`;
            blockEl.style.height = `${heightPercent}%`;
        }

        async function endTimeBlockResize() {
            if (!timeBlockResizeState) return;

            const { blockEl, blockId, edge } = timeBlockResizeState;

            blockEl.classList.remove('resizing');

            // Calculate times from the current visual position
            const topPercent = parseFloat(blockEl.style.top) || 0;
            const heightPercent = parseFloat(blockEl.style.height) || 50;
            const hourContent = blockEl.parentElement;
            const baseHour = parseInt(hourContent.dataset.hour);
            const calDate = new Date(currentCalendarDate);

            // Calculate start time from top position (can be negative for previous hour)
            const startMinuteOffset = (topPercent / 100) * 60;
            const startTotalMinutes = baseHour * 60 + startMinuteOffset;
            const startHour = Math.floor(startTotalMinutes / 60);
            const startMinute = Math.round(startTotalMinutes % 60);

            // Calculate duration and end time
            const durationMinutes = (heightPercent / 100) * 60;

            const newStartDate = new Date(calDate.getFullYear(), calDate.getMonth(), calDate.getDate(), startHour, startMinute);
            const newEndDate = new Date(newStartDate.getTime() + durationMinutes * 60 * 1000);

            // Check for overlaps before saving
            if (hasOverlappingItem(newStartDate, newEndDate, 'timeblock-' + blockId)) {
                // Revert visual changes
                blockEl.style.top = timeBlockResizeState.initialCssTop;
                blockEl.style.height = timeBlockResizeState.initialCssHeight;
                document.removeEventListener('mousemove', handleTimeBlockResize);
                document.removeEventListener('mouseup', endTimeBlockResize);
                timeBlockResizeState = null;
                return;
            }

            const startTimeUTC = newStartDate.toISOString();
            const endTimeUTC = newEndDate.toISOString();

            // Update on server - always send both times since either edge can change across hours
            try {
                const response = await fetch(`/tasks/api/time-blocks/${blockId}/update/`, {
                    method: 'PATCH',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-CSRFToken': csrfToken
                    },
                    body: JSON.stringify({
                        start_time: startTimeUTC,
                        end_time: endTimeUTC
                    })
                });

                const data = await response.json();
                if (data.success) {
                    // Update local data
                    const block = timeBlocks.find(b => b.id === blockId);
                    if (block) {
                        block.start = data.time_block.start;
                        block.end = data.time_block.end;
                    }
                    // Re-render to move block to correct hour if needed
                    renderTimeBlocks();
                }
            } catch (error) {
                console.error('Error updating time block:', error);
            }

            document.removeEventListener('mousemove', handleTimeBlockResize);
            document.removeEventListener('mouseup', endTimeBlockResize);
            timeBlockResizeState = null;
        }

        // Delete a time block
        async function deleteTimeBlock(blockId) {
            try {
                const response = await fetch(`/tasks/api/time-blocks/${blockId}/delete/`, {
                    method: 'DELETE',
                    headers: {
                        'X-CSRFToken': csrfToken
                    }
                });

                const data = await response.json();
                if (data.success) {
                    // Remove from local array
                    timeBlocks = timeBlocks.filter(b => b.id !== blockId);
                    // Re-render
                    renderTimeBlocks();
                }
            } catch (error) {
                console.error('Error deleting time block:', error);
            }
        }

        // Edit time block modal
        let currentEditingTimeBlockId = null;
        const editTimeBlockModal = document.getElementById('edit-time-block-modal');
        const editTimeBlockNameInput = document.getElementById('edit-time-block-name-input');
        const editTimeBlockSave = document.getElementById('edit-time-block-save');
        const editTimeBlockCancel = document.getElementById('edit-time-block-cancel');

        function openEditTimeBlockModal(blockId) {
            const block = timeBlocks.find(b => b.id === blockId);
            if (!block) return;

            currentEditingTimeBlockId = blockId;
            editTimeBlockNameInput.value = block.name;
            editTimeBlockModal.classList.add('active');
            editTimeBlockNameInput.focus();
            editTimeBlockNameInput.select();
        }

        async function saveTimeBlockEdit() {
            const newName = editTimeBlockNameInput.value.trim();
            if (!newName || !currentEditingTimeBlockId) {
                editTimeBlockModal.classList.remove('active');
                currentEditingTimeBlockId = null;
                return;
            }

            try {
                const response = await fetch(`/tasks/api/time-blocks/${currentEditingTimeBlockId}/update/`, {
                    method: 'PATCH',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-CSRFToken': csrfToken
                    },
                    body: JSON.stringify({ name: newName })
                });

                const data = await response.json();
                if (data.success) {
                    // Update local data
                    const block = timeBlocks.find(b => b.id === currentEditingTimeBlockId);
                    if (block) {
                        block.name = data.time_block.name;
                    }
                    // Re-render to show updated name
                    renderTimeBlocks();
                } else {
                    alert(data.error || 'Failed to update time block');
                }
            } catch (error) {
                console.error('Error updating time block name:', error);
                alert('Failed to update time block');
            }

            editTimeBlockModal.classList.remove('active');
            currentEditingTimeBlockId = null;
        }

        if (editTimeBlockSave) {
            editTimeBlockSave.addEventListener('click', saveTimeBlockEdit);
        }

        if (editTimeBlockCancel) {
            editTimeBlockCancel.addEventListener('click', function() {
                editTimeBlockModal.classList.remove('active');
                currentEditingTimeBlockId = null;
            });
        }

        if (editTimeBlockNameInput) {
            editTimeBlockNameInput.addEventListener('keydown', function(e) {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    saveTimeBlockEdit();
                } else if (e.key === 'Escape') {
                    editTimeBlockModal.classList.remove('active');
                    currentEditingTimeBlockId = null;
                }
            });
        }

        // Time block context menu
        function showTimeBlockContextMenu(e, blockId) {
            closeContextMenu();

            const menuHtml = `
                <div class="task-context-menu-item" onclick="event.stopPropagation(); openEditTimeBlockModal(${blockId}); closeContextMenu();">
                    <i class="bi bi-pencil"></i>
                    Edit
                </div>
                <div class="task-context-menu-item" onclick="event.stopPropagation(); snapTimeBlockToEventAbove(${blockId}); closeContextMenu();">
                    <i class="bi bi-magnet"></i>
                    Snap to Item Above
                </div>
                <div class="task-context-menu-item" onclick="event.stopPropagation(); snapTimeBlockToItemBelow(${blockId}); closeContextMenu();">
                    <i class="bi bi-magnet"></i>
                    Snap to Item Below
                </div>
                <div class="task-context-menu-divider"></div>
                <div class="task-context-menu-item danger" onclick="event.stopPropagation(); deleteTimeBlock(${blockId}); closeContextMenu();">
                    <i class="bi bi-trash"></i>
                    Delete
                </div>
            `;

            const menu = document.createElement('div');
            menu.className = 'task-context-menu';
            menu.id = 'task-context-menu';
            menu.innerHTML = menuHtml;

            document.body.appendChild(menu);

            // Position the menu
            const menuRect = menu.getBoundingClientRect();
            let x = e.clientX;
            let y = e.clientY;

            if (x + menuRect.width > window.innerWidth) {
                x = window.innerWidth - menuRect.width - 10;
            }
            if (y + menuRect.height > window.innerHeight) {
                y = window.innerHeight - menuRect.height - 10;
            }

            menu.style.left = x + 'px';
            menu.style.top = y + 'px';

            setTimeout(() => {
                document.addEventListener('click', closeContextMenu);
                document.addEventListener('contextmenu', closeContextMenu);
            }, 0);
        }

        // Snap time block to any item directly above it (event, time block, or task)
        async function snapTimeBlockToEventAbove(blockId) {
            const block = timeBlocks.find(b => b.id === blockId);
            if (!block) return;

            const blockStart = new Date(block.start);
            const blockEnd = new Date(block.end);

            // Find the closest item (event, time block, or task) that ends before this block starts
            let closestItemEnd = null;
            let closestDistance = Infinity;

            const todayStart = new Date(currentCalendarDate);
            todayStart.setHours(0, 0, 0, 0);
            const todayEnd = new Date(todayStart.getTime() + 24 * 60 * 60 * 1000);

            // Check calendar events
            calendarEvents.forEach(event => {
                const eventEnd = new Date(event.end);
                if (eventEnd >= todayStart && eventEnd < todayEnd && eventEnd <= blockStart) {
                    const distance = blockStart - eventEnd;
                    if (distance < closestDistance) {
                        closestDistance = distance;
                        closestItemEnd = eventEnd;
                    }
                }
            });

            // Check other time blocks
            timeBlocks.forEach(otherBlock => {
                if (otherBlock.id === blockId) return; // Skip self
                const otherEnd = new Date(otherBlock.end);
                if (otherEnd >= todayStart && otherEnd < todayEnd && otherEnd <= blockStart) {
                    const distance = blockStart - otherEnd;
                    if (distance < closestDistance) {
                        closestDistance = distance;
                        closestItemEnd = otherEnd;
                    }
                }
            });

            // Check scheduled tasks
            Object.keys(taskSchedulesMap).forEach(taskId => {
                const schedules = taskSchedulesMap[taskId] || [];
                schedules.forEach(schedule => {
                    const scheduleEnd = new Date(schedule.end_time);
                    if (scheduleEnd >= todayStart && scheduleEnd < todayEnd && scheduleEnd <= blockStart) {
                        const distance = blockStart - scheduleEnd;
                        if (distance < closestDistance) {
                            closestDistance = distance;
                            closestItemEnd = scheduleEnd;
                        }
                    }
                });
            });

            if (!closestItemEnd) {
                alert('No item found above this time block.');
                return;
            }

            // Extend the start time upward to match the closest item's end time
            // Keep the original end time (extend, don't move)
            const newStart = new Date(closestItemEnd);

            // Update via backend - only update start_time, keep end_time the same
            try {
                const response = await fetch(`/tasks/api/time-blocks/${blockId}/update/`, {
                    method: 'PATCH',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-CSRFToken': csrfToken
                    },
                    body: JSON.stringify({
                        start_time: newStart.toISOString()
                    })
                });

                if (response.ok) {
                    const data = await response.json();
                    // Update local data
                    block.start = data.time_block.start;
                    block.end = data.time_block.end;
                    // Re-render
                    renderTimeBlocks();
                } else {
                    alert('Failed to update time block.');
                }
            } catch (error) {
                console.error('Error updating time block:', error);
                alert('Error updating time block.');
            }
        }

        // Snap time block to extend its end time to meet the item below it
        async function snapTimeBlockToItemBelow(blockId) {
            const block = timeBlocks.find(b => b.id === blockId);
            if (!block) return;

            const blockStart = new Date(block.start);
            const blockEnd = new Date(block.end);

            // Find the closest item (event, time block, or task) that starts after this block ends
            let closestItemStart = null;
            let closestDistance = Infinity;

            const todayStart = new Date(currentCalendarDate);
            todayStart.setHours(0, 0, 0, 0);
            const todayEnd = new Date(todayStart.getTime() + 24 * 60 * 60 * 1000);

            // Check calendar events
            calendarEvents.forEach(event => {
                const eventStart = new Date(event.start);
                if (eventStart >= todayStart && eventStart < todayEnd && eventStart >= blockEnd) {
                    const distance = eventStart - blockEnd;
                    if (distance < closestDistance) {
                        closestDistance = distance;
                        closestItemStart = eventStart;
                    }
                }
            });

            // Check other time blocks
            timeBlocks.forEach(otherBlock => {
                if (otherBlock.id === blockId) return; // Skip self
                const otherStart = new Date(otherBlock.start);
                if (otherStart >= todayStart && otherStart < todayEnd && otherStart >= blockEnd) {
                    const distance = otherStart - blockEnd;
                    if (distance < closestDistance) {
                        closestDistance = distance;
                        closestItemStart = otherStart;
                    }
                }
            });

            // Check scheduled tasks
            Object.keys(taskSchedulesMap).forEach(taskId => {
                const schedules = taskSchedulesMap[taskId] || [];
                schedules.forEach(schedule => {
                    const scheduleStart = new Date(schedule.start_time);
                    if (scheduleStart >= todayStart && scheduleStart < todayEnd && scheduleStart >= blockEnd) {
                        const distance = scheduleStart - blockEnd;
                        if (distance < closestDistance) {
                            closestDistance = distance;
                            closestItemStart = scheduleStart;
                        }
                    }
                });
            });

            if (!closestItemStart) {
                alert('No item found below this time block.');
                return;
            }

            // Keep the start time, extend the end time to match the closest item's start
            const newEnd = new Date(closestItemStart);

            // Update via backend
            try {
                const response = await fetch(`/tasks/api/time-blocks/${blockId}/update/`, {
                    method: 'PATCH',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-CSRFToken': csrfToken
                    },
                    body: JSON.stringify({
                        end_time: newEnd.toISOString()
                    })
                });

                if (response.ok) {
                    const data = await response.json();
                    // Update local data
                    block.end = data.time_block.end;
                    // Re-render
                    renderTimeBlocks();
                } else {
                    alert('Failed to update time block.');
                }
            } catch (error) {
                console.error('Error updating time block:', error);
                alert('Error updating time block.');
            }
        }

        // Scheduled task context menu (for tasks on the calendar)
        function showScheduledTaskContextMenu(e, taskId, scheduleId) {
            closeContextMenu();
            contextMenuTaskId = taskId;
            pendingTagChanges = { toAdd: [], toRemove: [] };  // Reset pending changes

            // Get task info
            let card = document.querySelector(`.task-card[data-task-id="${taskId}"]`);
            const isCritical = card ? card.classList.contains('critical') : false;
            const taskTags = taskTagsMap[taskId] || [];
            const terminalStateId = getTerminalStateId();
            const taskData = taskDeadlinesMap[taskId];
            const isCompleted = taskData && taskData.state_id === terminalStateId;

            // Check if task is marked as "Done for Today" for the current calendar date
            const doneForDay = taskDoneForDayMap[taskId];
            const calendarDateStr = currentCalendarDate.toISOString().split('T')[0];
            const isDoneForToday = doneForDay === calendarDateStr;

            // Build menu HTML with all standard task options plus calendar-specific options
            let menuHtml = `
                <div class="task-context-menu-item" onclick="event.stopPropagation(); openTaskPanel(${taskId}); closeContextMenu();">
                    <i class="bi bi-pencil"></i>
                    Edit Task
                </div>
                <div class="task-context-menu-divider"></div>
                ${!isCompleted ? `
                <div class="task-context-menu-item" onclick="event.stopPropagation(); markTaskComplete(${taskId}); closeContextMenu();">
                    <i class="bi bi-check-circle"></i>
                    Mark Complete
                </div>
                ` : ''}
                <div class="task-context-menu-item" onclick="event.stopPropagation(); toggleTaskCritical(${taskId}); closeContextMenu();">
                    <i class="bi bi-exclamation-circle${isCritical ? '-fill' : ''}"></i>
                    ${isCritical ? 'Unmark Critical' : 'Mark Critical'}
                </div>
                <div class="task-context-menu-item" onclick="event.stopPropagation(); toggleDoneForToday(${taskId}); closeContextMenu();">
                    <i class="bi bi-bookmark-check${isDoneForToday ? '-fill' : ''}"></i>
                    ${isDoneForToday ? 'Unmark Done for Today' : 'Done for Today'}
                </div>
                <div class="task-context-menu-item" onclick="event.stopPropagation(); removeScheduleFromCalendar(${scheduleId}, ${taskId}); closeContextMenu();">
                    <i class="bi bi-calendar-x"></i>
                    Remove from Calendar
                </div>
                <div class="task-context-menu-divider"></div>
                <div class="task-context-menu-submenu">
                    <div class="task-context-menu-item">
                        <i class="bi bi-tags"></i>
                        Tags
                        <span class="submenu-arrow"><i class="bi bi-chevron-right"></i></span>
                    </div>
                    <div class="task-context-menu-submenu-content">
                        <div class="task-context-menu-item" onclick="event.stopPropagation(); promptNewTag(${taskId});">
                            <i class="bi bi-plus-circle"></i>
                            Create New Tag...
                        </div>
                        <div class="task-context-menu-divider"></div>
            `;

            // Show existing tags with checkmarks for assigned ones
            if (tagsList.length === 0) {
                menuHtml += `<div class="task-context-menu-item" style="color: #999; font-style: italic;">No tags yet</div>`;
            } else {
                tagsList.forEach(tag => {
                    const hasTag = taskTags.some(t => t.id === tag.id);
                    menuHtml += `
                        <div class="task-context-menu-item tag-toggle-item${hasTag ? ' active' : ''}" data-tag-id="${tag.id}" data-has-tag="${hasTag}" onclick="event.stopPropagation(); toggleTagLocally(this, ${tag.id})">
                            <i class="bi bi-${hasTag ? 'check-square-fill' : 'square'}"></i>
                            ${escapeHtml(tag.name)}
                        </div>
                    `;
                });
            }

            // Add "Remove all tags" option if task has tags
            if (taskTags.length > 0) {
                menuHtml += `
                        <div class="task-context-menu-divider"></div>
                        <div class="task-context-menu-item" onclick="event.stopPropagation(); removeAllTagsFromTask(${taskId});">
                            <i class="bi bi-x-circle" style="color: #dc3545;"></i>
                            <span style="color: #dc3545;">Remove all tags</span>
                        </div>
                `;
            }

            menuHtml += `
                        <div class="task-context-menu-divider"></div>
                        <div class="task-context-menu-item save-tags-btn" onclick="event.stopPropagation(); savePendingTags(${taskId});">
                            <i class="bi bi-check2"></i>
                            Save Tags
                        </div>
                    </div>
                </div>
                <div class="task-context-menu-divider"></div>
                <div class="task-context-menu-item" onclick="event.stopPropagation(); snapScheduledTaskToEventAbove(${taskId}, ${scheduleId}); closeContextMenu();">
                    <i class="bi bi-magnet"></i>
                    Snap to Item Above
                </div>
                <div class="task-context-menu-item" onclick="event.stopPropagation(); snapScheduledTaskToItemBelow(${taskId}, ${scheduleId}); closeContextMenu();">
                    <i class="bi bi-magnet"></i>
                    Snap to Item Below
                </div>
                <div class="task-context-menu-divider"></div>
                <div class="task-context-menu-item danger" onclick="event.stopPropagation(); deleteTaskFromMenu(${taskId}); closeContextMenu();">
                    <i class="bi bi-trash"></i>
                    Delete Task
                </div>
            `;

            const menu = document.createElement('div');
            menu.className = 'task-context-menu';
            menu.id = 'task-context-menu';
            menu.innerHTML = menuHtml;

            document.body.appendChild(menu);

            // Position the menu
            const menuRect = menu.getBoundingClientRect();
            let x = e.clientX;
            let y = e.clientY;

            if (x + menuRect.width > window.innerWidth) {
                x = window.innerWidth - menuRect.width - 10;
            }
            if (y + menuRect.height > window.innerHeight) {
                y = window.innerHeight - menuRect.height - 10;
            }

            menu.style.left = x + 'px';
            menu.style.top = y + 'px';

            setTimeout(() => {
                document.addEventListener('click', closeContextMenu);
                document.addEventListener('contextmenu', closeContextMenu);
            }, 0);
        }

        // Snap scheduled task to any item directly above it (event, time block, or other task)
        async function snapScheduledTaskToEventAbove(taskId, scheduleId) {
            // Find the schedule
            const schedules = taskSchedulesMap[taskId] || [];
            const schedule = schedules.find(s => s.id === scheduleId);
            if (!schedule) return;

            const scheduleStart = new Date(schedule.start_time);
            const scheduleEnd = new Date(schedule.end_time);

            // Find the closest item (event, time block, or task) that ends before this task starts
            let closestItemEnd = null;
            let closestDistance = Infinity;

            const todayStart = new Date(currentCalendarDate);
            todayStart.setHours(0, 0, 0, 0);
            const todayEnd = new Date(todayStart.getTime() + 24 * 60 * 60 * 1000);

            // Check calendar events
            calendarEvents.forEach(event => {
                const eventEnd = new Date(event.end);
                if (eventEnd >= todayStart && eventEnd < todayEnd && eventEnd <= scheduleStart) {
                    const distance = scheduleStart - eventEnd;
                    if (distance < closestDistance) {
                        closestDistance = distance;
                        closestItemEnd = eventEnd;
                    }
                }
            });

            // Check time blocks
            timeBlocks.forEach(block => {
                const blockEnd = new Date(block.end);
                if (blockEnd >= todayStart && blockEnd < todayEnd && blockEnd <= scheduleStart) {
                    const distance = scheduleStart - blockEnd;
                    if (distance < closestDistance) {
                        closestDistance = distance;
                        closestItemEnd = blockEnd;
                    }
                }
            });

            // Check other scheduled tasks
            Object.keys(taskSchedulesMap).forEach(otherTaskId => {
                const otherSchedules = taskSchedulesMap[otherTaskId] || [];
                otherSchedules.forEach(otherSchedule => {
                    if (otherSchedule.id === scheduleId) return; // Skip self
                    const otherEnd = new Date(otherSchedule.end_time);
                    if (otherEnd >= todayStart && otherEnd < todayEnd && otherEnd <= scheduleStart) {
                        const distance = scheduleStart - otherEnd;
                        if (distance < closestDistance) {
                            closestDistance = distance;
                            closestItemEnd = otherEnd;
                        }
                    }
                });
            });

            if (!closestItemEnd) {
                alert('No item found above this task.');
                return;
            }

            // Extend the start time upward to match the closest item's end time
            // Keep the original end time (extend, don't move)
            const newStart = new Date(closestItemEnd);

            // Update via backend - only update start_time, keep end_time the same
            try {
                const response = await fetch(`/tasks/api/schedules/${scheduleId}/update/`, {
                    method: 'PATCH',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-CSRFToken': csrfToken
                    },
                    body: JSON.stringify({
                        start_time: newStart.toISOString()
                    })
                });

                if (response.ok) {
                    const data = await response.json();
                    // Update local data
                    schedule.start_time = data.schedule.start_time;
                    schedule.end_time = data.schedule.end_time;
                    // Re-render
                    renderScheduledTasks();
                } else {
                    alert('Failed to update task schedule.');
                }
            } catch (error) {
                console.error('Error updating task schedule:', error);
                alert('Error updating task schedule.');
            }
        }

        // Snap scheduled task to extend its end time to meet the item below it
        async function snapScheduledTaskToItemBelow(taskId, scheduleId) {
            // Find the schedule
            const schedules = taskSchedulesMap[taskId] || [];
            const schedule = schedules.find(s => s.id === scheduleId);
            if (!schedule) return;

            const scheduleStart = new Date(schedule.start_time);
            const scheduleEnd = new Date(schedule.end_time);

            // Find the closest item (event, time block, or task) that starts after this task ends
            let closestItemStart = null;
            let closestDistance = Infinity;

            const todayStart = new Date(currentCalendarDate);
            todayStart.setHours(0, 0, 0, 0);
            const todayEnd = new Date(todayStart.getTime() + 24 * 60 * 60 * 1000);

            // Check calendar events
            calendarEvents.forEach(event => {
                const eventStart = new Date(event.start);
                if (eventStart >= todayStart && eventStart < todayEnd && eventStart >= scheduleEnd) {
                    const distance = eventStart - scheduleEnd;
                    if (distance < closestDistance) {
                        closestDistance = distance;
                        closestItemStart = eventStart;
                    }
                }
            });

            // Check time blocks
            timeBlocks.forEach(block => {
                const blockStart = new Date(block.start);
                if (blockStart >= todayStart && blockStart < todayEnd && blockStart >= scheduleEnd) {
                    const distance = blockStart - scheduleEnd;
                    if (distance < closestDistance) {
                        closestDistance = distance;
                        closestItemStart = blockStart;
                    }
                }
            });

            // Check other scheduled tasks
            Object.keys(taskSchedulesMap).forEach(otherTaskId => {
                const otherSchedules = taskSchedulesMap[otherTaskId] || [];
                otherSchedules.forEach(otherSchedule => {
                    if (otherSchedule.id === scheduleId) return; // Skip self
                    const otherStart = new Date(otherSchedule.start_time);
                    if (otherStart >= todayStart && otherStart < todayEnd && otherStart >= scheduleEnd) {
                        const distance = otherStart - scheduleEnd;
                        if (distance < closestDistance) {
                            closestDistance = distance;
                            closestItemStart = otherStart;
                        }
                    }
                });
            });

            if (!closestItemStart) {
                alert('No item found below this task.');
                return;
            }

            // Keep the start time, extend the end time to match the closest item's start
            const newEnd = new Date(closestItemStart);

            // Update via backend
            try {
                const response = await fetch(`/tasks/api/schedules/${scheduleId}/update/`, {
                    method: 'PATCH',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-CSRFToken': csrfToken
                    },
                    body: JSON.stringify({
                        end_time: newEnd.toISOString()
                    })
                });

                if (response.ok) {
                    const data = await response.json();
                    // Update local data
                    schedule.end_time = data.schedule.end_time;
                    // Re-render
                    renderScheduledTasks();
                } else {
                    alert('Failed to update task schedule.');
                }
            } catch (error) {
                console.error('Error updating task schedule:', error);
                alert('Error updating task schedule.');
            }
        }

        // ========== Block Time Modal ==========

        const addEventBtn = document.getElementById('add-event-btn');
        const addEventModal = document.getElementById('add-event-modal');
        const eventNameInput = document.getElementById('event-name-input');
        const timeSlotButtonsContainer = document.getElementById('time-slot-buttons');
        const addEventCancel = document.getElementById('add-event-cancel');
        const addEventOk = document.getElementById('add-event-ok');
        let selectedTimeSlotHour = null;  // Track selected hour

        // Get available hours (top of hour only, 7am-6pm, not occupied)
        function getAvailableTimeSlots() {
            // Use currentCalendarDate instead of today
            const viewDate = currentCalendarDate;
            const todayStart = new Date(viewDate.getFullYear(), viewDate.getMonth(), viewDate.getDate());
            const todayEnd = new Date(todayStart.getTime() + 24 * 60 * 60 * 1000);

            // Collect all occupied hour ranges for today
            const occupiedHours = new Set();

            // Check calendar events
            calendarEvents.forEach(event => {
                const startDate = new Date(event.start);
                const endDate = new Date(event.end);
                if (endDate <= todayStart || startDate >= todayEnd) return;
                // Mark all hours this event spans
                for (let h = Math.max(7, startDate.getHours()); h < Math.min(19, endDate.getHours() + (endDate.getMinutes() > 0 ? 1 : 0)); h++) {
                    occupiedHours.add(h);
                }
            });

            // Check time blocks
            timeBlocks.forEach(block => {
                const startDate = new Date(block.start);
                const endDate = new Date(block.end);
                if (endDate <= todayStart || startDate >= todayEnd) return;
                for (let h = Math.max(7, startDate.getHours()); h < Math.min(19, endDate.getHours() + (endDate.getMinutes() > 0 ? 1 : 0)); h++) {
                    occupiedHours.add(h);
                }
            });

            // Check scheduled tasks
            Object.entries(taskSchedulesMap).forEach(([taskId, schedules]) => {
                if (!schedules || schedules.length === 0) return;
                schedules.forEach(schedule => {
                    const startDate = new Date(schedule.start_time);
                    const endDate = new Date(schedule.end_time);
                    if (endDate <= todayStart || startDate >= todayEnd) return;
                    for (let h = Math.max(7, startDate.getHours()); h < Math.min(19, endDate.getHours() + (endDate.getMinutes() > 0 ? 1 : 0)); h++) {
                        occupiedHours.add(h);
                    }
                });
            });

            // Get available hours from 7am to 6pm
            const availableHours = [];
            for (let h = 7; h <= 18; h++) {
                if (!occupiedHours.has(h)) {
                    availableHours.push(h);
                }
            }

            // Select up to 5 slots spread across morning and afternoon
            const morningHours = availableHours.filter(h => h < 12);
            const afternoonHours = availableHours.filter(h => h >= 12);

            const selectedSlots = [];
            // Try to get a balanced mix
            if (availableHours.length <= 5) {
                return availableHours;
            }

            // Pick from morning (up to 2-3) and afternoon (up to 2-3)
            const morningCount = Math.min(Math.ceil(morningHours.length / 2), 3);
            const afternoonCount = Math.min(5 - morningCount, afternoonHours.length);

            // Spread morning picks
            if (morningHours.length > 0 && morningCount > 0) {
                const step = Math.max(1, Math.floor(morningHours.length / morningCount));
                for (let i = 0; i < morningCount && i * step < morningHours.length; i++) {
                    selectedSlots.push(morningHours[i * step]);
                }
            }

            // Spread afternoon picks
            if (afternoonHours.length > 0 && afternoonCount > 0) {
                const step = Math.max(1, Math.floor(afternoonHours.length / afternoonCount));
                for (let i = 0; i < afternoonCount && i * step < afternoonHours.length; i++) {
                    selectedSlots.push(afternoonHours[i * step]);
                }
            }

            // If we still need more, fill from remaining
            while (selectedSlots.length < 5 && selectedSlots.length < availableHours.length) {
                for (const h of availableHours) {
                    if (!selectedSlots.includes(h)) {
                        selectedSlots.push(h);
                        if (selectedSlots.length >= 5) break;
                    }
                }
            }

            return selectedSlots.sort((a, b) => a - b);
        }

        function formatHour(hour) {
            if (hour === 0) return '12am';
            if (hour === 12) return '12pm';
            if (hour < 12) return `${hour}am`;
            return `${hour - 12}pm`;
        }

        function populateTimeSlotButtons() {
            const slots = getAvailableTimeSlots();
            timeSlotButtonsContainer.innerHTML = '';
            selectedTimeSlotHour = null;
            updateOkButtonState();

            if (slots.length === 0) {
                timeSlotButtonsContainer.innerHTML = '<span style="color: #999; font-size: 0.8rem;">No available time slots</span>';
                return;
            }

            slots.forEach(hour => {
                const btn = document.createElement('button');
                btn.type = 'button';
                btn.className = 'time-slot-btn';
                btn.textContent = formatHour(hour);
                btn.dataset.hour = hour;
                btn.addEventListener('click', () => selectTimeSlot(hour, btn));
                timeSlotButtonsContainer.appendChild(btn);
            });
        }

        function selectTimeSlot(hour, btn) {
            // Remove selection from all buttons
            timeSlotButtonsContainer.querySelectorAll('.time-slot-btn').forEach(b => {
                b.classList.remove('selected');
            });
            // Select this one
            btn.classList.add('selected');
            selectedTimeSlotHour = hour;
            updateOkButtonState();
        }

        function updateOkButtonState() {
            if (addEventOk) {
                addEventOk.disabled = (selectedTimeSlotHour === null);
            }
        }

        async function createTimeBlockAtHour(hour) {
            const name = eventNameInput.value.trim();

            if (!name) {
                eventNameInput.focus();
                return;
            }

            // Create start time using currentCalendarDate (the day being viewed)
            const calDate = new Date(currentCalendarDate);
            const startLocal = new Date(calDate.getFullYear(), calDate.getMonth(), calDate.getDate(), hour, 0);
            const startUTC = startLocal.toISOString();

            // Find the gap at this time to determine end time
            const gap = findGapAtTime(startLocal);
            let endUTC;
            if (gap && gap.end) {
                endUTC = gap.end.toISOString();
            } else {
                // Fallback: 30 minutes if no gap found
                const endLocal = new Date(startLocal.getTime() + 30 * 60 * 1000);
                endUTC = endLocal.toISOString();
            }

            try {
                const response = await fetch('/tasks/api/time-blocks/create/', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-CSRFToken': csrfToken
                    },
                    body: JSON.stringify({
                        name: name,
                        start_time: startUTC,
                        end_time: endUTC
                    })
                });

                const data = await response.json();
                if (data.success) {
                    // Add to local array
                    timeBlocks.push(data.time_block);
                    // Re-render
                    renderTimeBlocks();
                    // Close modal
                    addEventModal.classList.remove('active');
                } else {
                    alert(data.error || 'Failed to create event');
                }
            } catch (error) {
                console.error('Error creating time block:', error);
                alert('Failed to create event');
            }
        }

        if (addEventBtn) {
            addEventBtn.addEventListener('click', function(e) {
                e.stopPropagation();
                eventNameInput.value = '';
                populateTimeSlotButtons();
                addEventModal.classList.add('active');
                eventNameInput.focus();
            });
        }

        if (addEventCancel) {
            addEventCancel.addEventListener('click', function() {
                addEventModal.classList.remove('active');
            });
        }

        if (addEventOk) {
            addEventOk.addEventListener('click', function() {
                if (selectedTimeSlotHour !== null) {
                    createTimeBlockAtHour(selectedTimeSlotHour);
                }
            });
        }

        if (addEventModal) {
            addEventModal.addEventListener('click', function(e) {
                if (e.target === addEventModal) {
                    addEventModal.classList.remove('active');
                }
            });
        }

        // ========== Scheduled Tasks on Calendar ==========

        // Render scheduled tasks on the calendar
        function renderScheduledTasks() {
            // Remove existing scheduled task elements
            document.querySelectorAll('.calendar-scheduled-task').forEach(el => el.remove());

            // Get current calendar date boundaries in local timezone
            const todayStart = new Date(currentCalendarDate);
            const todayEnd = new Date(todayStart.getTime() + 24 * 60 * 60 * 1000);

            // Iterate through all tasks and their schedules
            Object.entries(taskSchedulesMap).forEach(([taskId, schedules]) => {
                if (!schedules || schedules.length === 0) return;

                // Check each schedule for this task
                schedules.forEach(schedule => {
                    const startDate = new Date(schedule.start_time);

                    // Skip schedules not for current calendar date
                    if (startDate < todayStart || startDate >= todayEnd) return;

                    const hour = startDate.getHours();
                    const minute = startDate.getMinutes();

                    // Skip if outside visible range (7am-6pm)
                    if (hour < 7 || hour > 18) return;

                    const hourContent = document.querySelector(`.hour-content[data-hour="${hour}"]`);
                    if (!hourContent) return;

                    // Get task info from the task card
                    const taskCard = document.querySelector(`.task-card[data-task-id="${taskId}"]`);
                    if (!taskCard) return;

                    const titleEl = taskCard.querySelector('.task-card-title');
                    const title = titleEl ? titleEl.textContent : 'Task';

                    // Calculate duration in minutes
                    const endDate = new Date(schedule.end_time);
                    const durationMinutes = Math.max(15, (endDate - startDate) / (1000 * 60));

                    // Check if task is in terminal (completed) state
                    const terminalStateId = getTerminalStateId();
                    const taskDeadlineData = taskDeadlinesMap[taskId];
                    const isCompleted = taskDeadlineData && taskDeadlineData.state_id === terminalStateId;

                    // Format time range for tooltip (e.g., "4pm to 5pm (60 mins)")
                    const formatTooltipTime = (date) => {
                        let hours = date.getHours();
                        const ampm = hours >= 12 ? 'pm' : 'am';
                        hours = hours % 12 || 12;
                        const mins = date.getMinutes();
                        return mins === 0 ? `${hours}${ampm}` : `${hours}:${mins.toString().padStart(2, '0')}${ampm}`;
                    };
                    const timeRange = `${formatTooltipTime(startDate)} to ${formatTooltipTime(endDate)} (${Math.round(durationMinutes)} mins)`;

                    // Create scheduled task element
                    const taskEl = document.createElement('div');
                    taskEl.className = 'calendar-scheduled-task' + (isCompleted ? ' completed' : '');
                    taskEl.dataset.taskId = taskId;
                    taskEl.dataset.scheduleId = schedule.id;
                    taskEl.draggable = true;
                    taskEl.title = `${title}\n${timeRange}`;

                    // Create content wrapper
                    const contentWrapper = document.createElement('div');
                    contentWrapper.className = 'calendar-task-content';

                    // Add task icon
                    const taskIcon = document.createElement('i');
                    taskIcon.className = 'bi bi-check2-circle calendar-task-icon';
                    contentWrapper.appendChild(taskIcon);

                    // Add title text
                    const titleSpan = document.createElement('span');
                    titleSpan.className = 'calendar-task-title';
                    titleSpan.textContent = title;
                    contentWrapper.appendChild(titleSpan);

                    // Add "Done for Today" icon if task is marked done for current calendar date
                    const doneForDay = taskDoneForDayMap[taskId];
                    const calendarDateStr = currentCalendarDate.toISOString().split('T')[0];
                    if (doneForDay === calendarDateStr) {
                        const doneIcon = document.createElement('i');
                        doneIcon.className = 'bi bi-bookmark-check-fill calendar-done-for-day-icon';
                        doneIcon.title = 'Done for Today';
                        contentWrapper.appendChild(doneIcon);
                    }

                    taskEl.appendChild(contentWrapper);

                    // Add remove button (removes this specific schedule)
                    const removeBtn = document.createElement('button');
                    removeBtn.className = 'remove-btn';
                    removeBtn.innerHTML = '<i class="bi bi-x"></i>';
                    removeBtn.title = 'Remove from calendar';
                    removeBtn.addEventListener('click', async function(e) {
                        e.stopPropagation();
                        await removeScheduleFromCalendar(schedule.id, parseInt(taskId));
                    });
                    taskEl.appendChild(removeBtn);

                    // Add top resize handle
                    const resizeHandleTop = document.createElement('div');
                    resizeHandleTop.className = 'calendar-task-resize-handle-top';
                    resizeHandleTop.addEventListener('mousedown', function(e) {
                        e.stopPropagation();
                        e.preventDefault();
                        startTaskResize(e, taskEl, taskId, schedule.id, startDate, durationMinutes, 'top');
                    });
                    taskEl.appendChild(resizeHandleTop);

                    // Add bottom resize handle
                    const resizeHandle = document.createElement('div');
                    resizeHandle.className = 'calendar-task-resize-handle';
                    resizeHandle.addEventListener('mousedown', function(e) {
                        e.stopPropagation();
                        e.preventDefault();
                        startTaskResize(e, taskEl, taskId, schedule.id, startDate, durationMinutes, 'bottom');
                    });
                    taskEl.appendChild(resizeHandle);

                // Calculate height based on duration (each hour content is 100%)
                // Duration in minutes / 60 * 100 = percent of hour
                const heightPercent = (durationMinutes / 60) * 100;

                // Check if this scheduled task starts exactly when any calendar event ends
                // Events use heightPx - 4, so we need special pixel positioning to close the gap
                let adjustedTopPx = null;

                calendarEvents.forEach(event => {
                    const eventEnd = new Date(event.end);
                    if (Math.abs(eventEnd - startDate) < 1000) { // Within 1 second
                        // Found an adjacent event - calculate where it visually ends
                        const eventStart = new Date(event.start);
                        const eventStartHour = eventStart.getHours();
                        const eventStartMinute = eventStart.getMinutes();

                        // Event duration and visual height
                        const eventDurationMinutes = (eventEnd - eventStart) / (1000 * 60);
                        const eventHeightPx = (eventDurationMinutes / 60) * 60;

                        // Where the event starts in its hour (in pixels)
                        const eventTopPx = (eventStartMinute / 60) * 60;

                        // Where the event visually ends (in pixels from top of its start hour)
                        const eventVisualEndPx = eventTopPx + eventHeightPx;

                        // Calculate how many pixels into the current hour that is
                        const hoursDiff = hour - eventStartHour;
                        adjustedTopPx = eventVisualEndPx - (hoursDiff * 60);
                    }
                });

                // Also check for adjacent time blocks
                if (adjustedTopPx === null) {
                    timeBlocks.forEach(block => {
                        const blockEnd = new Date(block.end);
                        if (Math.abs(blockEnd - startDate) < 1000) { // Within 1 second
                            const blockStart = new Date(block.start);
                            const blockStartHour = blockStart.getHours();
                            const blockStartMinute = blockStart.getMinutes();

                            const blockDurationMinutes = (blockEnd - blockStart) / (1000 * 60);
                            const blockHeightPx = (blockDurationMinutes / 60) * 60;
                            const blockTopPx = (blockStartMinute / 60) * 60;
                            const blockVisualEndPx = blockTopPx + blockHeightPx;

                            const hoursDiff = hour - blockStartHour;
                            adjustedTopPx = blockVisualEndPx - (hoursDiff * 60);
                        }
                    });
                }

                // Also check for adjacent other scheduled tasks
                if (adjustedTopPx === null) {
                    Object.keys(taskSchedulesMap).forEach(otherTaskId => {
                        const otherSchedules = taskSchedulesMap[otherTaskId] || [];
                        otherSchedules.forEach(otherSchedule => {
                            if (otherSchedule.id === schedule.id) return; // Skip self
                            const otherEnd = new Date(otherSchedule.end_time);
                            if (Math.abs(otherEnd - startDate) < 1000) { // Within 1 second
                                const otherStart = new Date(otherSchedule.start_time);
                                const otherStartHour = otherStart.getHours();
                                const otherStartMinute = otherStart.getMinutes();

                                const otherDurationMinutes = (otherEnd - otherStart) / (1000 * 60);
                                const otherHeightPx = (otherDurationMinutes / 60) * 60;
                                const otherTopPx = (otherStartMinute / 60) * 60;
                                const otherVisualEndPx = otherTopPx + otherHeightPx;

                                const hoursDiff = hour - otherStartHour;
                                adjustedTopPx = otherVisualEndPx - (hoursDiff * 60);
                            }
                        });
                    });
                }

                if (adjustedTopPx !== null && adjustedTopPx >= -4 && adjustedTopPx < 60) {
                    // Position task exactly where adjacent item visually ends
                    // Allow small negative values (down to -4px) to close gaps
                    taskEl.style.top = `${adjustedTopPx}px`;
                    taskEl.style.height = `${heightPercent}%`;
                } else {
                    // Normal percentage-based positioning
                    const topPercent = (minute / 60) * 100;
                    taskEl.style.top = `${topPercent}%`;
                    taskEl.style.height = `${heightPercent}%`;
                }

                // Setup drag events for scheduled task
                setupScheduledTaskDragEvents(taskEl);

                // Right-click context menu for calendar tasks
                taskEl.addEventListener('contextmenu', function(e) {
                    e.preventDefault();
                    e.stopPropagation();
                    showScheduledTaskContextMenu(e, parseInt(this.dataset.taskId), parseInt(this.dataset.scheduleId));
                });

                // Double-click to open task panel
                taskEl.addEventListener('dblclick', function(e) {
                    e.preventDefault();
                    e.stopPropagation();
                    openTaskPanel(parseInt(this.dataset.taskId));
                });

                hourContent.appendChild(taskEl);
                });
            });

            // After all tasks are added, detect overlaps and adjust widths
            adjustOverlappingTasks();
        }

        // Detect overlapping tasks and adjust their widths to sit side by side
        function adjustOverlappingTasks() {
            // Get all hour contents
            document.querySelectorAll('.hour-content').forEach(hourContent => {
                const tasks = Array.from(hourContent.querySelectorAll('.calendar-scheduled-task'));
                if (tasks.length === 0) return;

                const containerHeight = hourContent.offsetHeight || 60;

                // Helper to convert CSS value to pixels
                function toPixels(value, containerSize) {
                    if (value.endsWith('%')) {
                        return (parseFloat(value) / 100) * containerSize;
                    }
                    return parseFloat(value) || 0;
                }

                // Build task info array with time ranges (all in pixels for accurate comparison)
                const taskInfos = tasks.map(taskEl => {
                    const topPx = toPixels(taskEl.style.top, containerHeight);
                    const heightPx = toPixels(taskEl.style.height, containerHeight);
                    const bottomPx = topPx + heightPx;
                    return {
                        element: taskEl,
                        top: topPx,
                        height: heightPx,
                        bottom: bottomPx,
                        originalTop: taskEl.style.top,  // Preserve original CSS value
                        column: 0  // Will be assigned based on overlap detection
                    };
                });

                // Sort by start time (top position)
                taskInfos.sort((a, b) => a.top - b.top);

                // Detect overlaps and assign columns (max 3)
                const columns = [];  // Array of arrays, each sub-array is a column

                taskInfos.forEach(taskInfo => {
                    // Find the first column where this task doesn't overlap with any existing task
                    let assignedColumn = -1;
                    for (let colIndex = 0; colIndex < 3; colIndex++) {
                        if (!columns[colIndex]) {
                            columns[colIndex] = [];
                        }

                        // Check if task overlaps with any task in this column
                        const overlaps = columns[colIndex].some(existing => {
                            return !(taskInfo.top >= existing.bottom || taskInfo.bottom <= existing.top);
                        });

                        if (!overlaps) {
                            assignedColumn = colIndex;
                            break;
                        }
                    }

                    // If we found a column (and didn't exceed max 3), assign it
                    if (assignedColumn !== -1) {
                        taskInfo.column = assignedColumn;
                        columns[assignedColumn].push(taskInfo);
                    } else {
                        // Max 3 columns reached, put in column 2 (last column)
                        taskInfo.column = 2;
                        columns[2].push(taskInfo);
                    }
                });

                // Calculate how many columns are actually used
                const numColumns = Math.min(3, columns.filter(col => col && col.length > 0).length);

                // For each task, determine the max number of overlapping tasks at its time
                taskInfos.forEach(taskInfo => {
                    // Skip tasks that are being dragged - preserve their width
                    if (taskInfo.element.classList.contains('dragging')) {
                        return;
                    }

                    // Find all tasks that overlap with this one (INCLUDE dragging tasks in count
                    // so sibling tasks don't expand when a task is picked up to drag)
                    const overlapping = taskInfos.filter(other => {
                        return !(taskInfo.top >= other.bottom || taskInfo.bottom <= other.top);
                    });

                    const overlapCount = Math.min(3, overlapping.length);
                    const columnIndex = taskInfo.column;

                    if (overlapCount > 1) {
                        // Align all overlapping tasks to the same top position (minimum among them)
                        // This ensures tasks at the same time appear at the same vertical position
                        const minTop = Math.min(...overlapping.map(t => t.top));
                        taskInfo.element.style.top = `${minTop}px`;

                        // Calculate width and left position
                        // We want: 4px left padding, 4px right padding, 4px gap between columns
                        // Total gaps between columns = (overlapCount - 1) * 4
                        // Available width for all columns = container - 8 (left/right padding) - gaps
                        const gap = 4;
                        const totalGaps = (overlapCount - 1) * gap;
                        const availableWidth = hourContent.offsetWidth - 8 - totalGaps;
                        const columnWidth = availableWidth / overlapCount;
                        const leftPosition = 4 + columnIndex * (columnWidth + gap);

                        taskInfo.element.style.left = `${leftPosition}px`;
                        taskInfo.element.style.width = `${columnWidth}px`;
                        taskInfo.element.style.right = 'auto';
                    } else {
                        // Single task, use full width
                        taskInfo.element.style.left = '4px';
                        taskInfo.element.style.right = '4px';
                        taskInfo.element.style.width = 'auto';
                    }
                });
            });
        }

        // Handle task resize by dragging top or bottom edge
        let resizeState = null;

        function startTaskResize(e, taskEl, taskId, scheduleId, startDate, durationMinutes, edge) {
            const hourContent = taskEl.closest('.hour-content');

            resizeState = {
                taskEl,
                taskId,
                scheduleId,
                startDate: new Date(startDate),
                initialTop: parseFloat(taskEl.style.top) || 0,
                initialHeight: parseFloat(taskEl.style.height) || 50,
                startY: e.clientY,
                edge: edge // 'top' or 'bottom'
            };

            document.addEventListener('mousemove', handleTaskResize);
            document.addEventListener('mouseup', endTaskResize);
            taskEl.classList.add('resizing');
        }

        function handleTaskResize(e) {
            if (!resizeState) return;

            const { taskEl, taskId, scheduleId, edge } = resizeState;
            const hourContent = taskEl.parentElement;
            const baseHour = parseInt(hourContent.dataset.hour);
            const hourHeight = 60; // pixels per hour
            const calDate = new Date(currentCalendarDate);

            // Get the calendar container for absolute positioning reference
            const hourlyGrid = document.getElementById('hourly-grid');
            if (!hourlyGrid) return;
            const gridRect = hourlyGrid.getBoundingClientRect();
            const mouseY = e.clientY - gridRect.top;

            // Calculate which hour and minute the mouse is over (7am = hour 7 at top)
            const totalMinutesFromTop = (mouseY / hourHeight) * 60;
            const targetHour = 7 + Math.floor(totalMinutesFromTop / 60);
            const targetMinute = totalMinutesFromTop % 60;

            // Get snap points for the target hour and find closest
            const targetHourClamped = Math.max(7, Math.min(18, targetHour));
            const snapPoints = getValidSnapPoints(targetHourClamped);
            const snappedMinute = findClosestSnapPoint(snapPoints, targetMinute);

            // Calculate the snapped absolute time
            const snappedHour = targetHourClamped;
            const snappedTime = new Date(calDate.getFullYear(), calDate.getMonth(), calDate.getDate(), snappedHour, snappedMinute);

            // Get the task's current schedule
            const schedules = taskSchedulesMap[taskId] || [];
            const schedule = schedules.find(s => s.id === parseInt(scheduleId));
            if (!schedule) return;

            const scheduleStart = new Date(schedule.start_time);
            const scheduleEnd = new Date(schedule.end_time);

            let newStartDate, newEndDate;

            if (edge === 'bottom') {
                // Bottom edge - keep start, change end
                newStartDate = scheduleStart;
                newEndDate = snappedTime;

                // Ensure minimum 30 minute duration
                const minEndTime = new Date(newStartDate.getTime() + 30 * 60 * 1000);
                if (newEndDate < minEndTime) {
                    newEndDate = minEndTime;
                }

                // Clamp to visible range (7pm max)
                const maxEnd = new Date(calDate.getFullYear(), calDate.getMonth(), calDate.getDate(), 19, 0);
                if (newEndDate > maxEnd) {
                    newEndDate = maxEnd;
                }
            } else {
                // Top edge - keep end, change start
                newEndDate = scheduleEnd;
                newStartDate = snappedTime;

                // Ensure minimum 30 minute duration
                const maxStartTime = new Date(newEndDate.getTime() - 30 * 60 * 1000);
                if (newStartDate > maxStartTime) {
                    newStartDate = maxStartTime;
                }

                // Clamp to visible range (7am min)
                const minStart = new Date(calDate.getFullYear(), calDate.getMonth(), calDate.getDate(), 7, 0);
                if (newStartDate < minStart) {
                    newStartDate = minStart;
                }
            }

            // Calculate visual position relative to the task's parent hour
            const newStartHour = newStartDate.getHours();
            const newStartMinute = newStartDate.getMinutes();

            // Calculate top and height as percentage of the parent hour
            const topMinuteOffset = (newStartHour - baseHour) * 60 + newStartMinute;
            const durationMinutes = (newEndDate - newStartDate) / (60 * 1000);

            const topPercent = (topMinuteOffset / 60) * 100;
            const heightPercent = (durationMinutes / 60) * 100;

            taskEl.style.top = `${topPercent}%`;
            taskEl.style.height = `${heightPercent}%`;
        }

        async function endTaskResize() {
            if (!resizeState) return;

            const { taskEl, taskId, scheduleId, edge } = resizeState;

            taskEl.classList.remove('resizing');

            // Calculate times from the current visual position
            const topPercent = parseFloat(taskEl.style.top) || 0;
            const heightPercent = parseFloat(taskEl.style.height) || 50;
            const hourContent = taskEl.parentElement;
            const baseHour = parseInt(hourContent.dataset.hour);
            const calDate = new Date(currentCalendarDate);

            // Calculate start time from top position (can span multiple hours)
            const startMinuteOffset = (topPercent / 100) * 60;
            const startTotalMinutes = baseHour * 60 + startMinuteOffset;
            const startHour = Math.floor(startTotalMinutes / 60);
            const startMinute = Math.round(startTotalMinutes % 60);

            // Calculate duration and end time
            const durationMinutes = (heightPercent / 100) * 60;

            const newStartDate = new Date(calDate.getFullYear(), calDate.getMonth(), calDate.getDate(), startHour, startMinute);
            const newEndDate = new Date(newStartDate.getTime() + durationMinutes * 60 * 1000);

            const startTimeUTC = localToUTC(newStartDate);
            const endTimeUTC = localToUTC(newEndDate);

            // Update on server - always send both times since resize can span hours
            await updateScheduleById(scheduleId, taskId, startTimeUTC, endTimeUTC);

            document.removeEventListener('mousemove', handleTaskResize);
            document.removeEventListener('mouseup', endTaskResize);
            resizeState = null;

            // Adjust overlapping tasks after resize
            adjustOverlappingTasks();
        }

        // Setup drag events for scheduled tasks on the calendar
        function setupScheduledTaskDragEvents(taskEl) {
            // Capture dimensions on mousedown (before drag starts) to prevent expansion
            taskEl.addEventListener('mousedown', function(e) {
                // Don't interfere with resize handles
                if (e.target.classList.contains('calendar-task-resize-handle') ||
                    e.target.classList.contains('calendar-task-resize-handle-top') ||
                    e.target.classList.contains('remove-btn') ||
                    e.target.closest('.remove-btn')) {
                    return;
                }

                // Get computed dimensions and store them as CSS variables
                const computedStyle = window.getComputedStyle(this);
                const currentWidth = computedStyle.width;
                const currentLeft = computedStyle.left;

                // Store as CSS variables for use by .dragging class
                this.style.setProperty('--drag-width', currentWidth);
                this.style.setProperty('--drag-left', currentLeft);
            });

            taskEl.addEventListener('dragstart', function(e) {
                this.classList.add('dragging');
                currentDragTaskId = this.dataset.taskId;
                e.dataTransfer.effectAllowed = 'move';
                e.dataTransfer.setData('text/plain', this.dataset.taskId);
                e.dataTransfer.setData('application/x-scheduled-task', 'true');
            });

            taskEl.addEventListener('dragend', function() {
                this.classList.remove('dragging');
                currentDragTaskId = null;

                // Clean up CSS variables used for dimension locking
                this.style.removeProperty('--drag-width');
                this.style.removeProperty('--drag-left');

                document.querySelectorAll('.hour-content.drag-over').forEach(el => {
                    el.classList.remove('drag-over', 'drag-top', 'drag-bottom', 'drag-blocked');
                    el.style.removeProperty('--preview-height');
                });
            });

            // Clean up CSS variables if user clicks without dragging
            taskEl.addEventListener('mouseup', function() {
                if (!this.classList.contains('dragging')) {
                    this.style.removeProperty('--drag-width');
                    this.style.removeProperty('--drag-left');
                }
            });
        }

        // Track dragged time block
        let currentDragTimeBlockId = null;

        function setupTimeBlockDragEvents(blockEl) {
            // Capture dimensions on mousedown (before drag starts) to prevent expansion
            blockEl.addEventListener('mousedown', function(e) {
                // Don't interfere with resize handles
                if (e.target.classList.contains('time-block-resize-handle') ||
                    e.target.classList.contains('time-block-resize-handle-top') ||
                    e.target.classList.contains('remove-btn') ||
                    e.target.closest('.remove-btn')) {
                    return;
                }

                // Get computed dimensions and store them as CSS variables
                const computedStyle = window.getComputedStyle(this);
                const currentWidth = computedStyle.width;
                const currentLeft = computedStyle.left;

                // Store as CSS variables for use by .dragging class
                this.style.setProperty('--drag-width', currentWidth);
                this.style.setProperty('--drag-left', currentLeft);
            });

            blockEl.addEventListener('dragstart', function(e) {
                this.classList.add('dragging');
                currentDragTimeBlockId = this.dataset.blockId;
                e.dataTransfer.effectAllowed = 'move';
                e.dataTransfer.setData('text/plain', this.dataset.blockId);
                e.dataTransfer.setData('application/x-time-block', 'true');
            });

            blockEl.addEventListener('dragend', function() {
                this.classList.remove('dragging');
                currentDragTimeBlockId = null;

                // Clean up CSS variables used for dimension locking
                this.style.removeProperty('--drag-width');
                this.style.removeProperty('--drag-left');

                document.querySelectorAll('.hour-content.drag-over').forEach(el => {
                    el.classList.remove('drag-over', 'drag-top', 'drag-bottom', 'drag-blocked');
                    el.style.removeProperty('--preview-height');
                });
            });

            // Clean up CSS variables if user clicks without dragging
            blockEl.addEventListener('mouseup', function() {
                if (!this.classList.contains('dragging')) {
                    this.style.removeProperty('--drag-width');
                    this.style.removeProperty('--drag-left');
                }
            });
        }

        // Update a time block's times on the server
        async function updateTimeBlockTime(blockId, startTimeUTC, endTimeUTC) {
            try {
                const response = await fetch(`/tasks/api/time-blocks/${blockId}/update/`, {
                    method: 'PATCH',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-CSRFToken': csrfToken
                    },
                    body: JSON.stringify({
                        start_time: startTimeUTC,
                        end_time: endTimeUTC
                    })
                });

                const data = await response.json();
                if (data.success) {
                    // Update local timeBlocks array
                    const block = timeBlocks.find(b => b.id === parseInt(blockId));
                    if (block) {
                        block.start = startTimeUTC;
                        block.end = endTimeUTC;
                    }
                    return true;
                }
                return false;
            } catch (error) {
                console.error('Error updating time block:', error);
                return false;
            }
        }

        // Convert local datetime to UTC ISO string
        function localToUTC(localDate) {
            return localDate.toISOString();
        }

        // Create a new TaskSchedule entry for a task
        async function createTaskSchedule(taskId, startTimeUTC, endTimeUTC) {
            try {
                const response = await fetch(`/tasks/api/${taskId}/schedules/create/`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-CSRFToken': csrfToken
                    },
                    body: JSON.stringify({
                        start_time: startTimeUTC,
                        end_time: endTimeUTC
                    })
                });

                const data = await response.json();
                if (data.success) {
                    // Update local taskSchedulesMap from response
                    if (data.task && data.task.schedules) {
                        taskSchedulesMap[taskId] = data.task.schedules;
                    }

                    // Update task card scheduled class
                    updateTaskScheduledClass(taskId);

                    return true;
                }
            } catch (error) {
                console.error('Error creating task schedule:', error);
            }
            return false;
        }

        // Update a specific schedule by its ID
        async function updateScheduleById(scheduleId, taskId, startTimeUTC, endTimeUTC) {
            try {
                const body = {};
                if (startTimeUTC) {
                    body.start_time = startTimeUTC;
                }
                if (endTimeUTC) {
                    body.end_time = endTimeUTC;
                }

                const response = await fetch(`/tasks/api/schedules/${scheduleId}/update/`, {
                    method: 'PATCH',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-CSRFToken': csrfToken
                    },
                    body: JSON.stringify(body)
                });

                const data = await response.json();
                if (data.success) {
                    // Update local taskSchedulesMap from response
                    if (data.task && data.task.schedules) {
                        taskSchedulesMap[taskId] = data.task.schedules;
                    }

                    // Update task card scheduled class
                    updateTaskScheduledClass(taskId);

                    return true;
                }
            } catch (error) {
                console.error('Error updating schedule:', error);
            }
            return false;
        }

        // Remove a specific schedule from calendar (delete one schedule)
        async function removeScheduleFromCalendar(scheduleId, taskId) {
            try {
                const response = await fetch(`/tasks/api/schedules/${scheduleId}/delete/`, {
                    method: 'DELETE',
                    headers: {
                        'X-CSRFToken': csrfToken
                    }
                });

                const data = await response.json();
                if (data.success) {
                    // Update local taskSchedulesMap - remove this schedule
                    if (taskSchedulesMap[taskId]) {
                        taskSchedulesMap[taskId] = taskSchedulesMap[taskId].filter(s => s.id !== scheduleId);
                    }

                    // Update task card scheduled class
                    updateTaskScheduledClass(taskId);

                    renderScheduledTasks();
                    initializeScheduledIcons();
                }
            } catch (error) {
                console.error('Error removing schedule from calendar:', error);
            }
        }

        // Show confirmation before removing task from calendar
        async function confirmRemoveFromCalendar(taskId) {
            const schedules = taskSchedulesMap[taskId] || [];
            if (schedules.length === 0) return;

            const confirmed = await showConfirmModal(
                'This will remove the task from all scheduled days on your calendar.',
                'Remove from Calendar',
                'Remove'
            );

            if (confirmed) {
                await unscheduleAllDates(taskId);
            }
        }

        // Remove all schedules for a task (unschedule from all future days)
        async function unscheduleAllDates(taskId) {
            const schedules = taskSchedulesMap[taskId] || [];
            if (schedules.length === 0) return;

            try {
                // Delete all schedules
                const deletePromises = schedules.map(schedule =>
                    fetch(`/tasks/api/schedules/${schedule.id}/delete/`, {
                        method: 'DELETE',
                        headers: {
                            'X-CSRFToken': csrfToken
                        }
                    })
                );

                await Promise.all(deletePromises);

                // Clear local taskSchedulesMap
                taskSchedulesMap[taskId] = [];

                // Update task card scheduled class
                updateTaskScheduledClass(taskId);

                // Update panel if open
                if (currentTaskId === taskId) {
                    renderPanelScheduledDates(taskId);
                }

                renderScheduledTasks();
                initializeScheduledIcons();
            } catch (error) {
                console.error('Error unscheduling all dates:', error);
            }
        }

        // Update the scheduled class and pill on a task card
        function updateTaskScheduledClass(taskId) {
            const cards = document.querySelectorAll(`.task-card[data-task-id="${taskId}"]`);
            const schedules = taskSchedulesMap[taskId] || [];
            const scheduleLabel = getScheduleLabel(schedules);
            const isScheduled = scheduleLabel !== null;

            cards.forEach(card => {
                card.classList.toggle('scheduled', isScheduled);

                // Skip adding schedule pills to Schedules view cards (they don't show schedule pills)
                const isInSchedulesView = card.closest('#schedules-content') !== null;
                if (isInSchedulesView) return;

                // Remove existing schedule pill
                let schedulePill = card.querySelector('.task-schedule-pill');
                if (schedulePill) {
                    schedulePill.remove();
                }

                // Add new schedule pill if needed
                if (isScheduled) {
                    const content = card.querySelector('.task-card-content');
                    if (content) {
                        let iconsContainer = content.querySelector('.task-card-icons');
                        if (!iconsContainer) {
                            iconsContainer = document.createElement('div');
                            iconsContainer.className = 'task-card-icons';
                            content.appendChild(iconsContainer);
                        }
                        // Create and insert schedule pill at the start
                        const pill = document.createElement('span');
                        pill.className = `task-schedule-pill ${scheduleLabel}`;
                        pill.textContent = scheduleLabel.charAt(0).toUpperCase() + scheduleLabel.slice(1);
                        iconsContainer.insertBefore(pill, iconsContainer.firstChild);
                    }
                } else {
                    // Remove icons container if empty
                    const iconsContainer = card.querySelector('.task-card-icons');
                    if (iconsContainer && iconsContainer.children.length === 0) {
                        iconsContainer.remove();
                    }
                }
            });
        }

        // Remove all schedules for a task from the calendar (via context menu)
        async function removeFromCalendar(taskId) {
            closeContextMenu();

            try {
                const response = await fetch(`/tasks/api/${taskId}/schedules/delete/`, {
                    method: 'DELETE',
                    headers: {
                        'X-CSRFToken': csrfToken
                    }
                });

                const data = await response.json();
                if (data.success) {
                    // Clear local schedules
                    taskSchedulesMap[taskId] = [];

                    // Update task card scheduled class
                    updateTaskScheduledClass(taskId);

                    renderScheduledTasks();
                    initializeScheduledIcons();
                }
            } catch (error) {
                console.error('Error removing task from calendar:', error);
            }
        }

        // Check if there's an overlapping calendar event or time block (but NOT tasks)
        function hasEventOrTimeBlockOverlap(newStart, newEnd) {
            // Check calendar events (use override times if present)
            if (calendarEvents && calendarEvents.length > 0) {
                for (const event of calendarEvents) {
                    if (event.is_all_day) continue;

                    const eventStart = event.override_start ? new Date(event.override_start) : new Date(event.start);
                    const eventEnd = event.override_end ? new Date(event.override_end) : new Date(event.end);

                    // Check for overlap
                    if (newStart < eventEnd && newEnd > eventStart) {
                        return true;
                    }
                }
            }

            // Check time blocks
            if (timeBlocks && timeBlocks.length > 0) {
                for (const block of timeBlocks) {
                    const blockStart = new Date(block.start);
                    const blockEnd = new Date(block.end);

                    // Check for overlap
                    if (newStart < blockEnd && newEnd > blockStart) {
                        return true;
                    }
                }
            }

            return false;
        }

        // Check if there's an overlapping task or event at the given time
        function hasOverlappingItem(newStart, newEnd, excludeTaskId, excludeScheduleId = null) {
            // Check existing scheduled tasks
            for (const [taskId, schedules] of Object.entries(taskSchedulesMap)) {
                if (!schedules || schedules.length === 0) continue;
                if (taskId === excludeTaskId || taskId === String(excludeTaskId)) continue;

                for (const schedule of schedules) {
                    // Skip the schedule being moved/resized
                    if (excludeScheduleId && schedule.id === excludeScheduleId) continue;

                    const taskStart = new Date(schedule.start_time);
                    const taskEnd = new Date(schedule.end_time);

                    // Check for overlap: (newStart < taskEnd) && (newEnd > taskStart)
                    if (newStart < taskEnd && newEnd > taskStart) {
                        return true;
                    }
                }
            }

            // Check calendar events
            if (calendarEvents && calendarEvents.length > 0) {
                for (const event of calendarEvents) {
                    if (event.is_all_day) continue;

                    const eventStart = new Date(event.start);
                    const eventEnd = new Date(event.end);

                    // Check for overlap
                    if (newStart < eventEnd && newEnd > eventStart) {
                        return true;
                    }
                }
            } else {
            }

            // Check time blocks
            if (timeBlocks && timeBlocks.length > 0) {
                for (const block of timeBlocks) {
                    // Skip if this is the time block being moved
                    if (excludeTaskId === 'timeblock-' + block.id) continue;

                    const blockStart = new Date(block.start);
                    const blockEnd = new Date(block.end);

                    // Check for overlap
                    if (newStart < blockEnd && newEnd > blockStart) {
                        return true;
                    }
                }
            }

            return false;
        }

        // Count how many tasks overlap with the given time range (excluding excludeTaskId)
        function countOverlappingTasks(newStart, newEnd, excludeTaskId, excludeScheduleId = null) {
            let count = 0;

            // Check existing scheduled tasks
            for (const [taskId, schedules] of Object.entries(taskSchedulesMap)) {
                if (!schedules || schedules.length === 0) continue;
                if (taskId === excludeTaskId || taskId === String(excludeTaskId)) continue;

                for (const schedule of schedules) {
                    // Skip the schedule being moved/resized
                    if (excludeScheduleId && schedule.id === excludeScheduleId) continue;

                    const taskStart = new Date(schedule.start_time);
                    const taskEnd = new Date(schedule.end_time);

                    // Check for overlap: (newStart < taskEnd) && (newEnd > taskStart)
                    if (newStart < taskEnd && newEnd > taskStart) {
                        count++;
                    }
                }
            }

            return count;
        }

        // Find valid snap points for a given hour (includes :00, :30, and event end times)
        function getValidSnapPoints(hour) {
            const snapPoints = [0, 30]; // Always include :00 and :30

            // Find events that end in this hour at non-standard times
            const todayStart = new Date(currentCalendarDate);
            todayStart.setHours(0, 0, 0, 0);
            const todayEnd = new Date(todayStart.getTime() + 24 * 60 * 60 * 1000);

            calendarEvents.forEach(event => {
                const endDate = new Date(event.end);
                const endHour = endDate.getHours();
                const endMinute = endDate.getMinutes();
                const onCurrentDay = endDate >= todayStart && endDate < todayEnd;

                // Check if event ends on current calendar date
                if (onCurrentDay) {
                    // If event ends in this hour at non-standard time, add it
                    if (endHour === hour && endMinute !== 0 && endMinute !== 30) {
                        if (!snapPoints.includes(endMinute)) {
                            snapPoints.push(endMinute);
                        }
                    }
                }
            });

            return snapPoints.sort((a, b) => a - b);
        }

        // Find the closest snap point to a given minute
        // Simply snaps to the absolute closest point (whether :00, :30, or event end)
        function findClosestSnapPoint(snapPoints, targetMinute) {
            if (snapPoints.length === 0) return 0;

            // Find the absolute closest point from all available snap points
            let closest = snapPoints[0];
            let minDiff = Math.abs(targetMinute - closest);

            for (const point of snapPoints) {
                const diff = Math.abs(targetMinute - point);
                if (diff < minDiff) {
                    minDiff = diff;
                    closest = point;
                }
            }

            return closest;
        }

        // Setup drop zones on calendar hour rows
        function setupCalendarDropZones() {
            document.querySelectorAll('.hour-content').forEach(hourContent => {
                hourContent.addEventListener('dragover', function(e) {
                    e.preventDefault();
                    this.classList.add('drag-over');

                    // Block multi-select drops on calendar
                    if (e.dataTransfer.types.includes('application/x-multi-task')) {
                        this.classList.add('drag-blocked');
                        e.dataTransfer.dropEffect = 'none';
                        return;
                    }

                    // Check if dragging a task, time block, or calendar event
                    const taskId = currentDragTaskId;
                    const timeBlockId = currentDragTimeBlockId;
                    const calendarEventId = currentDragCalendarEventId;

                    // Use existing duration if available, otherwise 30 minutes
                    let durationMs = 30 * 60 * 1000;
                    let excludeId = null;

                    if (calendarEventId) {
                        excludeId = 'event-' + calendarEventId;
                        const event = calendarEvents.find(e => e.id === calendarEventId);
                        if (event) {
                            const existingStart = event.override_start ? new Date(event.override_start) : new Date(event.start);
                            const existingEnd = event.override_end ? new Date(event.override_end) : new Date(event.end);
                            durationMs = existingEnd - existingStart;
                        }
                    } else if (taskId) {
                        excludeId = taskId;
                        // Only preserve duration if dragging from calendar (moving existing schedule on current day)
                        // When dragging from task panel, always use 30 minutes
                        if (e.dataTransfer.types.includes('application/x-scheduled-task')) {
                            // Get duration from schedule on current day only
                            const todayStart = new Date(currentCalendarDate);
                            const todayEnd = new Date(todayStart.getTime() + 24 * 60 * 60 * 1000);
                            const schedules = taskSchedulesMap[taskId] || [];
                            const scheduleOnCurrentDay = schedules.find(s => {
                                const scheduleStart = new Date(s.start_time);
                                return scheduleStart >= todayStart && scheduleStart < todayEnd;
                            });
                            if (scheduleOnCurrentDay) {
                                const existingStart = new Date(scheduleOnCurrentDay.start_time);
                                const existingEnd = new Date(scheduleOnCurrentDay.end_time);
                                durationMs = existingEnd - existingStart;
                            }
                        }
                        // If not from calendar, durationMs stays at 30 minutes default
                    } else if (timeBlockId) {
                        excludeId = 'timeblock-' + timeBlockId;
                        const block = timeBlocks.find(b => b.id === parseInt(timeBlockId));
                        if (block) {
                            const existingStart = new Date(block.start);
                            const existingEnd = new Date(block.end);
                            durationMs = existingEnd - existingStart;
                        }
                    }
                    const durationMinutes = durationMs / (60 * 1000);

                    // Calculate preview height as percentage of hour (60px per hour)
                    const previewHeightPercent = (durationMinutes / 60) * 100;
                    this.style.setProperty('--preview-height', `${previewHeightPercent}%`);

                    // Determine drop position using snap points
                    const rect = this.getBoundingClientRect();
                    const relativeY = e.clientY - rect.top;
                    const percentY = relativeY / rect.height;
                    const hour = parseInt(this.dataset.hour);

                    // Calculate target minute from position
                    const targetMinute = Math.round(percentY * 60);

                    // Get valid snap points for this hour and find closest
                    const snapPoints = getValidSnapPoints(hour);
                    const clampedMinute = findClosestSnapPoint(snapPoints, targetMinute);

                    // Update visual indicators - set precise preview position
                    const previewTopPercent = (clampedMinute / 60) * 100;
                    this.style.setProperty('--preview-top', `${previewTopPercent}%`);

                    const startLocal = new Date(currentCalendarDate.getFullYear(), currentCalendarDate.getMonth(), currentCalendarDate.getDate(), hour, clampedMinute);
                    const endLocal = new Date(startLocal.getTime() + durationMs);

                    // For tasks, block if overlapping event/time block OR more than 3 tasks
                    // For time blocks, don't allow any overlap
                    let isBlocked = false;
                    if (taskId) {
                        // Tasks can't be dropped on events or time blocks
                        if (hasEventOrTimeBlockOverlap(startLocal, endLocal)) {
                            isBlocked = true;
                        } else {
                            const overlappingCount = countOverlappingTasks(startLocal, endLocal, excludeId);
                            isBlocked = overlappingCount >= 3;
                        }
                    } else if (timeBlockId) {
                        isBlocked = hasOverlappingItem(startLocal, endLocal, excludeId);
                    }

                    this.classList.toggle('drag-blocked', isBlocked);
                    e.dataTransfer.dropEffect = isBlocked ? 'none' : 'move';
                });

                hourContent.addEventListener('dragleave', function(e) {
                    if (!this.contains(e.relatedTarget)) {
                        this.classList.remove('drag-over', 'drag-blocked');
                        this.style.removeProperty('--preview-height');
                        this.style.removeProperty('--preview-top');
                    }
                });

                hourContent.addEventListener('drop', async function(e) {
                    e.preventDefault();
                    this.classList.remove('drag-over', 'drag-blocked');
                    this.style.removeProperty('--preview-height');
                    this.style.removeProperty('--preview-top');

                    // Block multi-select drops on calendar
                    if (e.dataTransfer.types.includes('application/x-multi-task')) {
                        return;
                    }

                    const dataId = e.dataTransfer.getData('text/plain');
                    if (!dataId) return;

                    const isTimeBlock = e.dataTransfer.types.includes('application/x-time-block');
                    const isCalendarEvent = e.dataTransfer.types.includes('application/x-calendar-event');
                    const hour = parseInt(this.dataset.hour);

                    // Calculate minute based on drop position within the hour
                    const rect = this.getBoundingClientRect();
                    const relativeY = e.clientY - rect.top;
                    const percentY = relativeY / rect.height;

                    // Calculate target minute from position
                    let targetMinute = Math.round(percentY * 60);
                    let finalHour = hour;
                    let finalMinute = targetMinute;

                    // Check if we should snap to previous hour's event end
                    // If dragging near top of hour (< 15 min) and there's an event ending in previous hour at irregular time
                    if (targetMinute < 15) {
                        const todayStart = new Date(currentCalendarDate);
                        todayStart.setHours(0, 0, 0, 0);
                        const todayEnd = new Date(todayStart.getTime() + 24 * 60 * 60 * 1000);

                        let closestPrevHourEventEnd = null;
                        let closestDistance = Infinity;

                        calendarEvents.forEach(event => {
                            const endDate = new Date(event.end);
                            if (endDate >= todayStart && endDate < todayEnd) {
                                const endHour = endDate.getHours();
                                const endMinute = endDate.getMinutes();
                                // Check if event ends in previous hour at non-standard time
                                if (endHour === hour - 1 && endMinute !== 0 && endMinute !== 30) {
                                    // Calculate distance from drop position to this event end
                                    // Drop position is at hour:targetMinute, event ends at (hour-1):endMinute
                                    const dropPositionMinutes = hour * 60 + targetMinute;
                                    const eventEndMinutes = (hour - 1) * 60 + endMinute;
                                    const distance = dropPositionMinutes - eventEndMinutes;
                                    if (distance >= 0 && distance < closestDistance) {
                                        closestDistance = distance;
                                        closestPrevHourEventEnd = { hour: hour - 1, minute: endMinute };
                                    }
                                }
                            }
                        });

                        // If found a close event end within 15 minutes, snap to it
                        if (closestPrevHourEventEnd && closestDistance <= 15) {
                            finalHour = closestPrevHourEventEnd.hour;
                            finalMinute = closestPrevHourEventEnd.minute;
                        } else {
                            // Normal snapping within current hour
                            const snapPoints = getValidSnapPoints(hour);
                            finalMinute = findClosestSnapPoint(snapPoints, targetMinute);
                        }
                    } else {
                        // Normal snapping within current hour
                        const snapPoints = getValidSnapPoints(hour);
                        finalMinute = findClosestSnapPoint(snapPoints, targetMinute);
                    }

                    // Create the scheduled start time in local timezone using currentCalendarDate
                    const startLocal = new Date(currentCalendarDate.getFullYear(), currentCalendarDate.getMonth(), currentCalendarDate.getDate(), finalHour, finalMinute);

                    if (isCalendarEvent) {
                        // Handle calendar event drop (local move)
                        const eventId = parseInt(dataId);
                        const event = calendarEvents.find(e => e.id === eventId);
                        if (!event) return;

                        // Get current event times (use override if present)
                        const currentStart = event.override_start ? new Date(event.override_start) : new Date(event.start);
                        const currentEnd = event.override_end ? new Date(event.override_end) : new Date(event.end);
                        const durationMs = currentEnd - currentStart;
                        const endLocal = new Date(startLocal.getTime() + durationMs);

                        // Convert to UTC for API
                        const startUTC = localToUTC(startLocal);
                        const endUTC = localToUTC(endLocal);

                        await moveCalendarEvent(eventId, startUTC, endUTC);
                    } else if (isTimeBlock) {
                        // Handle time block drop
                        const blockId = dataId;
                        const block = timeBlocks.find(b => b.id === parseInt(blockId));
                        if (!block) return;

                        // Preserve existing duration
                        const existingStart = new Date(block.start);
                        const existingEnd = new Date(block.end);
                        const durationMs = existingEnd - existingStart;
                        const endLocal = new Date(startLocal.getTime() + durationMs);

                        // Check for overlapping items
                        const hasOverlap = hasOverlappingItem(startLocal, endLocal, 'timeblock-' + blockId);
                        if (hasOverlap) {
                            return;
                        }

                        const startUTC = localToUTC(startLocal);
                        const endUTC = localToUTC(endLocal);

                        const success = await updateTimeBlockTime(blockId, startUTC, endUTC);
                        if (success) {
                            renderTimeBlocks();
                        }
                    } else {
                        // Handle task drop
                        const taskId = dataId;
                        const schedules = taskSchedulesMap[taskId] || [];

                        // Check if task already has a schedule on the current calendar day
                        const todayStart = new Date(currentCalendarDate);
                        const todayEnd = new Date(todayStart.getTime() + 24 * 60 * 60 * 1000);
                        const existingScheduleOnCurrentDay = schedules.find(s => {
                            const scheduleStart = new Date(s.start_time);
                            return scheduleStart >= todayStart && scheduleStart < todayEnd;
                        });

                        // Always use 30 minutes for new drops, preserve duration only when moving existing schedule
                        let durationMs = 30 * 60 * 1000; // 30 minutes default
                        let existingScheduleId = null;

                        if (existingScheduleOnCurrentDay) {
                            // Moving existing schedule - preserve its duration
                            const existingStart = new Date(existingScheduleOnCurrentDay.start_time);
                            const existingEnd = new Date(existingScheduleOnCurrentDay.end_time);
                            durationMs = existingEnd - existingStart;
                            existingScheduleId = existingScheduleOnCurrentDay.id;
                        }
                        // For new drops from task panel, durationMs stays at 30 minutes

                        const endLocal = new Date(startLocal.getTime() + durationMs);

                        // Block drop if it overlaps with a time block or calendar event
                        if (hasEventOrTimeBlockOverlap(startLocal, endLocal)) {
                            // Can't drop on time blocks or events
                            return;
                        }

                        // Check for overlapping tasks - allow up to 3 tasks at same time
                        const overlappingTaskCount = countOverlappingTasks(startLocal, endLocal, taskId, existingScheduleId);
                        if (overlappingTaskCount >= 3) {
                            // Max 3 tasks allowed at same time
                            return;
                        }

                        const startUTC = localToUTC(startLocal);
                        const endUTC = localToUTC(endLocal);

                        let success;
                        // If task already has a schedule on this day, update it (move); otherwise create new
                        if (existingScheduleId) {
                            // Update the existing schedule (move it)
                            success = await updateScheduleById(existingScheduleId, taskId, startUTC, endUTC);
                        } else {
                            // Create a new schedule
                            success = await createTaskSchedule(taskId, startUTC, endUTC);
                        }

                        if (success) {
                            renderScheduledTasks();
                            initializeScheduledIcons();
                        }
                    }
                });

                // Gap-fill feature: mousemove handler for Cmd/Ctrl + hover preview
                hourContent.addEventListener('mousemove', function(e) {
                    if (!isModifierKeyHeld) {
                        clearGapPreview();
                        return;
                    }

                    const hour = parseInt(this.dataset.hour);
                    const rect = this.getBoundingClientRect();
                    const relativeY = e.clientY - rect.top;
                    const minuteInHour = Math.round((relativeY / rect.height) * 60);

                    // Calculate the full time of cursor position
                    const cursorTime = getTimeAtPosition(hour, minuteInHour);

                    // Check if cursor is over an existing item
                    if (isPositionOccupied(cursorTime)) {
                        clearGapPreview();
                        return;
                    }

                    // Find the gap boundaries
                    const gap = findGapAtTime(cursorTime);
                    if (gap) {
                        showGapPreview(gap.start, gap.end);
                    } else {
                        clearGapPreview();
                    }
                });

                hourContent.addEventListener('mouseleave', function() {
                    clearGapPreview();
                });

                // Gap-fill feature: click handler to create blocked time
                hourContent.addEventListener('click', function(e) {
                    if (isModifierKeyHeld && currentGapPreview) {
                        e.preventDefault();
                        e.stopPropagation();
                        createBlockedTimeForGap(currentGapPreview.startTime, currentGapPreview.endTime);
                    }
                });
            });
        }

        // Setup task cards to be draggable to calendar and tasks panel as drop target for removing from calendar
        function setupTaskToCalendarDrag() {
            // Task cards can already be dragged (setupTaskCardDragEvents handles this)
            // We just need to make sure the calendar drop zones accept them

            // Also set up the tasks panel as a drop target for removing calendar times
            const tasksPanel = document.getElementById('tasks-panel');
            if (tasksPanel) {
                tasksPanel.addEventListener('dragover', function(e) {
                    // Only show drop indicator if dragging a scheduled task from calendar
                    if (e.dataTransfer.types.includes('application/x-scheduled-task')) {
                        e.preventDefault();
                        e.dataTransfer.dropEffect = 'move';
                    }
                });

                tasksPanel.addEventListener('drop', async function(e) {
                    // Only handle if dragging a scheduled task from calendar
                    if (!e.dataTransfer.types.includes('application/x-scheduled-task')) return;

                    e.preventDefault();
                    const taskId = e.dataTransfer.getData('text/plain');
                    if (!taskId) return;

                    // Remove from calendar by deleting all schedules
                    await removeFromCalendar(taskId);
                });
            }
        }

        // Initialize scheduled task indicators on existing cards
        function initScheduledTaskIndicators() {
            Object.entries(taskSchedulesMap).forEach(([taskId, schedules]) => {
                if (schedules && schedules.length > 0) {
                    updateTaskScheduledClass(taskId);
                }
            });
        }

        // Update task counts in the panel layout
        function updatePanelCounts() {
            // Update state group counts (in states-content)
            document.querySelectorAll('#states-content .state-group').forEach(group => {
                const stateId = group.dataset.stateId;
                const body = group.querySelector('.state-group-body');
                if (!body) return;

                const visibleCards = body.querySelectorAll('.task-card:not([style*="display: none"])').length;
                const countEl = document.getElementById(`panel-count-${stateId}`);
                if (countEl) countEl.textContent = visibleCards;

                // Update collapsed metrics pill
                const metricPill = document.querySelector(`.panel-collapsed-metrics .metric-pill[data-state-id="${stateId}"] .metric-count`);
                if (metricPill) metricPill.textContent = visibleCards;

                // Show/hide empty message (always hide "No State" group when empty)
                let emptyMsg = body.querySelector('.state-group-empty');
                if (visibleCards === 0) {
                    if (stateId === 'none') {
                        // Hide "No State" group when empty
                        group.style.display = 'none';
                    } else {
                        group.style.display = '';
                        // Auto-collapse empty state groups
                        group.classList.add('collapsed');
                        if (!emptyMsg) {
                            emptyMsg = document.createElement('div');
                            emptyMsg.className = 'state-group-empty';
                            emptyMsg.textContent = 'No tasks';
                            body.appendChild(emptyMsg);
                        }
                    }
                } else {
                    group.style.display = '';
                    if (emptyMsg) {
                        emptyMsg.remove();
                    }
                }
            });

            // Update tag group counts (in tags-content)
            document.querySelectorAll('#tags-content .state-group').forEach(group => {
                const body = group.querySelector('.state-group-body');
                if (!body) return;

                const visibleCards = body.querySelectorAll('.task-card:not([style*="display: none"])').length;
                const countEl = group.querySelector('.state-group-count');
                if (countEl) countEl.textContent = visibleCards;

                // Show empty message when no visible tasks
                let emptyMsg = body.querySelector('.state-group-empty');
                if (visibleCards === 0) {
                    group.style.display = '';
                    // Auto-collapse empty tag groups
                    group.classList.add('collapsed');
                    if (!emptyMsg) {
                        emptyMsg = document.createElement('div');
                        emptyMsg.className = 'state-group-empty';
                        emptyMsg.textContent = 'No tasks';
                        body.appendChild(emptyMsg);
                    }
                } else {
                    group.style.display = '';
                    if (emptyMsg) {
                        emptyMsg.remove();
                    }
                }
            });

            // Update schedule group counts (in schedules-content)
            document.querySelectorAll('#schedules-content .state-group').forEach(group => {
                const body = group.querySelector('.state-group-body');
                if (!body) return;

                const visibleCards = body.querySelectorAll('.task-card:not([style*="display: none"])').length;
                const countEl = group.querySelector('.state-group-count');
                if (countEl) countEl.textContent = visibleCards;

                // Update collapsed metrics pill
                const scheduleGroup = group.dataset.scheduleGroup;
                const metricPill = document.querySelector(`.panel-collapsed-metrics .metric-pill[data-schedule-group="${scheduleGroup}"] .metric-count`);
                if (metricPill) metricPill.textContent = visibleCards;

                // Show empty message when no visible tasks
                let emptyMsg = body.querySelector('.state-group-empty');
                if (visibleCards === 0) {
                    group.style.display = '';
                    // Auto-collapse empty schedule groups
                    group.classList.add('collapsed');
                    if (!emptyMsg) {
                        emptyMsg = document.createElement('div');
                        emptyMsg.className = 'state-group-empty';
                        emptyMsg.textContent = 'No tasks';
                        body.appendChild(emptyMsg);
                    }
                } else {
                    group.style.display = '';
                    if (emptyMsg) {
                        emptyMsg.remove();
                    }
                }
            });
        }

        // Update calendar metrics in collapsed view
        function updateCalendarMetrics() {
            if (!calendarEvents || calendarEvents.length === 0) {
                document.getElementById('meetings-count').textContent = '0';
                document.getElementById('meetings-time').textContent = '0h';
                return;
            }

            // Get today's date boundaries in local timezone
            const now = new Date();
            const todayStart = new Date(now.getFullYear(), now.getMonth(), now.getDate());
            const todayEnd = new Date(todayStart.getTime() + 24 * 60 * 60 * 1000);

            // Filter to today's events and count non-all-day events as meetings
            const todaysEvents = calendarEvents.filter(event => {
                if (event.is_all_day) return false;
                const startDate = new Date(event.start);
                const endDate = new Date(event.end);
                // Event overlaps with today
                return endDate > todayStart && startDate < todayEnd;
            });

            const meetingCount = todaysEvents.length;

            // Calculate total time in meetings (in minutes)
            let totalMinutes = 0;
            todaysEvents.forEach(event => {
                const startDate = new Date(event.start);
                const endDate = new Date(event.end);
                const durationMs = endDate - startDate;
                totalMinutes += Math.round(durationMs / 60000);
            });

            // Format time
            const hours = Math.floor(totalMinutes / 60);
            const mins = totalMinutes % 60;
            let timeStr;
            if (hours > 0 && mins > 0) {
                timeStr = `${hours}h ${mins}m`;
            } else if (hours > 0) {
                timeStr = `${hours}h`;
            } else {
                timeStr = `${mins}m`;
            }

            document.getElementById('meetings-count').textContent = meetingCount;
            document.getElementById('meetings-time').textContent = timeStr;
        }

        // ========== Task Multi-Select ==========

        let selectedTaskIds = new Set();
        let lastClickedTaskId = null; // For shift-click range selection

        function clearTaskSelection() {
            selectedTaskIds.clear();
            document.querySelectorAll('.task-card.selected').forEach(card => {
                card.classList.remove('selected');
            });
            lastClickedTaskId = null;
        }

        function toggleTaskSelection(taskId, card) {
            if (selectedTaskIds.has(taskId)) {
                selectedTaskIds.delete(taskId);
                card.classList.remove('selected');
            } else {
                selectedTaskIds.add(taskId);
                card.classList.add('selected');
            }
            lastClickedTaskId = taskId;
        }

        function selectTask(taskId, card) {
            selectedTaskIds.add(taskId);
            card.classList.add('selected');
            lastClickedTaskId = taskId;
        }

        function selectTaskRange(fromId, toId) {
            // Get all task cards in DOM order
            const allCards = Array.from(document.querySelectorAll('.task-card'));
            const fromIndex = allCards.findIndex(c => parseInt(c.dataset.taskId) === fromId);
            const toIndex = allCards.findIndex(c => parseInt(c.dataset.taskId) === toId);

            if (fromIndex === -1 || toIndex === -1) return;

            const start = Math.min(fromIndex, toIndex);
            const end = Math.max(fromIndex, toIndex);

            for (let i = start; i <= end; i++) {
                const card = allCards[i];
                const taskId = parseInt(card.dataset.taskId);
                selectedTaskIds.add(taskId);
                card.classList.add('selected');
            }
        }

        function selectAllTasksInGroup(groupElement) {
            // Clear existing selection first
            clearTaskSelection();

            // Select all visible task cards in the group
            const taskCards = groupElement.querySelectorAll('.task-card');
            taskCards.forEach(card => {
                const taskId = parseInt(card.dataset.taskId);
                selectedTaskIds.add(taskId);
                card.classList.add('selected');
            });

            // Show toast if tasks were selected
            if (selectedTaskIds.size > 0) {
                showToast(`${selectedTaskIds.size} task${selectedTaskIds.size > 1 ? 's' : ''} selected`, {
                    duration: 2000,
                    icon: 'bi-check-circle'
                });
            }
        }

        function handleTaskCardClick(e, card) {
            const taskId = parseInt(card.dataset.taskId);

            // Don't handle selection if clicking on buttons or drag handle
            if (e.target.closest('button') || e.target.closest('.task-card-drag-handle')) {
                return;
            }

            if (e.shiftKey && lastClickedTaskId !== null) {
                // Shift+click: select range
                e.preventDefault();
                selectTaskRange(lastClickedTaskId, taskId);
            } else if (e.metaKey || e.ctrlKey) {
                // Cmd/Ctrl+click: toggle selection
                e.preventDefault();
                toggleTaskSelection(taskId, card);
            } else {
                // Regular click: clear selection and select this one (but let double-click through)
                // We'll handle this in mousedown to not interfere with double-click
            }
        }

        // Clear selection when clicking outside task cards
        document.addEventListener('click', function(e) {
            if (!e.target.closest('.task-card') && !e.target.closest('.task-context-menu') && !e.target.closest('.modal-overlay')) {
                clearTaskSelection();
            }
        });

        // ========== Task Card Drag and Drop ==========

        let draggedTaskCard = null;
        let draggedTaskCards = []; // For multi-select drag
        let taskDropIndicator = null;
        let currentDragTaskId = null; // Track dragged task ID for both task cards and calendar items

        // Create drop indicator element for task cards
        function createTaskDropIndicator() {
            const indicator = document.createElement('div');
            indicator.className = 'task-drop-indicator';
            indicator.style.cssText = 'height: 3px; background: #6B9080; border-radius: 2px; margin: 0.35rem 0;';
            return indicator;
        }

        // Get drop position within state-group-body
        function getTaskDropPosition(container, y) {
            const cards = [...container.querySelectorAll('.task-card:not(.dragging)')];

            for (const card of cards) {
                const rect = card.getBoundingClientRect();
                const midpoint = rect.top + rect.height / 2;
                if (y < midpoint) {
                    return { element: card, position: 'before' };
                }
            }
            return { element: null, position: 'end' };
        }

        // Setup drag events for task cards
        function setupTaskCardDragEvents(card) {
            // Make card draggable
            card.draggable = true;

            // Click handler for selection
            card.addEventListener('click', function(e) {
                const taskId = parseInt(this.dataset.taskId);

                // Don't handle if clicking buttons
                if (e.target.closest('button')) return;

                if (e.shiftKey && lastClickedTaskId !== null) {
                    // Shift+click: select range
                    e.preventDefault();
                    selectTaskRange(lastClickedTaskId, taskId);
                } else if (e.metaKey || e.ctrlKey) {
                    // Cmd/Ctrl+click: toggle selection
                    e.preventDefault();
                    toggleTaskSelection(taskId, this);
                }
                // Regular click without modifier doesn't change selection (allows drag)
            });

            card.addEventListener('dragstart', function(e) {
                const taskId = parseInt(card.dataset.taskId);

                // If dragging a selected card, drag all selected cards
                if (selectedTaskIds.has(taskId) && selectedTaskIds.size > 1) {
                    draggedTaskCards = Array.from(selectedTaskIds).map(id =>
                        document.querySelector(`.task-card[data-task-id="${id}"]`)
                    ).filter(c => c);
                    draggedTaskCards.forEach(c => {
                        c.classList.add('dragging');
                        c.style.opacity = '0.4';
                    });
                    // Don't allow dropping on calendar for multi-select
                    e.dataTransfer.setData('application/x-multi-task', 'true');
                } else {
                    // Single task drag - clear selection and drag just this one
                    clearTaskSelection();
                    draggedTaskCards = [card];
                }

                draggedTaskCard = card;
                currentDragTaskId = card.dataset.taskId;
                card.classList.add('dragging');
                e.dataTransfer.effectAllowed = 'move';
                e.dataTransfer.setData('text/plain', card.dataset.taskId);
                setTimeout(() => {
                    card.style.opacity = '0.4';
                }, 0);
            });

            card.addEventListener('dragend', function() {
                // Reset all dragged cards
                draggedTaskCards.forEach(c => {
                    c.classList.remove('dragging');
                    c.style.opacity = '1';
                });
                card.classList.remove('dragging');
                card.style.opacity = '1';
                draggedTaskCard = null;
                draggedTaskCards = [];
                currentDragTaskId = null;
                // Remove all drag-over classes and drop indicator
                document.querySelectorAll('.drag-over').forEach(el => el.classList.remove('drag-over'));
                if (taskDropIndicator && taskDropIndicator.parentElement) {
                    taskDropIndicator.remove();
                }
                taskDropIndicator = null;
            });

            // Right-click to show context menu
            card.addEventListener('contextmenu', function(e) {
                const taskId = parseInt(this.dataset.taskId);

                // If right-clicking on a selected card with multiple selections, show multi-select menu
                if (selectedTaskIds.has(taskId) && selectedTaskIds.size > 1) {
                    showMultiSelectContextMenu(e);
                } else {
                    // Clear selection and show single-task menu
                    clearTaskSelection();
                    showContextMenu(e, taskId, 'openTaskPanel');
                }
            });

            // Double-click to open task panel
            card.addEventListener('dblclick', function(e) {
                e.preventDefault();
                e.stopPropagation();
                clearTaskSelection();
                openTaskPanel(parseInt(this.dataset.taskId));
            });
        }

        // Setup drop zones (state-group-body elements)
        function setupDropZones() {
            document.querySelectorAll('.state-group-body').forEach(dropZone => {
                dropZone.addEventListener('dragover', function(e) {
                    e.preventDefault();
                    if (!draggedTaskCard) return;

                    e.dataTransfer.dropEffect = 'move';
                    this.classList.add('drag-over');

                    // Show drop indicator at correct position
                    const { element, position } = getTaskDropPosition(this, e.clientY);

                    if (!taskDropIndicator) {
                        taskDropIndicator = createTaskDropIndicator();
                    }

                    if (position === 'end') {
                        this.appendChild(taskDropIndicator);
                    } else if (element) {
                        element.parentElement.insertBefore(taskDropIndicator, element);
                    }
                });

                dropZone.addEventListener('dragleave', function(e) {
                    // Only remove if we're actually leaving the drop zone
                    if (!this.contains(e.relatedTarget)) {
                        this.classList.remove('drag-over');
                        if (taskDropIndicator && taskDropIndicator.parentElement === this) {
                            taskDropIndicator.remove();
                        }
                    }
                });

                dropZone.addEventListener('drop', async function(e) {
                    e.preventDefault();
                    this.classList.remove('drag-over');

                    if (!draggedTaskCard) return;

                    const rawNewStateId = this.dataset.stateId;
                    const newStateId = rawNewStateId === 'none' ? null : parseInt(rawNewStateId);

                    // Get drop position
                    const { element, position } = getTaskDropPosition(this, e.clientY);

                    // Remove drop indicator
                    if (taskDropIndicator && taskDropIndicator.parentElement) {
                        taskDropIndicator.remove();
                    }

                    // Handle multi-select drop
                    const isMultiDrop = draggedTaskCards.length > 1;
                    const cardsToMove = isMultiDrop ? draggedTaskCards : [draggedTaskCard];

                    // Collect old states for each card
                    const cardOldStates = cardsToMove.map(card => {
                        const oldBody = card.parentElement;
                        const rawOldStateId = card.closest('.state-group').dataset.stateId;
                        const oldStateId = rawOldStateId === 'none' ? null : parseInt(rawOldStateId);
                        return { card, oldBody, oldStateId, changedState: newStateId !== oldStateId };
                    });

                    // Move cards to new position (maintain their relative order)
                    // Sort cards by their current order in the DOM to maintain relative order
                    const sortedCards = [...cardsToMove].sort((a, b) => {
                        const aRect = a.getBoundingClientRect();
                        const bRect = b.getBoundingClientRect();
                        return aRect.top - bRect.top;
                    });

                    // Insert cards at the drop position
                    if (position === 'end') {
                        sortedCards.forEach(card => this.appendChild(card));
                    } else if (element) {
                        // Insert before the target element
                        sortedCards.forEach(card => {
                            element.parentElement.insertBefore(card, element);
                        });
                    }

                    // Update counts
                    updatePanelCounts();

                    // Get new order of all cards in this state
                    const cardIds = [...this.querySelectorAll('.task-card')].map(c => parseInt(c.dataset.taskId));

                    // Update state on server for each card that changed state
                    for (const { card, changedState } of cardOldStates) {
                        if (changedState) {
                            const taskId = parseInt(card.dataset.taskId);
                            try {
                                const response = await fetch(`/tasks/api/${taskId}/update/`, {
                                    method: 'PATCH',
                                    headers: {
                                        'Content-Type': 'application/json',
                                        'X-CSRFToken': csrfToken
                                    },
                                    body: JSON.stringify({ state_id: newStateId })
                                });
                                const data = await response.json();
                                if (data.success && data.task) {
                                    // Update task everywhere (including calendar)
                                    handleTaskStateChange(data.task);
                                }
                            } catch (error) {
                                console.error('Error updating task state:', error);
                            }
                        }
                    }

                    // Update abandoned state visibility and warnings
                    updateAbandonedStateVisibility();
                    updateDeadlineWarningIcon();

                    // Always update order (for both same-state reorder and cross-state moves)
                    try {
                        await fetch('/tasks/api/tasks/reorder/', {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                                'X-CSRFToken': csrfToken
                            },
                            body: JSON.stringify({ task_ids: cardIds })
                        });
                    } catch (error) {
                        console.error('Error updating task order:', error);
                    }

                    // Collect unique old state bodies that need reordering
                    const oldBodiesSet = new Set();
                    for (const { oldBody, changedState } of cardOldStates) {
                        if (changedState && oldBody && oldBody !== this) {
                            oldBodiesSet.add(oldBody);
                        }
                    }

                    // Reorder each affected old state
                    for (const oldBody of oldBodiesSet) {
                        const oldCardIds = [...oldBody.querySelectorAll('.task-card')].map(c => parseInt(c.dataset.taskId));
                        try {
                            await fetch('/tasks/api/tasks/reorder/', {
                                method: 'POST',
                                headers: {
                                    'Content-Type': 'application/json',
                                    'X-CSRFToken': csrfToken
                                },
                                body: JSON.stringify({ task_ids: oldCardIds })
                            });
                        } catch (error) {
                            console.error('Error updating old state order:', error);
                        }
                    }

                });
            });
        }

        // Initialize drag and drop for existing cards
        document.querySelectorAll('.task-card').forEach(card => {
            setupTaskCardDragEvents(card);
        });
        setupDropZones();

        // Setup drag handlers for a single state group (used when adding new states)
        function setupStateGroupDragHandlers(stateGroup) {
            const dropZone = stateGroup.querySelector('.state-group-body');
            const header = stateGroup.querySelector('.state-group-header');

            if (dropZone) {
                dropZone.addEventListener('dragover', function(e) {
                    e.preventDefault();
                    if (!draggedTaskCard) return;

                    e.dataTransfer.dropEffect = 'move';
                    this.classList.add('drag-over');

                    const { element, position } = getTaskDropPosition(this, e.clientY);

                    if (!taskDropIndicator) {
                        taskDropIndicator = createTaskDropIndicator();
                    }

                    if (position === 'end') {
                        this.appendChild(taskDropIndicator);
                    } else if (element) {
                        element.parentElement.insertBefore(taskDropIndicator, element);
                    }
                });

                dropZone.addEventListener('dragleave', function(e) {
                    if (!this.contains(e.relatedTarget)) {
                        this.classList.remove('drag-over');
                        if (taskDropIndicator && taskDropIndicator.parentElement === this) {
                            taskDropIndicator.remove();
                        }
                    }
                });

                dropZone.addEventListener('drop', async function(e) {
                    e.preventDefault();
                    this.classList.remove('drag-over');

                    if (!draggedTaskCard) return;

                    const rawNewStateId = this.dataset.stateId;
                    const newStateId = rawNewStateId === 'none' ? null : parseInt(rawNewStateId);

                    const { element, position } = getTaskDropPosition(this, e.clientY);

                    if (taskDropIndicator && taskDropIndicator.parentElement) {
                        taskDropIndicator.remove();
                    }

                    // Handle multi-select drop
                    const isMultiDrop = draggedTaskCards.length > 1;
                    const cardsToMove = isMultiDrop ? draggedTaskCards : [draggedTaskCard];

                    // Collect old states for each card
                    const cardOldStates = cardsToMove.map(card => {
                        const oldBody = card.parentElement;
                        const rawOldStateId = card.closest('.state-group').dataset.stateId;
                        const oldStateId = rawOldStateId === 'none' ? null : parseInt(rawOldStateId);
                        return { card, oldBody, oldStateId, changedState: newStateId !== oldStateId };
                    });

                    // Sort cards by their current order in the DOM
                    const sortedCards = [...cardsToMove].sort((a, b) => {
                        const aRect = a.getBoundingClientRect();
                        const bRect = b.getBoundingClientRect();
                        return aRect.top - bRect.top;
                    });

                    // Insert cards at the drop position
                    if (position === 'end') {
                        sortedCards.forEach(card => this.appendChild(card));
                    } else if (element) {
                        sortedCards.forEach(card => {
                            element.parentElement.insertBefore(card, element);
                        });
                    }

                    updatePanelCounts();

                    const cardIds = [...this.querySelectorAll('.task-card')].map(c => parseInt(c.dataset.taskId));

                    // Update state on server for each card that changed state
                    for (const { card, changedState } of cardOldStates) {
                        if (changedState) {
                            const taskId = parseInt(card.dataset.taskId);
                            try {
                                const response = await fetch(`/tasks/api/${taskId}/update/`, {
                                    method: 'PATCH',
                                    headers: {
                                        'Content-Type': 'application/json',
                                        'X-CSRFToken': csrfToken
                                    },
                                    body: JSON.stringify({ state_id: newStateId })
                                });
                                const data = await response.json();
                                if (data.success && data.task) {
                                    // Update task everywhere (including calendar)
                                    handleTaskStateChange(data.task);
                                }
                            } catch (error) {
                                console.error('Error updating task state:', error);
                            }
                        }
                    }

                    // Update abandoned state visibility and warnings
                    updateAbandonedStateVisibility();
                    updateDeadlineWarningIcon();

                    try {
                        await fetch('/tasks/api/tasks/reorder/', {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                                'X-CSRFToken': csrfToken
                            },
                            body: JSON.stringify({ task_ids: cardIds })
                        });
                    } catch (error) {
                        console.error('Error reordering tasks:', error);
                    }

                    // Collect unique old state bodies that need reordering
                    const oldBodiesSet = new Set();
                    for (const { oldBody, changedState } of cardOldStates) {
                        if (changedState && oldBody && oldBody !== this) {
                            oldBodiesSet.add(oldBody);
                        }
                    }

                    // Reorder each affected old state
                    for (const oldBody of oldBodiesSet) {
                        const oldCardIds = [...oldBody.querySelectorAll('.task-card')].map(c => parseInt(c.dataset.taskId));
                        try {
                            await fetch('/tasks/api/tasks/reorder/', {
                                method: 'POST',
                                headers: {
                                    'Content-Type': 'application/json',
                                    'X-CSRFToken': csrfToken
                                },
                                body: JSON.stringify({ task_ids: oldCardIds })
                            });
                        } catch (error) {
                            console.error('Error updating old state order:', error);
                        }
                    }
                });
            }

            if (header) {
                header.addEventListener('dragover', function(e) {
                    if (!draggedTaskCard) return;
                    e.preventDefault();
                    e.dataTransfer.dropEffect = 'move';

                    // Add visual feedback for both expanded and collapsed headers
                    this.classList.add('drag-hover');

                    const sg = this.closest('.state-group');
                    if (sg && sg.classList.contains('collapsed')) {
                        // Don't auto-expand terminal state
                        const stateId = parseInt(sg.dataset.stateId);
                        const isTerminal = stateId === getTerminalStateId();
                        if (isTerminal) return;

                        // Auto-expand collapsed state after delay
                        if (!expandTimeout) {
                            expandTimeout = setTimeout(() => {
                                sg.classList.remove('collapsed');
                            }, 400);
                        }
                    }
                });

                header.addEventListener('dragleave', function(e) {
                    this.classList.remove('drag-hover');
                    if (expandTimeout) {
                        clearTimeout(expandTimeout);
                        expandTimeout = null;
                    }
                });

                header.addEventListener('drop', async function(e) {
                    e.preventDefault();
                    this.classList.remove('drag-hover');
                    if (expandTimeout) {
                        clearTimeout(expandTimeout);
                        expandTimeout = null;
                    }

                    if (!draggedTaskCard) return;

                    const stateGroup = this.closest('.state-group');
                    const body = stateGroup.querySelector('.state-group-body');
                    if (!body) return;

                    const newStateId = parseInt(body.dataset.stateId);

                    // Handle multi-select drop
                    const isMultiDrop = draggedTaskCards.length > 1;
                    const cardsToMove = isMultiDrop ? draggedTaskCards : [draggedTaskCard];

                    // Collect old states for each card
                    const cardOldStates = cardsToMove.map(card => {
                        const oldStateGroup = card.closest('.state-group');
                        const oldBody = oldStateGroup ? oldStateGroup.querySelector('.state-group-body') : null;
                        const oldStateId = oldBody ? parseInt(oldBody.dataset.stateId) : null;
                        return { card, oldBody, oldStateId, changedState: newStateId !== oldStateId };
                    });

                    // Expand the state if collapsed (except for terminal state)
                    const isTerminalState = newStateId === getTerminalStateId();
                    if (!isTerminalState) {
                        stateGroup.classList.remove('collapsed');
                    }

                    // Sort cards by their current order in the DOM
                    const sortedCards = [...cardsToMove].sort((a, b) => {
                        const aRect = a.getBoundingClientRect();
                        const bRect = b.getBoundingClientRect();
                        return aRect.top - bRect.top;
                    });

                    // Move the task cards to the top of the body
                    sortedCards.reverse().forEach(card => {
                        if (body.firstChild) {
                            body.insertBefore(card, body.firstChild);
                        } else {
                            body.appendChild(card);
                        }
                    });

                    updatePanelCounts();

                    // Update task order in the new state
                    const cardIds = [...body.querySelectorAll('.task-card')].map(c => parseInt(c.dataset.taskId));

                    // Update state on server for each card that changed state
                    for (const { card, changedState } of cardOldStates) {
                        if (changedState) {
                            const taskId = parseInt(card.dataset.taskId);
                            try {
                                const response = await fetch(`/tasks/api/${taskId}/update/`, {
                                    method: 'PATCH',
                                    headers: {
                                        'Content-Type': 'application/json',
                                        'X-CSRFToken': csrfToken
                                    },
                                    body: JSON.stringify({ state_id: newStateId })
                                });
                                const data = await response.json();
                                if (data.success && data.task) {
                                    // Update task everywhere (including calendar)
                                    handleTaskStateChange(data.task);
                                }
                            } catch (error) {
                                console.error('Error updating task state:', error);
                            }
                        }
                    }

                    // Update abandoned state visibility and warnings
                    updateAbandonedStateVisibility();
                    updateDeadlineWarningIcon();

                    // Collect unique old state bodies that need reordering
                    const oldBodiesSet = new Set();
                    for (const { oldBody, changedState } of cardOldStates) {
                        if (changedState && oldBody && oldBody !== body) {
                            oldBodiesSet.add(oldBody);
                        }
                    }

                    // Reorder each affected old state
                    for (const oldBody of oldBodiesSet) {
                        const oldCardIds = [...oldBody.querySelectorAll('.task-card')].map(c => parseInt(c.dataset.taskId));
                        try {
                            await fetch('/tasks/api/tasks/reorder/', {
                                method: 'POST',
                                headers: {
                                    'Content-Type': 'application/json',
                                    'X-CSRFToken': csrfToken
                                },
                                body: JSON.stringify({ task_ids: oldCardIds })
                            });
                        } catch (error) {
                            console.error('Error updating old state order:', error);
                        }
                    }

                    // Update order in new state
                    try {
                        await fetch('/tasks/api/tasks/reorder/', {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                                'X-CSRFToken': csrfToken
                            },
                            body: JSON.stringify({ task_ids: cardIds })
                        });
                    } catch (error) {
                        console.error('Error reordering tasks:', error);
                    }
                });
            }
        }

        // Setup drag-over handlers for state group headers
        // When dragging over a header, allow dropping to move task into that state
        let expandTimeout = null;
        document.querySelectorAll('.state-group-header').forEach(header => {
            header.addEventListener('dragover', function(e) {
                if (!draggedTaskCard) return;
                e.preventDefault();
                e.dataTransfer.dropEffect = 'move';

                // Add visual feedback for both expanded and collapsed headers
                this.classList.add('drag-hover');

                const stateGroup = this.closest('.state-group');
                if (stateGroup && stateGroup.classList.contains('collapsed')) {
                    // Don't auto-expand terminal state
                    const stateId = parseInt(stateGroup.dataset.stateId);
                    const isTerminal = stateId === getTerminalStateId();
                    if (isTerminal) return;

                    // Auto-expand collapsed state after delay
                    if (!expandTimeout) {
                        expandTimeout = setTimeout(() => {
                            stateGroup.classList.remove('collapsed');
                        }, 400);
                    }
                }
            });

            header.addEventListener('dragleave', function(e) {
                this.classList.remove('drag-hover');
                if (expandTimeout) {
                    clearTimeout(expandTimeout);
                    expandTimeout = null;
                }
            });

            header.addEventListener('drop', async function(e) {
                e.preventDefault();
                this.classList.remove('drag-hover');
                if (expandTimeout) {
                    clearTimeout(expandTimeout);
                    expandTimeout = null;
                }

                if (!draggedTaskCard) return;

                const stateGroup = this.closest('.state-group');
                const body = stateGroup.querySelector('.state-group-body');
                if (!body) return;

                const newStateId = parseInt(body.dataset.stateId);

                // Handle multi-select drop
                const isMultiDrop = draggedTaskCards.length > 1;
                const cardsToMove = isMultiDrop ? draggedTaskCards : [draggedTaskCard];

                // Collect old states for each card
                const cardOldStates = cardsToMove.map(card => {
                    const oldStateGroup = card.closest('.state-group');
                    const oldBody = oldStateGroup ? oldStateGroup.querySelector('.state-group-body') : null;
                    const oldStateId = oldBody ? parseInt(oldBody.dataset.stateId) : null;
                    return { card, oldBody, oldStateId, changedState: newStateId !== oldStateId };
                });

                // Expand the state if collapsed (except for terminal state)
                const isTerminalState = newStateId === getTerminalStateId();
                if (!isTerminalState) {
                    stateGroup.classList.remove('collapsed');
                }

                // Sort cards by their current order in the DOM
                const sortedCards = [...cardsToMove].sort((a, b) => {
                    const aRect = a.getBoundingClientRect();
                    const bRect = b.getBoundingClientRect();
                    return aRect.top - bRect.top;
                });

                // Move the task cards to the top of the body
                sortedCards.reverse().forEach(card => {
                    if (body.firstChild) {
                        body.insertBefore(card, body.firstChild);
                    } else {
                        body.appendChild(card);
                    }
                });

                updatePanelCounts();

                // Update task order in the new state
                const cardIds = [...body.querySelectorAll('.task-card')].map(c => parseInt(c.dataset.taskId));

                // Update state on server for each card that changed state
                for (const { card, changedState } of cardOldStates) {
                    if (changedState) {
                        const taskId = parseInt(card.dataset.taskId);
                        try {
                            const response = await fetch(`/tasks/api/${taskId}/update/`, {
                                method: 'PATCH',
                                headers: {
                                    'Content-Type': 'application/json',
                                    'X-CSRFToken': csrfToken
                                },
                                body: JSON.stringify({ state_id: newStateId })
                            });
                            const data = await response.json();
                            if (data.success && data.task) {
                                // Update task everywhere (including calendar)
                                handleTaskStateChange(data.task);
                            }
                        } catch (error) {
                            console.error('Error updating task state:', error);
                        }
                    }
                }

                // Update abandoned state visibility and warnings
                updateAbandonedStateVisibility();
                updateDeadlineWarningIcon();

                // Collect unique old state bodies that need reordering
                const oldBodiesSet = new Set();
                for (const { oldBody, changedState } of cardOldStates) {
                    if (changedState && oldBody && oldBody !== body) {
                        oldBodiesSet.add(oldBody);
                    }
                }

                // Reorder each affected old state
                for (const oldBody of oldBodiesSet) {
                    const oldCardIds = [...oldBody.querySelectorAll('.task-card')].map(c => parseInt(c.dataset.taskId));
                    try {
                        await fetch('/tasks/api/tasks/reorder/', {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                                'X-CSRFToken': csrfToken
                            },
                            body: JSON.stringify({ task_ids: oldCardIds })
                        });
                    } catch (error) {
                        console.error('Error updating old state order:', error);
                    }
                }

                // Update order in new state
                try {
                    await fetch('/tasks/api/tasks/reorder/', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'X-CSRFToken': csrfToken
                        },
                        body: JSON.stringify({ task_ids: cardIds })
                    });
                } catch (error) {
                    console.error('Error reordering tasks:', error);
                }
            });

            // Right-click to show context menu with Select All option
            header.addEventListener('contextmenu', function(e) {
                const stateGroup = this.closest('.state-group');
                if (stateGroup) {
                    showGroupContextMenu(e, stateGroup);
                }
            });
        });

        // Initialize two-panel layout
        generateHourlyCalendar();
        updateCurrentTimeLine();
        setCalendarDate();
        renderCalendarEvents();
        renderTimeBlocks();
        setupCalendarDropZones();
        renderScheduledTasks();

        // Update current time line every 15 minutes
        setInterval(updateCurrentTimeLine, 15 * 60 * 1000);
        initScheduledTaskIndicators();
        setupTaskToCalendarDrag();
        updateCollapsedMetricsForStates();  // Rebuild metrics excluding terminal state
        updateCalendarMetrics();
        updateStateTypeLabels();

        // Gap-fill feature: track modifier key state (Cmd on Mac, Ctrl on Windows)
        document.addEventListener('keydown', function(e) {
            if (e.metaKey || e.ctrlKey) {
                isModifierKeyHeld = true;
            }
        });

        document.addEventListener('keyup', function(e) {
            if (!e.metaKey && !e.ctrlKey) {
                isModifierKeyHeld = false;
                clearGapPreview();
            }
        });

        // Clear gap preview when window loses focus
        window.addEventListener('blur', function() {
            isModifierKeyHeld = false;
            clearGapPreview();
        });

        // Subtle icon color animation
        (function() {
            const icon = document.getElementById('page-icon');
            const baseColor = { r: 51, g: 51, b: 51 }; // #333
            const accentColor = { r: 107, g: 144, b: 128 }; // #6B9080 (Sage)
            let animationFrame;
            let startTime;
            let duration;
            let direction = 1; // 1 = to accent, -1 = to base

            function lerp(a, b, t) {
                return a + (b - a) * t;
            }

            function getRandomDuration() {
                return 3000 + Math.random() * 4000; // 3-7 seconds
            }

            function animate(timestamp) {
                if (!startTime) {
                    startTime = timestamp;
                    duration = getRandomDuration();
                }

                const elapsed = timestamp - startTime;
                const progress = Math.min(elapsed / duration, 1);

                // Ease in-out
                const eased = progress < 0.5
                    ? 2 * progress * progress
                    : 1 - Math.pow(-2 * progress + 2, 2) / 2;

                const t = direction === 1 ? eased : 1 - eased;

                const r = Math.round(lerp(baseColor.r, accentColor.r, t));
                const g = Math.round(lerp(baseColor.g, accentColor.g, t));
                const b = Math.round(lerp(baseColor.b, accentColor.b, t));

                icon.style.color = `rgb(${r}, ${g}, ${b})`;

                if (progress >= 1) {
                    direction *= -1;
                    startTime = null;
                }

                animationFrame = requestAnimationFrame(animate);
            }

            animationFrame = requestAnimationFrame(animate);
        })();

        // ========== Calendar Drag and Drop ==========

        // Setup calendar sections as drop zones
        document.querySelectorAll('.calendar-section').forEach(section => {
            section.addEventListener('dragover', function(e) {
                e.preventDefault();
                if (!draggedKanbanCard) return;
                this.classList.add('drag-over');
            });

            section.addEventListener('dragleave', function(e) {
                this.classList.remove('drag-over');
            });

            section.addEventListener('drop', async function(e) {
                e.preventDefault();
                this.classList.remove('drag-over');

                if (!draggedKanbanCard) return;

                const taskId = parseInt(draggedKanbanCard.dataset.taskId);

                // Get time period from parent calendar box
                const calendarBox = this.closest('.calendar-box');
                const timePeriod = calendarBox.dataset.timePeriod;
                const sectionNumber = parseInt(this.dataset.section);

                // Check if card is already in a calendar section
                const wasInCalendar = draggedKanbanCard.closest('.calendar-section');

                // Get the content div to append to
                const contentDiv = this.querySelector('.calendar-section-content');

                let cardToAdd;
                if (wasInCalendar) {
                    // Move the card from one calendar section to another
                    cardToAdd = draggedKanbanCard;
                    cardToAdd.classList.remove('dragging');
                    cardToAdd.style.opacity = '1';
                    cardToAdd.style.display = 'flex';
                    contentDiv.appendChild(cardToAdd);
                } else {
                    // Clone the card from kanban board
                    cardToAdd = draggedKanbanCard.cloneNode(true);
                    cardToAdd.draggable = true;
                    cardToAdd.classList.remove('dragging');
                    cardToAdd.style.opacity = '1';
                    cardToAdd.style.display = 'flex';
                    contentDiv.appendChild(cardToAdd);

                    // Setup drag for cloned card
                    setupCalendarCardDrag(cardToAdd);
                }

                // Update today field to true with time_period and section_number
                try {
                    await fetch(`/tasks/api/tasks/${taskId}/set-today/`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'X-CSRFToken': csrfToken
                        },
                        body: JSON.stringify({
                            today: true,
                            time_period: timePeriod,
                            section_number: sectionNumber
                        })
                    });
                } catch (error) {
                    console.error('Error updating today field:', error);
                }

                // Update calendar display after DOM updates
                setTimeout(() => {
                    processCalendarSections();
                }, 0);

                draggedKanbanCard = null;
            });
        });

        // Setup drag for calendar cards (to drag back to kanban)
        function setupCalendarCardDrag(card) {
            card.addEventListener('dragstart', function(e) {
                draggedKanbanCard = this;
                this.classList.add('dragging');
                e.dataTransfer.effectAllowed = 'move';
                e.dataTransfer.setData('text/plain', this.dataset.taskId);
                setTimeout(() => {
                    this.style.opacity = '0.4';
                }, 0);
            });

            card.addEventListener('dragend', function(e) {
                this.classList.remove('dragging');
                this.style.opacity = '1';
                draggedKanbanCard = null;
            });

            // Add click handler
            card.addEventListener('click', function() {
                openKanbanPanel(parseInt(this.dataset.taskId));
            });

            // Add context menu
            setupKanbanCardContextMenu(card);
        }

        // Setup drag for existing calendar cards
        document.querySelectorAll('.calendar-section .kanban-card').forEach(card => {
            setupCalendarCardDrag(card);
        });

        // Enhance kanban column drop to remove from calendar when dropped back
        const originalKanbanDropHandler = document.querySelectorAll('.kanban-column-body');
        originalKanbanDropHandler.forEach(body => {
            body.addEventListener('drop', async function(e) {
                if (!draggedKanbanCard) return;

                const taskId = parseInt(draggedKanbanCard.dataset.taskId);
                const wasInCalendar = draggedKanbanCard.closest('.calendar-section');

                if (wasInCalendar) {
                    // Remove from calendar
                    draggedKanbanCard.remove();

                    // Update today field to false
                    try {
                        await fetch(`/tasks/api/tasks/${taskId}/set-today/`, {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                                'X-CSRFToken': csrfToken
                            },
                            body: JSON.stringify({ today: false })
                        });
                    } catch (error) {
                        console.error('Error updating today field:', error);
                    }

                    // Update calendar display after DOM updates
                    setTimeout(() => {
                        processCalendarSections();
                    }, 0);
                }
            });
        });

        // ===== TIME SLOT PANEL FUNCTIONALITY =====

        let currentTimeslotSection = null;
        let draggedTimeslotTask = null;

        // Process calendar sections to show task counts
        function processCalendarSections() {
            document.querySelectorAll('.calendar-section').forEach(section => {
                const content = section.querySelector('.calendar-section-content');
                if (!content) return;

                const tasks = content.querySelectorAll('.kanban-card');
                const taskCount = tasks.length;

                // Remove any existing count display
                const existingCount = content.querySelector('.calendar-task-count');
                if (existingCount) {
                    existingCount.remove();
                }

                if (taskCount > 1) {
                    // Hide individual tasks
                    tasks.forEach(task => task.style.display = 'none');

                    // Create and show count summary
                    const countDiv = document.createElement('div');
                    countDiv.className = 'calendar-task-count';
                    countDiv.textContent = `${taskCount} tasks`;
                    countDiv.dataset.sectionId = section.dataset.section;

                    const calendarBox = section.closest('.calendar-box');
                    if (calendarBox) {
                        countDiv.dataset.timePeriod = calendarBox.dataset.timePeriod;
                    }

                    countDiv.addEventListener('click', function() {
                        openTimeslotPanel(section);
                    });

                    content.appendChild(countDiv);
                } else if (taskCount === 1) {
                    // Show single task normally
                    tasks[0].style.display = 'flex';
                }
            });
        }

        // Open time slot panel
        function openTimeslotPanel(section) {
            currentTimeslotSection = section;
            const content = section.querySelector('.calendar-section-content');
            if (!content) return;

            const tasks = Array.from(content.querySelectorAll('.kanban-card'));
            const calendarBox = section.closest('.calendar-box');
            if (!calendarBox) return;

            // Find the time label by section number
            const sectionNumber = parseInt(section.dataset.section);
            const labelColumn = calendarBox.querySelector('.calendar-label-column');
            if (!labelColumn) return;

            const timeLabels = labelColumn.querySelectorAll('.calendar-time-label');
            const timeLabelEl = timeLabels[sectionNumber - 1]; // section numbers are 1-indexed
            if (!timeLabelEl) return;

            const timeLabel = timeLabelEl.textContent;
            const timePeriod = calendarBox.dataset.timePeriod;

            // Set panel title
            document.getElementById('timeslot-panel-title').textContent =
                `${timePeriod.charAt(0).toUpperCase() + timePeriod.slice(1)} - ${timeLabel}`;

            // Populate task list
            const taskList = document.getElementById('timeslot-task-list');
            taskList.innerHTML = '';

            tasks.forEach(task => {
                const taskItem = createTimeslotTaskItem(task);
                taskList.appendChild(taskItem);
            });

            // Setup drag and drop for reordering
            setupTimeslotDragAndDrop();

            // Show panel
            document.getElementById('timeslot-panel-overlay').classList.add('active');
            document.getElementById('timeslot-panel').classList.add('active');
        }

        // Create task item for timeslot panel
        function createTimeslotTaskItem(task) {
            const item = document.createElement('div');
            item.className = 'timeslot-task-item';
            item.draggable = true;
            item.dataset.taskId = task.dataset.taskId;

            const title = document.createElement('div');
            title.className = 'timeslot-task-title';
            title.textContent = task.querySelector('.kanban-card-title').textContent;

            const meta = document.createElement('div');
            meta.className = 'timeslot-task-meta';

            const contextBadge = task.querySelector('.kanban-card-context');
            if (contextBadge) {
                const badge = document.createElement('span');
                badge.className = 'timeslot-task-context';
                badge.textContent = contextBadge.textContent;
                badge.style.background = contextBadge.style.background;
                meta.appendChild(badge);
            }

            item.appendChild(title);
            item.appendChild(meta);

            return item;
        }

        // Setup drag and drop for timeslot panel
        function setupTimeslotDragAndDrop() {
            const items = document.querySelectorAll('.timeslot-task-item');

            items.forEach(item => {
                item.addEventListener('dragstart', function(e) {
                    draggedTimeslotTask = this;
                    this.classList.add('dragging');
                    e.dataTransfer.effectAllowed = 'move';
                });

                item.addEventListener('dragend', function() {
                    this.classList.remove('dragging');
                    draggedTimeslotTask = null;
                });

                item.addEventListener('dragover', function(e) {
                    e.preventDefault();
                    if (draggedTimeslotTask === this) return;

                    const rect = this.getBoundingClientRect();
                    const midpoint = rect.top + rect.height / 2;

                    if (e.clientY < midpoint) {
                        this.parentNode.insertBefore(draggedTimeslotTask, this);
                    } else {
                        this.parentNode.insertBefore(draggedTimeslotTask, this.nextSibling);
                    }
                });
            });

            // Save order on drop
            document.getElementById('timeslot-task-list').addEventListener('drop', async function() {
                await saveTimeslotTaskOrder();
            });
        }

        // Save task order
        async function saveTimeslotTaskOrder() {
            const taskList = document.getElementById('timeslot-task-list');
            const taskIds = Array.from(taskList.querySelectorAll('.timeslot-task-item'))
                .map(item => parseInt(item.dataset.taskId));

            try {
                const response = await fetch('/tasks/api/tasks/reorder/', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-CSRFToken': csrfToken
                    },
                    body: JSON.stringify({ task_ids: taskIds })
                });

                if (response.ok) {
                    // Update order in the calendar section
                    if (currentTimeslotSection) {
                        const content = currentTimeslotSection.querySelector('.calendar-section-content');
                        const tasks = Array.from(content.querySelectorAll('.kanban-card'));

                        taskIds.forEach((taskId, index) => {
                            const task = tasks.find(t => parseInt(t.dataset.taskId) === taskId);
                            if (task) {
                                task.style.order = index;
                            }
                        });
                    }
                }
            } catch (error) {
                console.error('Error saving task order:', error);
            }
        }

        // Close timeslot panel
        function closeTimeslotPanel() {
            document.getElementById('timeslot-panel-overlay').classList.remove('active');
            document.getElementById('timeslot-panel').classList.remove('active');
            currentTimeslotSection = null;
        }

        // Event listeners for timeslot panel
        document.getElementById('timeslot-panel-close').addEventListener('click', closeTimeslotPanel);
        document.getElementById('timeslot-panel-overlay').addEventListener('click', closeTimeslotPanel);

        // Initialize schedule pills for tasks on page load (States and Tags views)
        // Schedules view does NOT show schedule pills (already grouping by schedule)
        function initializeScheduledIcons() {
            // Add schedule pills to States and Tags view cards (not Schedules view)
            document.querySelectorAll('#states-content .task-card, #tags-content .task-card').forEach(card => {
                const taskId = card.dataset.taskId;
                const schedules = taskSchedulesMap[taskId] || [];
                const scheduleLabel = getScheduleLabel(schedules);

                // Remove any existing schedule pill
                const existingPill = card.querySelector('.task-schedule-pill');
                if (existingPill) {
                    existingPill.remove();
                }

                if (scheduleLabel) {
                    // Add schedule pill
                    let iconsDiv = card.querySelector('.task-card-icons');
                    if (!iconsDiv) {
                        iconsDiv = document.createElement('div');
                        iconsDiv.className = 'task-card-icons';
                        card.querySelector('.task-card-content').appendChild(iconsDiv);
                    }

                    const pill = document.createElement('span');
                    pill.className = `task-schedule-pill ${scheduleLabel}`;
                    pill.textContent = scheduleLabel.charAt(0).toUpperCase() + scheduleLabel.slice(1);

                    // Insert at the beginning (before critical icon)
                    const criticalIcon = iconsDiv.querySelector('.task-critical-icon');
                    if (criticalIcon) {
                        iconsDiv.insertBefore(pill, criticalIcon);
                    } else {
                        iconsDiv.insertBefore(pill, iconsDiv.firstChild);
                    }
                } else {
                    // Clean up empty icons div if no schedule pill and no other icons
                    const iconsDiv = card.querySelector('.task-card-icons');
                    if (iconsDiv && iconsDiv.children.length === 0) {
                        iconsDiv.remove();
                    }
                }
            });
        }

        // ========== Calendar Day Navigation ==========

        // Update the calendar date text display
        function updateCalendarDateText() {
            const dateText = document.getElementById('calendar-date-text');
            const todayBtn = document.getElementById('calendar-today-btn');
            const today = new Date();
            today.setHours(0, 0, 0, 0);

            // Check if currentCalendarDate is today
            const isToday = currentCalendarDate.getTime() === today.getTime();
            if (isToday) {
                dateText.textContent = 'Today';
                todayBtn.classList.remove('visible');
            } else {
                // Format as "Mon, Jan 15"
                const options = { weekday: 'short', month: 'short', day: 'numeric' };
                dateText.textContent = currentCalendarDate.toLocaleDateString('en-US', options);
                todayBtn.classList.add('visible');
            }
        }

        // Jump to today
        function goToToday() {
            const today = new Date();
            today.setHours(0, 0, 0, 0);
            currentCalendarDate = today;
            refreshCalendar();
        }

        // Re-render all calendar content for the current date
        function refreshCalendar() {
            updateCalendarDateText();
            updateNavigationButtons();
            renderCalendarEvents();
            renderTimeBlocks();
            renderScheduledTasks();
            initializeScheduledIcons();
        }

        // Check if we can navigate forward (max 4 days from today)
        function canNavigateForward() {
            const today = new Date();
            today.setHours(0, 0, 0, 0);
            const maxDate = new Date(today);
            maxDate.setDate(maxDate.getDate() + 4);

            const nextDate = new Date(currentCalendarDate);
            nextDate.setDate(nextDate.getDate() + 1);

            return nextDate <= maxDate;
        }

        // Update navigation button states
        function updateNavigationButtons() {
            const nextBtn = document.getElementById('calendar-next-day');
            if (canNavigateForward()) {
                nextBtn.disabled = false;
                nextBtn.style.opacity = '1';
                nextBtn.style.cursor = 'pointer';
            } else {
                nextBtn.disabled = true;
                nextBtn.style.opacity = '0.4';
                nextBtn.style.cursor = 'not-allowed';
            }
        }

        // Navigate to previous day
        function navigateToPreviousDay() {
            currentCalendarDate.setDate(currentCalendarDate.getDate() - 1);
            refreshCalendar();
        }

        // Navigate to next day
        function navigateToNextDay() {
            if (!canNavigateForward()) return;
            currentCalendarDate.setDate(currentCalendarDate.getDate() + 1);
            refreshCalendar();
        }

        // Add event listeners for navigation buttons
        document.getElementById('calendar-prev-day').addEventListener('click', navigateToPreviousDay);
        document.getElementById('calendar-next-day').addEventListener('click', navigateToNextDay);
        document.getElementById('calendar-today-btn').addEventListener('click', goToToday);

        // Initialize navigation button states
        updateNavigationButtons();

        // Initialize today icons on page load
        initializeScheduledIcons();

        // Initialize deadline warning icon on page load
        updateDeadlineWarningIcon();

        // Process abandoned tasks on page load (if enabled)
        processAbandonedTasks();

        // Set up abandoned settings event listeners
        const autoAbandonToggle = document.getElementById('auto-abandon-enabled');
        const abandonedDaysInput = document.getElementById('abandoned-days-input');
        const abandonedDaysRow = document.getElementById('abandoned-days-row');

        if (autoAbandonToggle) {
            autoAbandonToggle.addEventListener('change', function() {
                autoAbandonEnabled = this.checked;
                if (abandonedDaysRow) {
                    abandonedDaysRow.style.opacity = autoAbandonEnabled ? '1' : '0.5';
                }
                const excludeTagsRow = document.getElementById('abandon-exclude-tags-row');
                const excludeStatesRow = document.getElementById('abandon-exclude-states-row');
                if (excludeTagsRow) excludeTagsRow.style.opacity = autoAbandonEnabled ? '1' : '0.5';
                if (excludeStatesRow) excludeStatesRow.style.opacity = autoAbandonEnabled ? '1' : '0.5';
                saveFilterSettings();
                updateDeadlineWarningIcon();
            });
        }

        if (abandonedDaysInput) {
            abandonedDaysInput.addEventListener('change', function() {
                abandonedDays = parseInt(this.value) || 14;
                if (abandonedDays < 1) abandonedDays = 1;
                if (abandonedDays > 365) abandonedDays = 365;
                this.value = abandonedDays;
                saveFilterSettings();
                updateDeadlineWarningIcon();
            });
        }

        // Process calendar sections on page load
        processCalendarSections();

        // ========== Animated Placeholder (Train Board Effect) ==========
        const placeholderPhrases = [
            "Go on then",
            "What's the damage?",
            "Confess",
            "Avoiding something?",
            "Well?",
            "What's haunting you?",
            "Spit it out",
            "Unburden yourself",
            "Running from something?",
            "What are you putting off?",
            "It won't matter in a year",
            "Busy yourself",
            "Does it matter? Maybe",
            "The day demands something"
        ];

        const animatedPlaceholder = document.getElementById('animated-placeholder');
        const newTaskInput = document.getElementById('new-task-input');
        let currentPhraseIndex = -1; // Start with initial text
        let placeholderTimeout = null;
        let placeholderRestartTimer = null;

        function wrapChars(text) {
            return text.split('').map(char =>
                char === ' ' ? '<span class="char">&nbsp;</span>' : `<span class="char">${char}</span>`
            ).join('');
        }

        function animateToPhrase(newPhrase) {
            const chars = animatedPlaceholder.querySelectorAll('.char');
            const newChars = newPhrase.split('');
            const maxLen = Math.max(chars.length, newChars.length);

            // Fade out existing chars with staggered delay
            chars.forEach((char, i) => {
                setTimeout(() => {
                    char.classList.add('fade-out');
                }, i * 80);
            });

            // After all chars faded out, rebuild with new text
            setTimeout(() => {
                animatedPlaceholder.innerHTML = wrapChars(newPhrase);
                const newCharEls = animatedPlaceholder.querySelectorAll('.char');

                // Fade in new chars with staggered delay
                newCharEls.forEach((char, i) => {
                    char.style.opacity = '0';
                    setTimeout(() => {
                        char.classList.add('fade-in');
                    }, i * 80);
                });
            }, chars.length * 80 + 400);
        }

        function getRandomPhraseIndex() {
            let newIndex;
            do {
                newIndex = Math.floor(Math.random() * placeholderPhrases.length);
            } while (newIndex === currentPhraseIndex && placeholderPhrases.length > 1);
            return newIndex;
        }

        function cyclePlaceholder() {
            currentPhraseIndex = getRandomPhraseIndex();
            animateToPhrase(placeholderPhrases[currentPhraseIndex]);
            placeholderTimeout = setTimeout(cyclePlaceholder, 10000);
        }

        function startPlaceholderCycle() {
            // Initial text stays for 10 seconds
            animatedPlaceholder.innerHTML = wrapChars('Add a new task...');
            placeholderTimeout = setTimeout(cyclePlaceholder, 10000);
        }

        function stopPlaceholderCycle() {
            if (placeholderTimeout) {
                clearTimeout(placeholderTimeout);
                placeholderTimeout = null;
            }
        }

        function cancelDelayedRestart() {
            if (placeholderRestartTimer) {
                clearTimeout(placeholderRestartTimer);
                placeholderRestartTimer = null;
            }
        }

        function scheduleDelayedPlaceholderRestart() {
            // Cancel any existing delayed restart
            cancelDelayedRestart();

            // Schedule restart after 10 seconds if input remains empty and unfocused
            placeholderRestartTimer = setTimeout(() => {
                if (!newTaskInput.value && document.activeElement !== newTaskInput) {
                    animatedPlaceholder.classList.remove('hidden');
                    startPlaceholderCycle();
                }
                placeholderRestartTimer = null;
            }, 10000);
        }

        // Show/hide placeholder based on input state
        newTaskInput.addEventListener('input', function() {
            if (this.value) {
                // User is typing - hide placeholder and cancel any delayed restart
                animatedPlaceholder.classList.add('hidden');
                stopPlaceholderCycle();
                cancelDelayedRestart();
            } else {
                // Input is empty - hide placeholder and schedule delayed restart
                animatedPlaceholder.classList.add('hidden');
                stopPlaceholderCycle();
                scheduleDelayedPlaceholderRestart();
            }
        });

        newTaskInput.addEventListener('focus', function() {
            // Cancel delayed restart if user focuses the input
            cancelDelayedRestart();

            // If input is empty and placeholder is hidden, show it immediately
            if (!this.value && animatedPlaceholder.classList.contains('hidden')) {
                animatedPlaceholder.classList.remove('hidden');
                startPlaceholderCycle();
            }
        });

        // Start the animation cycle
        startPlaceholderCycle();

        // Initialize calendar date text
        updateCalendarDateText();

        // Also process after a task is moved to/from calendar
        const originalDropHandler = document.querySelectorAll('.calendar-section');
        originalDropHandler.forEach(section => {
            section.addEventListener('drop', function() {
                setTimeout(processCalendarSections, 100);
            });
        });

        // ========== Task Detail Templates ==========

        let editingTemplateId = null;

        // Render templates list in settings panel
        function renderTemplateList() {
            const list = document.getElementById('template-list');
            if (!list) return;

            if (detailTemplates.length === 0) {
                list.innerHTML = '<div style="color: #6c757d; font-size: 0.8rem; text-align: center; padding: 0.5rem;">No templates yet</div>';
                return;
            }

            list.innerHTML = detailTemplates.map(t => `
                <div class="template-item" data-template-id="${t.id}">
                    <div class="template-item-left">
                        <i class="bi bi-file-text"></i>
                        <span class="template-item-name">${escapeHtml(t.name)}</span>
                        ${t.is_default ? '<span class="template-default-badge">Default</span>' : ''}
                    </div>
                    <div class="template-item-actions">
                        <button class="template-item-btn" onclick="editTemplate(${t.id})" title="Edit">
                            <i class="bi bi-pencil"></i>
                        </button>
                        <button class="template-item-btn delete" onclick="deleteTemplate(${t.id})" title="Delete">
                            <i class="bi bi-trash"></i>
                        </button>
                    </div>
                </div>
            `).join('');
        }

        // Render template dropdown in task panel
        function renderTemplateDropdown() {
            const menu = document.getElementById('template-dropdown-menu');
            if (!menu) return;

            if (detailTemplates.length === 0) {
                menu.innerHTML = `
                    <div class="template-dropdown-header">Load Template</div>
                    <div class="template-dropdown-empty">No templates available</div>
                `;
                return;
            }

            menu.innerHTML = `
                <div class="template-dropdown-header">Load Template</div>
                ${detailTemplates.map(t => `
                    <button class="template-dropdown-item" onclick="loadTemplate(${t.id})">
                        <span>${escapeHtml(t.name)}</span>
                    </button>
                `).join('')}
            `;
        }

        // Helper to escape HTML
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // Reset template modal to edit mode
        function resetTemplateModalToEdit() {
            const contentInput = document.getElementById('template-content-input');
            const contentPreview = document.getElementById('template-content-preview');
            const editBtn = document.getElementById('template-edit-btn');
            const viewBtn = document.getElementById('template-view-btn');
            contentPreview.style.display = 'none';
            contentInput.style.display = 'block';
            editBtn.classList.add('active');
            viewBtn.classList.remove('active');
        }

        // Open template modal for creating new template
        function openNewTemplateModal() {
            editingTemplateId = null;
            document.getElementById('template-modal-title').textContent = 'New Template';
            document.getElementById('template-name-input').value = '';
            document.getElementById('template-content-input').value = '';
            document.getElementById('template-is-default').checked = false;
            resetTemplateModalToEdit();
            document.getElementById('template-modal').classList.add('active');
            document.getElementById('template-name-input').focus();
        }

        // Open template modal for editing existing template
        function editTemplate(templateId) {
            const template = detailTemplates.find(t => t.id === templateId);
            if (!template) return;

            editingTemplateId = templateId;
            document.getElementById('template-modal-title').textContent = 'Edit Template';
            document.getElementById('template-name-input').value = template.name;
            document.getElementById('template-content-input').value = template.content;
            document.getElementById('template-is-default').checked = template.is_default;
            resetTemplateModalToEdit();
            document.getElementById('template-modal').classList.add('active');
            document.getElementById('template-name-input').focus();
        }

        // Close template modal
        function closeTemplateModal() {
            document.getElementById('template-modal').classList.remove('active');
            editingTemplateId = null;
            resetTemplateModalToEdit();
        }

        // Save template (create or update)
        async function saveTemplate() {
            const name = document.getElementById('template-name-input').value.trim();
            const content = document.getElementById('template-content-input').value;
            const isDefault = document.getElementById('template-is-default').checked;

            if (!name) {
                showAlertModal('Please enter a template name.', 'Error');
                return;
            }

            try {
                let response;
                if (editingTemplateId) {
                    // Update existing template
                    response = await fetch(`/tasks/api/templates/${editingTemplateId}/update/`, {
                        method: 'PATCH',
                        headers: {
                            'Content-Type': 'application/json',
                            'X-CSRFToken': csrfToken
                        },
                        body: JSON.stringify({ name, content, is_default: isDefault })
                    });
                } else {
                    // Create new template
                    response = await fetch('/tasks/api/templates/create/', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'X-CSRFToken': csrfToken
                        },
                        body: JSON.stringify({ name, content, is_default: isDefault })
                    });
                }

                const data = await response.json();
                if (data.success) {
                    // Refresh templates from server
                    await refreshTemplates();
                    closeTemplateModal();
                } else {
                    showAlertModal(data.error || 'Failed to save template', 'Error');
                }
            } catch (error) {
                console.error('Error saving template:', error);
                showAlertModal('Failed to save template', 'Error');
            }
        }

        // Delete template
        async function deleteTemplate(templateId) {
            const template = detailTemplates.find(t => t.id === templateId);
            if (!template) return;

            const confirmed = await showConfirmModal(
                `Are you sure you want to delete the template "${template.name}"?`,
                'Delete Template'
            );

            if (!confirmed) return;

            try {
                const response = await fetch(`/tasks/api/templates/${templateId}/delete/`, {
                    method: 'DELETE',
                    headers: {
                        'X-CSRFToken': csrfToken
                    }
                });

                const data = await response.json();
                if (data.success) {
                    await refreshTemplates();
                } else {
                    showAlertModal(data.error || 'Failed to delete template', 'Error');
                }
            } catch (error) {
                console.error('Error deleting template:', error);
                showAlertModal('Failed to delete template', 'Error');
            }
        }

        // Refresh templates from server
        async function refreshTemplates() {
            try {
                const response = await fetch('/tasks/api/templates/');
                const data = await response.json();
                if (data.success) {
                    detailTemplates = data.templates;
                    renderTemplateList();
                    renderTemplateDropdown();
                }
            } catch (error) {
                console.error('Error refreshing templates:', error);
            }
        }

        // Load template into task details
        async function loadTemplate(templateId) {
            const template = detailTemplates.find(t => t.id === templateId);
            if (!template) return;

            const detailsInput = document.getElementById('panel-details');
            const currentContent = detailsInput.value.trim();

            // Close dropdown
            document.getElementById('template-dropdown-menu').classList.remove('show');

            // If there's existing content, ask for confirmation
            if (currentContent) {
                const confirmed = await showConfirmModal(
                    'This will replace the current details. Continue?',
                    'Load Template',
                    'Replace'
                );
                if (!confirmed) return;
            }

            // Load template content
            detailsInput.value = template.content;

            // Update the preview if it's visible (view mode is active)
            if (markdownViewBtn.classList.contains('active')) {
                showMarkdownPreview();
            }

            // Trigger autosave
            if (currentTaskId) {
                clearTimeout(saveTimeout);
                saveTimeout = setTimeout(saveCurrentTask, 500);
            }
        }

        // Toggle template dropdown
        function toggleTemplateDropdown(e) {
            e.stopPropagation();
            const menu = document.getElementById('template-dropdown-menu');
            menu.classList.toggle('show');
        }

        // Close dropdown when clicking outside
        document.addEventListener('click', function(e) {
            const dropdown = document.getElementById('template-dropdown');
            const menu = document.getElementById('template-dropdown-menu');
            if (dropdown && menu && !dropdown.contains(e.target)) {
                menu.classList.remove('show');
            }
        });

        // Template modal event listeners
        document.getElementById('add-template-btn').addEventListener('click', openNewTemplateModal);
        document.getElementById('template-modal-cancel').addEventListener('click', closeTemplateModal);
        document.getElementById('template-modal-save').addEventListener('click', saveTemplate);
        document.getElementById('template-dropdown-btn').addEventListener('click', toggleTemplateDropdown);

        // Close template modal on overlay click
        document.getElementById('template-modal').addEventListener('click', function(e) {
            if (e.target === this) {
                closeTemplateModal();
            }
        });

        // Handle Enter key in template name input
        document.getElementById('template-name-input').addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                e.preventDefault();
                document.getElementById('template-content-input').focus();
            }
        });

        // Template modal Edit/View toggle
        const templateContentInput = document.getElementById('template-content-input');
        const templateContentPreview = document.getElementById('template-content-preview');
        const templateEditBtn = document.getElementById('template-edit-btn');
        const templateViewBtn = document.getElementById('template-view-btn');

        function showTemplatePreview() {
            const text = templateContentInput.value.trim();
            templateContentPreview.innerHTML = text ? marked.parse(text) : '<span style="color: #6c757d; font-style: italic;">No content to preview</span>';
            templateContentInput.style.display = 'none';
            templateContentPreview.style.display = 'block';
            templateEditBtn.classList.remove('active');
            templateViewBtn.classList.add('active');
        }

        function showTemplateEdit() {
            templateContentPreview.style.display = 'none';
            templateContentInput.style.display = 'block';
            templateEditBtn.classList.add('active');
            templateViewBtn.classList.remove('active');
            templateContentInput.focus();
        }

        templateEditBtn.addEventListener('click', showTemplateEdit);
        templateViewBtn.addEventListener('click', showTemplatePreview);

        // Clicking preview switches to edit mode
        templateContentPreview.addEventListener('click', showTemplateEdit);

        // Initialize templates on page load
        renderTemplateList();
        renderTemplateDropdown();

    </script>
</body>
</html>
