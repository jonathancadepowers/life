<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="csrf-token" content="{{ csrf_token }}">
    <title>Tasks</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <link href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.1/font/bootstrap-icons.css" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <style>
        * {
            box-sizing: border-box;
        }

        body {
            background-color: #f8f9fa;
            min-height: 100vh;
            padding-bottom: 2rem;
        }

        .container {
            max-width: 700px;
            padding: 1.5rem;
        }

        .page-header {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 2rem;
        }

        .page-icon {
            font-size: 1.75rem;
            color: #333;
        }

        .page-title {
            font-size: 1.75rem;
            font-weight: 300;
            color: #333;
            margin: 0;
        }

        /* Task Input */
        .task-input-container {
            margin-bottom: 2rem;
        }

        #new-task-input {
            width: 100%;
            font-size: 1.5rem;
            padding: 1rem;
            border: none;
            border-bottom: 2px solid #dee2e6;
            background: transparent;
            outline: none;
            transition: border-color 0.2s;
        }

        #new-task-input:focus {
            border-bottom-color: #0d6efd;
        }

        #new-task-input::placeholder {
            color: #adb5bd;
        }

        /* Task List */
        .task-list {
            list-style: none;
            padding: 0;
            margin: 0;
        }

        .task-item {
            display: flex;
            align-items: flex-start;
            padding: 1rem 0;
            border-bottom: 1px solid #e9ecef;
            cursor: pointer;
            transition: background-color 0.15s;
            margin: 0 -0.5rem;
            padding-left: 0.5rem;
            padding-right: 0.5rem;
            border-radius: 6px;
        }

        .task-item:hover {
            background-color: #f1f3f4;
        }

        .task-item.critical .task-title {
            color: #dc3545;
            font-weight: 500;
        }

        .task-checkbox {
            width: 22px;
            height: 22px;
            border: 2px solid #adb5bd;
            border-radius: 50%;
            margin-right: 1rem;
            flex-shrink: 0;
            cursor: pointer;
            transition: all 0.15s;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-top: 2px;
        }

        .task-checkbox:hover {
            border-color: #0d6efd;
            background-color: rgba(13, 110, 253, 0.1);
        }

        .task-content {
            flex: 1;
            min-width: 0;
        }

        .task-title {
            font-size: 1.1rem;
            color: #212529;
            word-wrap: break-word;
        }

        .task-details-preview {
            font-size: 0.875rem;
            color: #6c757d;
            margin-top: 0.25rem;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }


        /* Slide-out Panel */
        .panel-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(0, 0, 0, 0.3);
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s, visibility 0.3s;
            z-index: 1000;
        }

        .panel-overlay.active {
            opacity: 1;
            visibility: visible;
        }

        /* Modal styles */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            z-index: 2000;
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.2s, visibility 0.2s;
        }

        .modal-overlay.active {
            opacity: 1;
            visibility: visible;
        }

        .modal-content {
            background: white;
            border-radius: 12px;
            padding: 1.5rem;
            max-width: 400px;
            width: 90%;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.2);
        }

        .modal-title {
            font-size: 1.1rem;
            font-weight: 600;
            margin-bottom: 0.75rem;
            color: #333;
        }

        .modal-body {
            font-size: 0.9rem;
            color: #555;
            margin-bottom: 1rem;
        }

        .modal-select {
            width: 100%;
            padding: 0.5rem;
            border: 1px solid #ddd;
            border-radius: 6px;
            font-size: 0.9rem;
            margin-bottom: 1rem;
        }

        .modal-input {
            width: 100%;
            padding: 0.5rem;
            border: 1px solid #ddd;
            border-radius: 6px;
            font-size: 0.9rem;
            margin-bottom: 1rem;
            box-sizing: border-box;
        }

        .modal-input:focus {
            outline: none;
            border-color: #6B9080;
            box-shadow: 0 0 0 2px rgba(107, 144, 128, 0.2);
        }

        .modal-buttons {
            display: flex;
            justify-content: flex-end;
            gap: 0.5rem;
        }

        .modal-btn {
            padding: 0.5rem 1rem;
            border: none;
            border-radius: 6px;
            font-size: 0.85rem;
            cursor: pointer;
            transition: background 0.15s;
        }

        .modal-btn-cancel {
            background: #e9ecef;
            color: #333;
        }

        .modal-btn-cancel:hover {
            background: #dde0e3;
        }

        .modal-btn-danger {
            background: #dc3545;
            color: white;
        }

        .modal-btn-danger:hover {
            background: #c82333;
        }

        .modal-btn-primary {
            background: #6B9080;
            color: white;
        }

        .modal-btn-primary:hover {
            background: #5a7d6e;
        }

        .slide-panel {
            position: fixed;
            top: 0;
            right: 0;
            width: 100%;
            max-width: 400px;
            height: 100%;
            background: white;
            box-shadow: -4px 0 20px rgba(0, 0, 0, 0.15);
            transform: translateX(100%);
            transition: transform 0.3s ease;
            z-index: 1001;
            display: flex;
            flex-direction: column;
        }

        .slide-panel.active {
            transform: translateX(0);
        }

        .panel-header {
            padding: 1.25rem;
            border-bottom: 1px solid #e9ecef;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .panel-close {
            background: none;
            border: none;
            font-size: 1.5rem;
            color: #6c757d;
            cursor: pointer;
            padding: 0;
            line-height: 1;
        }

        .panel-close:hover {
            color: #212529;
        }

        .panel-body {
            flex: 1;
            padding: 1.25rem;
            overflow-y: auto;
        }

        .panel-title-input {
            width: 100%;
            font-size: 1.25rem;
            font-weight: 500;
            border: none;
            padding: 0.5rem 0;
            margin-bottom: 1rem;
            outline: none;
            border-bottom: 1px solid transparent;
            resize: none;
            overflow: hidden;
            min-height: 2rem;
            font-family: inherit;
            line-height: 1.4;
        }

        .panel-title-input:focus {
            border-bottom-color: #0d6efd;
        }

        .panel-details-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 0.5rem;
        }

        .panel-details-label {
            font-size: 0.875rem;
            color: #6c757d;
        }

        .markdown-mode-toggle {
            display: flex;
            background: #e9ecef;
            border-radius: 4px;
            overflow: hidden;
            font-size: 0.75rem;
        }

        .markdown-mode-btn {
            padding: 0.25rem 0.5rem;
            border: none;
            background: transparent;
            cursor: pointer;
            color: #6c757d;
            transition: all 0.2s;
        }

        .markdown-mode-btn.active {
            background: #0d6efd;
            color: white;
        }

        .markdown-mode-btn:hover:not(.active) {
            background: #dee2e6;
        }

        .panel-details-container {
            position: relative;
        }

        .panel-details-input {
            width: 100%;
            min-height: 450px;
            border: 1px solid #dee2e6;
            border-radius: 8px;
            padding: 0.75rem;
            font-size: 1rem;
            resize: vertical;
            outline: none;
            font-family: inherit;
        }

        .panel-details-input:focus {
            border-color: #0d6efd;
        }

        .panel-details-preview {
            width: 100%;
            min-height: 450px;
            border: 1px solid #dee2e6;
            border-radius: 8px;
            padding: 0.75rem;
            font-size: 1rem;
            background: #fafbfc;
            cursor: text;
            overflow-y: auto;
        }

        .panel-details-preview:empty::before {
            content: 'Add details...';
            color: #6c757d;
        }

        .panel-details-preview h1,
        .panel-details-preview h2,
        .panel-details-preview h3 {
            margin-top: 0.5rem;
            margin-bottom: 0.5rem;
        }

        .panel-details-preview h1 { font-size: 1.5rem; }
        .panel-details-preview h2 { font-size: 1.25rem; }
        .panel-details-preview h3 { font-size: 1.1rem; }

        .panel-details-preview p {
            margin-bottom: 0.5rem;
        }

        .panel-details-preview ul,
        .panel-details-preview ol {
            margin-bottom: 0.5rem;
            padding-left: 1.5rem;
        }

        .panel-details-preview code {
            background: #e9ecef;
            padding: 0.1rem 0.3rem;
            border-radius: 3px;
            font-size: 0.9em;
        }

        .panel-details-preview pre {
            background: #e9ecef;
            padding: 0.75rem;
            border-radius: 6px;
            overflow-x: auto;
        }

        .panel-details-preview pre code {
            background: none;
            padding: 0;
        }

        .panel-details-preview blockquote {
            border-left: 3px solid #dee2e6;
            padding-left: 0.75rem;
            margin-left: 0;
            color: #6c757d;
        }

        .panel-details-preview a {
            color: #0d6efd;
        }

        .panel-footer {
            padding: 1rem 1.25rem;
            border-top: 1px solid #e9ecef;
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 1rem;
        }

        .critical-toggle {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            cursor: pointer;
            user-select: none;
        }

        .critical-toggle input {
            width: 18px;
            height: 18px;
            cursor: pointer;
        }

        .critical-toggle label {
            cursor: pointer;
            font-weight: 500;
        }

        .mark-done-btn {
            background: #28a745;
            color: white;
            border: none;
            padding: 0.4rem 0.75rem;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.85rem;
            font-weight: 500;
            display: flex;
            align-items: center;
            gap: 0.35rem;
        }

        .mark-done-btn:hover {
            background: #218838;
        }

        .mark-done-btn.is-done {
            background: #6c757d;
        }

        .mark-done-btn.is-done:hover {
            background: #5a6268;
        }

        .delete-btn {
            background: none;
            border: none;
            color: #6c757d;
            cursor: pointer;
            padding: 0.5rem;
            font-size: 1.25rem;
        }

        .delete-btn:hover {
            color: #dc3545;
        }

        /* Empty state */
        .empty-state {
            text-align: center;
            padding: 3rem 1rem;
            color: #6c757d;
        }

        .empty-state i {
            font-size: 3rem;
            margin-bottom: 1rem;
            opacity: 0.5;
        }

        /* Sidebar icons */
        .sidebar-icons {
            position: fixed;
            top: 1.5rem;
            left: 1.5rem;
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
            z-index: 100;
        }

        .sidebar-icon {
            color: #adb5bd;
            cursor: pointer;
            font-size: 1.25rem;
            transition: color 0.2s;
        }

        .sidebar-icon:hover {
            color: #6c757d;
        }

        .sidebar-icon.active {
            color: #6B9080;
        }

        /* Filter dropdown */
        .filter-dropdown {
            position: fixed;
            top: 1.5rem;
            left: 3.5rem;
            background: white;
            border-radius: 8px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.15);
            padding: 1rem;
            min-width: 220px;
            z-index: 1100;
            display: none;
        }

        .filter-dropdown.active {
            display: block;
        }

        .filter-section {
            margin-bottom: 1rem;
        }

        .filter-section:last-child {
            margin-bottom: 0;
        }

        .filter-section-title {
            font-size: 0.75rem;
            font-weight: 600;
            color: #6c757d;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            margin-bottom: 0.5rem;
        }

        .filter-option {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.35rem 0;
            cursor: pointer;
            font-size: 0.9rem;
            color: #333;
        }

        .filter-option:hover {
            color: #6B9080;
        }

        .filter-option input[type="checkbox"] {
            width: 16px;
            height: 16px;
            cursor: pointer;
            accent-color: #6B9080;
        }

        .filter-option .context-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            flex-shrink: 0;
        }

        .filter-clear {
            width: 100%;
            padding: 0.5rem;
            margin-top: 0.5rem;
            border: 1px solid #dee2e6;
            background: white;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.8rem;
            color: #6c757d;
            transition: all 0.15s;
        }

        .filter-clear:hover {
            background: #f8f9fa;
            border-color: #6B9080;
            color: #6B9080;
        }

        .filter-badge {
            position: absolute;
            top: -4px;
            right: -4px;
            background: #6B9080;
            color: white;
            font-size: 0.65rem;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        /* Left slide-out panel for contexts */
        .context-panel {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            max-width: 320px;
            height: 100%;
            background: white;
            box-shadow: 4px 0 20px rgba(0, 0, 0, 0.15);
            transform: translateX(-100%);
            transition: transform 0.3s ease;
            z-index: 1001;
            display: flex;
            flex-direction: column;
        }

        .context-panel.active {
            transform: translateX(0);
        }

        .context-list {
            list-style: none;
            padding: 0;
            margin: 0;
        }

        .context-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0.75rem 1.25rem;
            border-bottom: 1px solid #e9ecef;
        }

        .context-item:hover {
            background-color: #f8f9fa;
        }

        .context-name {
            font-size: 1rem;
            cursor: pointer;
            padding: 0.125rem 0.25rem;
            border-radius: 4px;
            transition: background 0.15s;
        }

        .context-name:hover {
            background: #e9ecef;
        }

        .context-name-input {
            font-size: 1rem;
            padding: 0.125rem 0.25rem;
            border: 1px solid #6B9080;
            border-radius: 4px;
            outline: none;
            width: 120px;
        }

        .context-delete {
            background: none;
            border: none;
            color: #adb5bd;
            cursor: pointer;
            padding: 0.25rem;
            font-size: 1rem;
            opacity: 0;
            transition: opacity 0.15s, color 0.15s;
        }

        .context-item:hover .context-delete {
            opacity: 1;
        }

        .context-delete:hover {
            color: #dc3545;
        }

        .context-input-container {
            padding: 1rem 1.25rem;
            border-bottom: 1px solid #e9ecef;
        }

        #new-context-input {
            width: 100%;
            padding: 0.5rem 0.75rem;
            border: 1px solid #dee2e6;
            border-radius: 6px;
            font-size: 0.95rem;
            outline: none;
        }

        #new-context-input:focus {
            border-color: #0d6efd;
        }

        /* Context dropdown in task panel */
        .panel-context-label {
            font-size: 0.875rem;
            color: #6c757d;
            margin-top: 1rem;
            margin-bottom: 0.5rem;
        }

        #panel-context {
            width: 100%;
            padding: 0.5rem 0.75rem;
            border: 1px solid #dee2e6;
            border-radius: 6px;
            font-size: 1rem;
            background: white;
            outline: none;
        }

        #panel-context:focus {
            border-color: #0d6efd;
        }

        /* Context badge on task item */
        .task-context-badge {
            font-size: 0.75rem;
            color: white;
            background: #6c757d;
            padding: 0.125rem 0.5rem;
            border-radius: 4px;
            margin-left: 0.5rem;
        }

        /* Context color indicator */
        .context-color-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 0.5rem;
            flex-shrink: 0;
        }

        .context-item-left {
            display: flex;
            align-items: center;
        }

        /* Settings section headers */
        .settings-section-header {
            font-size: 0.75rem;
            font-weight: 600;
            color: #6c757d;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            padding: 1rem 1.25rem 0.5rem;
            background: #f8f9fa;
        }

        .settings-section {
            border-bottom: 1px solid #e9ecef;
        }

        .settings-section:last-child {
            border-bottom: none;
        }

        /* State list styles */
        .state-list {
            list-style: none;
            padding: 0;
            margin: 0;
        }

        .state-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0.75rem 1.25rem;
            border-bottom: 1px solid #e9ecef;
        }

        .state-item:last-child {
            border-bottom: none;
        }

        .state-item:hover {
            background-color: #f8f9fa;
        }

        .state-name {
            font-size: 1rem;
            cursor: pointer;
            padding: 0.125rem 0.25rem;
            border-radius: 4px;
            transition: background 0.15s;
        }

        .state-name:hover {
            background: #e9ecef;
        }

        .state-name.no-edit {
            cursor: default;
        }

        .state-name.no-edit:hover {
            background: transparent;
        }

        .state-name-input {
            font-size: 1rem;
            padding: 0.125rem 0.25rem;
            border: 1px solid #6B9080;
            border-radius: 4px;
            outline: none;
            width: 100px;
        }

        .state-delete {
            background: none;
            border: none;
            color: #adb5bd;
            cursor: pointer;
            padding: 0.25rem;
            font-size: 1rem;
            opacity: 0;
            transition: opacity 0.15s, color 0.15s;
        }

        .state-item:hover .state-delete {
            opacity: 1;
        }

        .state-delete:hover {
            color: #dc3545;
        }

        .state-icon-btn {
            background: none;
            border: 1px solid #dee2e6;
            border-radius: 4px;
            color: #6c757d;
            cursor: pointer;
            padding: 0.25rem 0.4rem;
            font-size: 0.875rem;
            transition: all 0.15s;
        }

        .state-icon-btn:hover {
            border-color: #6B9080;
            color: #6B9080;
        }

        .state-icon-btn i.bi-plus-circle-dotted {
            opacity: 0.5;
        }

        .icon-picker-popup {
            position: fixed;
            background: white;
            border-radius: 8px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.2);
            padding: 0.75rem;
            z-index: 1200;
            max-width: 280px;
            max-height: 300px;
            overflow-y: auto;
        }

        .icon-picker-grid {
            display: grid;
            grid-template-columns: repeat(6, 1fr);
            gap: 0.25rem;
        }

        .icon-picker-item {
            width: 36px;
            height: 36px;
            display: flex;
            align-items: center;
            justify-content: center;
            border: none;
            background: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 1.1rem;
            color: #333;
            transition: background 0.15s;
        }

        .icon-picker-item:hover {
            background: #e9ecef;
        }

        .icon-picker-item.selected {
            background: #6B9080;
            color: white;
        }

        .icon-picker-clear {
            width: 100%;
            padding: 0.5rem;
            margin-top: 0.5rem;
            border: 1px solid #dee2e6;
            background: white;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.8rem;
            color: #6c757d;
        }

        .icon-picker-clear:hover {
            background: #f8f9fa;
        }

        .icon-picker-custom {
            display: flex;
            gap: 0.5rem;
            margin-bottom: 0.75rem;
            padding-bottom: 0.75rem;
            border-bottom: 1px solid #e9ecef;
        }

        .icon-picker-custom input {
            flex: 1;
            padding: 0.4rem 0.6rem;
            border: 1px solid #dee2e6;
            border-radius: 4px;
            font-size: 0.85rem;
            outline: none;
        }

        .icon-picker-custom input:focus {
            border-color: #6B9080;
        }

        .icon-picker-custom button {
            padding: 0.4rem 0.75rem;
            background: #6B9080;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.85rem;
        }

        .icon-picker-custom button:hover {
            background: #5a7a6c;
        }

        .state-input-container {
            padding: 0.75rem 1.25rem;
        }

        #new-state-input {
            width: 100%;
            padding: 0.5rem 0.75rem;
            border: 1px solid #dee2e6;
            border-radius: 6px;
            font-size: 0.95rem;
            outline: none;
        }

        #new-state-input:focus {
            border-color: #0d6efd;
        }

        .state-item-left {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .state-item-right {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .state-drag-handle {
            cursor: grab;
            color: #adb5bd;
            padding: 0.25rem;
            margin-right: 0.25rem;
        }

        .state-drag-handle:hover {
            color: #6c757d;
        }

        .state-item.dragging {
            opacity: 0.5;
            background: #e9ecef;
        }

        .state-item.drag-over-top {
            border-top: 2px solid #6B9080;
            margin-top: -1px;
        }

        .state-item.drag-over-bottom {
            border-bottom: 2px solid #6B9080;
            margin-bottom: -1px;
        }

        .state-list.drag-over-bottom {
            border-bottom: 2px solid #6B9080;
            padding-bottom: 8px;
        }

        .terminal-state .state-group-body {
            padding-top: 0.25rem;
        }

        .delete-completed-link {
            font-size: 0.65rem;
            color: #999;
            cursor: pointer;
            text-align: right;
            padding: 0 0.5rem 0.25rem 0;
        }

        .delete-completed-link:hover {
            color: #dc3545;
        }

        /* Panel header right container */
        .panel-header-right {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-left: auto;
        }

        /* Inline completed toggle in panel header */
        .completed-toggle-inline {
            display: none;
            align-items: center;
            gap: 0.5rem;
            cursor: pointer;
            user-select: none;
            margin-right: 0.75rem;
            font-size: 0.7rem;
            color: #6c757d;
        }

        .completed-toggle-inline.visible {
            display: flex;
        }

        .completed-toggle-inline input[type="checkbox"] {
            display: none;
        }

        .toggle-label-inline {
            white-space: nowrap;
        }

        .toggle-switch {
            width: 32px;
            height: 18px;
            background: #ccc;
            border-radius: 9px;
            position: relative;
            transition: background 0.2s;
            flex-shrink: 0;
        }

        .toggle-switch::after {
            content: '';
            position: absolute;
            width: 14px;
            height: 14px;
            background: white;
            border-radius: 50%;
            top: 2px;
            left: 2px;
            transition: transform 0.2s;
        }

        .completed-toggle-inline input:checked + .toggle-switch {
            background: #0d6efd;
        }

        .completed-toggle-inline input:checked + .toggle-switch::after {
            transform: translateX(14px);
        }

        .tasks-panel-wrapper {
            display: flex;
            flex-direction: column;
            flex: 1;
            min-width: 300px;
            height: 100%;
        }

        .tasks-panel-wrapper.panel-minimized {
            flex: 0 0 60px;
            min-width: 60px;
        }

        .tasks-panel-wrapper.panel-minimized .completed-toggle-inline {
            display: none !important;
        }

        .state-terminal-checkbox-wrapper.disabled-terminal {
            cursor: help;
        }

        .state-terminal-checkbox-wrapper.disabled-terminal::after {
            content: attr(data-tooltip);
            position: absolute;
            left: 100%;
            top: 50%;
            transform: translateY(-50%);
            background: #333;
            color: white;
            padding: 0.4rem 0.6rem;
            border-radius: 4px;
            font-size: 0.75rem;
            white-space: nowrap;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.2s, visibility 0.2s;
            z-index: 1200;
            margin-left: 8px;
        }

        .state-terminal-checkbox-wrapper.disabled-terminal:hover::after {
            opacity: 1;
            visibility: visible;
        }

        /* Mobile adjustments */
        @media (max-width: 576px) {
            .container {
                padding: 1rem;
            }

            h1 {
                font-size: 1.5rem;
                margin-bottom: 1.5rem;
            }

            #new-task-input {
                font-size: 1.25rem;
                padding: 0.75rem 0;
            }

            .slide-panel {
                max-width: 100%;
            }

            .context-panel {
                max-width: 100%;
            }

            .settings-gear {
                top: 1rem;
                left: 1rem;
            }

            .task-title {
                font-size: 1rem;
            }

            .kanban-board {
                flex-direction: column;
                gap: 1rem;
            }

            .kanban-column {
                min-width: 100%;
                max-height: 300px;
            }
        }

        /* Section Headers */
        .section-container {
            max-width: 1800px;
            margin: 0.25rem auto;
        }

        .section-container:first-of-type {
            margin-top: 2rem;
        }

        .section-header {
            padding: 0 3rem 0.5rem;
        }

        .section-title {
            font-size: 1.5rem;
            font-weight: 600;
            color: #2c3e50;
            margin: 0;
            letter-spacing: -0.5px;
        }

        /* Kanban Board */
        .kanban-container {
            max-width: 1800px;
            margin: 0 auto;
            padding: 0 3rem 0.5rem;
        }

        .kanban-board {
            display: flex;
            gap: 1.25rem;
            overflow-x: auto;
            padding-bottom: 0.5rem;
        }

        .kanban-column {
            flex: 1;
            min-width: 200px;
            background: #fff;
            border-radius: 8px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            display: flex;
            flex-direction: column;
        }

        .kanban-column-header {
            padding: 0.75rem 1rem;
            font-weight: 500;
            font-size: 0.875rem;
            color: #333;
            border-bottom: 1px solid #e9ecef;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .kanban-column-count {
            background: #e9ecef;
            color: #6c757d;
            font-size: 0.75rem;
            padding: 0.125rem 0.5rem;
            border-radius: 10px;
        }

        .kanban-column-body {
            padding: 0.5rem;
            flex: 1;
            overflow-y: auto;
            min-height: 100px;
            max-height: 190px;
        }

        .kanban-column-body.drag-over {
            background: #f0f7f4;
        }

        .kanban-card {
            background: #f8f9fa;
            border: 1px solid #e9ecef;
            border-radius: 6px;
            padding: 0.625rem 0.75rem;
            margin-bottom: 0.5rem;
            cursor: grab;
            transition: box-shadow 0.15s, transform 0.15s;
            position: relative;
            height: 50px;
            display: flex;
            flex-direction: column;
            justify-content: center;
        }

        .kanban-card:hover {
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .kanban-card.dragging {
            opacity: 0.5;
            transform: rotate(2deg);
        }

        .kanban-card-title {
            font-size: 0.9rem;
            color: #212529;
            margin-bottom: 0;
            padding-right: 1.5rem;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .kanban-card.critical {
            background: #fff5f5;
            border-color: #f8d7da;
        }

        .kanban-card.critical:hover {
            background: #ffecec;
        }

        .kanban-card-meta {
            display: none;
        }

        .kanban-card-context {
            font-size: 0.7rem;
            color: white;
            padding: 0.1rem 0.4rem;
            border-radius: 3px;
        }

        .kanban-empty {
            color: #adb5bd;
            font-size: 0.8rem;
            text-align: center;
            padding: 1rem;
            font-style: italic;
        }

        /* Calendar (Today View) */
        .calendar-container {
            max-width: 1800px;
            margin: 0 auto;
            padding: 0 3rem 1rem;
        }

        .calendar-board {
            display: flex;
            gap: 1rem;
        }

        .calendar-box {
            flex: 1;
            min-width: 200px;
            background: #fff;
            border-radius: 8px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            display: flex;
            flex-direction: column;
        }


        .calendar-box-header {
            padding: 0.75rem 1rem;
            font-weight: 500;
            font-size: 0.875rem;
            color: #333;
            border-bottom: 1px solid #e9ecef;
        }

        .calendar-box-title {
            font-weight: 500;
            font-size: 0.875rem;
            color: #333;
        }

        .calendar-box-body {
            flex: 1;
            overflow-y: auto;
            min-height: 100px;
            max-height: 400px;
            display: flex;
            flex-direction: row;
        }

        .calendar-label-column {
            background: #f8f9fa;
            min-width: 56px;
            display: flex;
            flex-direction: column;
            flex-shrink: 0;
        }

        .calendar-label-column .calendar-time-label {
            font-size: 0.75rem;
            color: #6c757d;
            text-align: left;
            padding: 1.25rem 0.5rem;
            border-bottom: 1px solid #e0e0e0;
            flex: 1;
            display: flex;
            align-items: center;
        }

        .calendar-label-column .calendar-time-label:last-child {
            border-bottom: none;
        }

        .calendar-content-column {
            flex: 1;
            display: flex;
            flex-direction: column;
        }

        .calendar-content-column .calendar-section {
            padding: 0.5rem;
            border-bottom: 1px solid #e9ecef;
            min-height: 60px;
            flex: 1;
            display: flex;
            align-items: center;
        }

        .calendar-content-column .calendar-section:last-child {
            border-bottom: none;
        }

        .calendar-section-content {
            width: 100%;
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
            align-items: center;
        }

        .calendar-task-count {
            background: #f8f9fa;
            border: 1px solid #e9ecef;
            border-radius: 6px;
            padding: 0.625rem 0.75rem;
            cursor: pointer;
            transition: box-shadow 0.15s;
            height: 50px;
            display: flex;
            align-items: center;
            font-size: 0.9rem;
            color: #495057;
        }

        .calendar-task-count:hover {
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .calendar-section-content .kanban-card {
            margin-bottom: 0;
        }

        /* Right slide-out panel for time slot tasks */
        .timeslot-panel {
            position: fixed;
            top: 0;
            right: 0;
            width: 100%;
            max-width: 400px;
            height: 100%;
            background: white;
            box-shadow: -4px 0 20px rgba(0, 0, 0, 0.15);
            transform: translateX(100%);
            transition: transform 0.3s ease;
            z-index: 1001;
            display: flex;
            flex-direction: column;
        }

        .timeslot-panel.active {
            transform: translateX(0);
        }

        .timeslot-panel-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s ease, visibility 0.3s ease;
            z-index: 1000;
        }

        .timeslot-panel-overlay.active {
            opacity: 1;
            visibility: visible;
        }

        .timeslot-task-list {
            flex: 1;
            overflow-y: auto;
            padding: 1rem;
        }

        .timeslot-task-item {
            background: #f8f9fa;
            border: 1px solid #e9ecef;
            border-radius: 6px;
            padding: 0.75rem;
            margin-bottom: 0.75rem;
            cursor: grab;
            transition: box-shadow 0.15s;
            position: relative;
        }

        .timeslot-task-item:active {
            cursor: grabbing;
        }

        .timeslot-task-item:hover {
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .timeslot-task-item.dragging {
            opacity: 0.5;
        }

        .timeslot-task-title {
            font-size: 0.95rem;
            color: #212529;
            margin-bottom: 0.25rem;
        }

        .timeslot-task-meta {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .timeslot-task-context {
            font-size: 0.7rem;
            color: white;
            padding: 0.1rem 0.4rem;
            border-radius: 3px;
        }

        .calendar-content-column .calendar-section.drag-over {
            background: #f0f7f4;
        }

        /* ========== Two-Panel Layout ========== */
        .two-panel-container {
            max-width: 1800px;
            margin: 0 auto;
            padding: 0 2rem 2rem;
        }

        .panels-wrapper {
            display: flex;
            gap: 1rem;
            align-items: stretch;
        }

        .panel {
            background: white;
            border: 1px solid #dee2e6;
            border-radius: 8px;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            transition: height 0.3s ease;
            position: relative;
            flex: 1;
            min-width: 300px;
            min-height: 870px;
        }

        .panel.collapsed {
            height: 48px;
            min-height: 48px;
            max-height: 48px;
            overflow: hidden;
            box-sizing: border-box;
        }

        .panel.collapsed .panel-content {
            display: none;
        }

        .panel-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0.75rem 1rem;
            border-bottom: 1px solid #e9ecef;
            background: #fafafa;
            min-height: 48px;
        }

        .panel-header-left {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .panel-header-title {
            font-weight: 600;
            font-size: 0.8rem;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            color: #495057;
        }

        .panel-collapse-btn {
            background: none;
            border: none;
            color: #6c757d;
            cursor: pointer;
            padding: 0.25rem;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: color 0.15s, transform 0.3s;
            font-size: 1rem;
        }

        .panel-collapse-btn:hover {
            color: #495057;
        }

        .panel.collapsed .panel-collapse-btn {
            transform: rotate(180deg);
        }

        .panel-content {
            flex: 1;
            overflow-y: auto;
            padding: 1rem;
        }

        .panel-header-vertical {
            display: none;
        }

        .panel.collapsed .panel-header {
            border-bottom: none;
            height: 46px;
            min-height: 46px;
            max-height: 46px;
            box-sizing: border-box;
        }

        /* Collapsed panel metrics */
        .panel-collapsed-metrics {
            display: none;
            flex-wrap: wrap;
            gap: 0.5rem;
            margin-right: 0.5rem;
            justify-content: flex-end;
        }

        .panel.collapsed .panel-collapsed-metrics {
            display: flex;
        }

        /* Hide expand button when panel is vertically collapsed */
        .panel.collapsed .panel-expand-btn {
            display: none;
        }

        .metric-pill {
            background: #e9ecef;
            color: #495057;
            font-size: 0.75rem;
            padding: 0.25rem 0.6rem;
            border-radius: 12px;
            white-space: nowrap;
        }

        .metric-pill .metric-count,
        .metric-pill #meetings-count,
        .metric-pill #meetings-time {
            font-weight: 600;
        }

        /* Block Time button - only visible when Calendar is expanded */
        .add-event-btn {
            display: none;
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            color: #495057;
            cursor: pointer;
            padding: 0.25rem 0.5rem;
            border-radius: 4px;
            font-size: 0.75rem;
            font-weight: 500;
            align-items: center;
            gap: 0.25rem;
            margin-right: 0.5rem;
            transition: all 0.15s;
        }

        .add-event-btn:hover {
            background: #e9ecef;
            border-color: #ced4da;
        }

        /* Show when horizontally expanded OR vertically expanded (not collapsed) */
        .calendar-panel.expanded .add-event-btn,
        .calendar-panel:not(.collapsed):not(.minimized) .add-event-btn {
            display: flex;
        }

        /* Panel expand button */
        .panel-expand-btn {
            background: none;
            border: none;
            color: #6c757d;
            cursor: pointer;
            padding: 0.25rem;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: color 0.15s;
            font-size: 1rem;
            margin-left: auto;
            margin-right: 0.5rem;
        }

        .panel-expand-btn:hover {
            color: #495057;
        }

        .panel.expanded .panel-expand-btn i {
            transform: rotate(180deg);
        }

        /* Hide vertical collapse button when horizontally expanded */
        .panel.expanded .panel-collapse-btn {
            display: none;
        }

        /* Horizontal expansion states */
        .panel.expanded {
            flex: 4;
        }

        .panel.minimized {
            flex: 0 0 60px;
            min-width: 60px;
        }

        .panel.minimized .panel-content {
            display: none;
        }

        .panel.minimized .panel-header {
            flex-direction: column;
            padding: 0.75rem 0.5rem;
            height: 100%;
        }

        .panel.minimized .panel-header-left {
            writing-mode: vertical-rl;
            text-orientation: mixed;
            transform: rotate(180deg);
        }

        .panel.minimized .panel-collapsed-metrics {
            display: none;
        }

        .panel.minimized .panel-expand-btn {
            margin: 0;
            margin-bottom: 0.5rem;
        }

        .panel.minimized .panel-collapse-btn {
            display: none;
        }

        .panel.minimized .panel-header-right {
            width: 100%;
            justify-content: center;
        }

        /* Tasks Panel - State Groups */
        .state-group {
            margin-bottom: 1.5rem;
        }

        .state-group:last-child {
            margin-bottom: 0;
        }

        .state-group-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0.75rem 1rem;
            cursor: pointer;
            background: #fafbfc;
            border: 1px solid #e9ecef;
            border-left: 3px solid #6B9080;
            border-radius: 6px;
            transition: all 0.15s;
            user-select: none;
        }

        .state-group-header:hover {
            background: #f5f7f8;
            border-color: #dee2e6;
        }

        .state-group.collapsed .state-group-header {
            background: #fdfdfd;
            border-left-color: #cbd5e0;
        }

        .state-group-header.drag-hover {
            background: #f0f7f4;
            border-left-color: #6B9080;
            border-color: #6B9080;
        }

        .state-group:not(.collapsed) .state-group-header {
            border-bottom-left-radius: 0;
            border-bottom-right-radius: 0;
        }

        .state-group-left {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .state-group-icon {
            color: #495057;
            font-size: 1rem;
        }

        .state-group-name {
            font-weight: 600;
            font-size: 0.85rem;
            color: #2c3e50;
            text-transform: uppercase;
            letter-spacing: 0.03em;
        }

        .state-group-right {
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }

        .state-group-count {
            background: #e9ecef;
            color: #6c757d;
            font-size: 0.7rem;
            padding: 0.125rem 0.4rem;
            border-radius: 10px;
        }

        .state-group-toggle {
            color: #6c757d;
            font-size: 0.875rem;
            transition: transform 0.2s;
        }

        .state-group.collapsed .state-group-toggle {
            transform: rotate(-90deg);
        }

        .state-group-body {
            padding: 0.9rem 0.5rem;
            background: white;
            border: 1px solid #e9ecef;
            border-top: none;
            border-bottom-left-radius: 6px;
            border-bottom-right-radius: 6px;
            min-height: 40px;
            max-height: 220px;
            overflow-y: auto;
            transition: background 0.15s;
        }

        .state-group-body.drag-over {
            background: #f0f7f4;
        }

        .state-group-header.drag-over {
            background: #e8f4ea;
        }

        .state-group.collapsed .state-group-body {
            display: none;
        }

        .task-card {
            background: #fafbfc;
            border: 1px solid #eef0f2;
            border-radius: 4px;
            padding: 0.4rem 0.6rem;
            margin-bottom: 0.7rem;
            cursor: grab;
            transition: background 0.15s, box-shadow 0.15s, opacity 0.15s;
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 0.5rem;
        }

        .task-card:last-child {
            margin-bottom: 0;
        }

        .task-card:hover {
            background: #f0f7f4;
            border-color: #d0e0d8;
        }

        .task-card.dragging {
            opacity: 0.5;
            cursor: grabbing;
        }

        .task-card.drag-over {
            border-color: #6B9080;
            box-shadow: 0 0 0 1px #6B9080;
        }
        }

        .task-card:last-child {
            margin-bottom: 0;
        }

        .task-card-title {
            font-size: 0.8rem;
            color: #333;
            margin-bottom: 0;
            flex: 1;
            min-width: 0;
        }

        .task-card.critical {
            /* Critical tasks use icon instead of red background */
        }

        .task-card.critical:hover {
            background: #e8e8e8;
        }

        .panel-header-icon {
            font-size: 1rem;
            opacity: 0.7;
        }

        .task-card-icons {
            display: flex;
            align-items: center;
            gap: 0.25rem;
            flex-shrink: 0;
            margin-left: auto;
        }

        .task-critical-icon {
            color: #dc3545;
            font-size: 0.85rem;
            flex-shrink: 0;
        }

        .task-card.completed .task-card-title {
            text-decoration: line-through;
            color: #6c757d;
        }

        .task-card.highlight-new {
            animation: highlightGlow 4.5s ease-out;
        }

        @keyframes highlightGlow {
            0% {
                background: #fff9c4;
                box-shadow: 0 0 8px rgba(255, 235, 59, 0.6);
            }
            44% {
                background: #fff9c4;
                box-shadow: 0 0 8px rgba(255, 235, 59, 0.6);
            }
            100% {
                background: #fafbfc;
                box-shadow: none;
            }
        }

        .task-card.critical.highlight-new {
            animation: highlightGlowCritical 4.5s ease-out;
        }

        @keyframes highlightGlowCritical {
            0% {
                background: #fff9c4;
                box-shadow: 0 0 8px rgba(255, 235, 59, 0.6);
            }
            44% {
                background: #fff9c4;
                box-shadow: 0 0 8px rgba(255, 235, 59, 0.6);
            }
            100% {
                background: #fff5f5;
                box-shadow: none;
            }
        }

        .task-card-meta {
            display: none;
        }

        .task-card-context {
            font-size: 0.65rem;
            color: white;
            padding: 0.1rem 0.4rem;
            border-radius: 3px;
        }

        .task-card-tags {
            display: flex;
            gap: 0.25rem;
            flex-wrap: wrap;
            justify-content: flex-end;
            flex-shrink: 0;
        }

        .task-tag-pill {
            font-size: 0.6rem;
            padding: 0.1rem 0.35rem;
            border-radius: 3px;
            background: #e9ecef;
            color: #6c757d;
            white-space: nowrap;
        }

        /* Scheduled task indicator - no background change, only sun icon shows scheduling */

        .task-card-today-icon {
            color: #ffc107;
            font-size: 0.85rem;
            flex-shrink: 0;
        }

        .task-card-content {
            display: flex;
            align-items: flex-start;
            gap: 0.5rem;
            width: 100%;
        }

        .task-card-content .task-card-title {
            flex: 1;
            min-width: 0;
        }

        /* Scheduled task on calendar - matches Tasks section styling */
        .calendar-scheduled-task {
            position: absolute;
            left: 4px;
            right: 4px;
            min-height: 28px;
            background: #f8f9fa;
            color: #333;
            font-size: 0.75rem;
            padding: 0.25rem 0.5rem;
            padding-right: 1.5rem;
            border-radius: 4px;
            cursor: grab;
            border: 1px solid #dee2e6;
            overflow: hidden;
            z-index: 2;
            box-sizing: border-box;
            display: flex;
            flex-direction: row;
            align-items: flex-start;
            gap: 6px;
        }

        .calendar-task-content {
            display: flex;
            align-items: center;
            gap: 4px;
            white-space: nowrap;
            overflow: hidden;
            flex: 1;
            min-width: 0;
            margin-top: 1.5px;
        }

        .calendar-task-icon {
            font-size: 0.7rem;
            flex-shrink: 0;
            opacity: 0.7;
        }

        .calendar-task-title {
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .calendar-task-tags {
            display: flex;
            flex-wrap: nowrap;
            gap: 2px;
            flex-shrink: 0;
            margin-left: auto;
            margin-top: 1.5px;
        }

        .calendar-task-tag {
            background: rgba(0, 0, 0, 0.1);
            padding: 1px 4px;
            border-radius: 2px;
            font-size: 0.6rem;
            white-space: nowrap;
        }

        .calendar-scheduled-task.critical .calendar-task-tag {
            background: rgba(0, 0, 0, 0.1);
        }

        .calendar-task-resize-handle {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            height: 6px;
            cursor: ns-resize;
            background: transparent;
        }

        /* Time block on calendar - subtle teal/sage color */
        .calendar-time-block {
            position: absolute;
            left: 4px;
            right: 4px;
            min-height: 28px;
            background: #e8f4f0;
            color: #3d5a4c;
            font-size: 0.75rem;
            padding: 0.25rem 0.5rem;
            padding-right: 1.5rem;
            border-radius: 4px;
            cursor: grab;
            border: 1px solid #b8d4c8;
            overflow: hidden;
            z-index: 2;
            box-sizing: border-box;
            display: flex;
            flex-direction: row;
            align-items: flex-start;
            gap: 6px;
        }

        .calendar-time-block:hover {
            background: #dceee8;
        }

        .time-block-content {
            display: flex;
            align-items: center;
            gap: 4px;
            white-space: nowrap;
            overflow: hidden;
            flex: 1;
            min-width: 0;
            margin-top: 1.5px;
        }

        .time-block-title {
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            font-weight: 500;
            cursor: text;
        }

        .time-block-inline-input {
            background: white;
            border: 1px solid #6B9080;
            border-radius: 2px;
            font-size: 0.75rem;
            font-weight: 500;
            color: #3d5a4c;
            padding: 0 2px;
            margin: -1px 0;
            width: 100%;
            outline: none;
        }

        .time-block-resize-handle {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            height: 6px;
            cursor: ns-resize;
            background: transparent;
        }

        .time-block-resize-handle:hover {
            background: rgba(61, 90, 76, 0.2);
        }

        .calendar-time-block .remove-btn {
            background: transparent;
            border: none;
            color: #6c9080;
            cursor: pointer;
            position: absolute;
            right: 2px;
            top: 2px;
            padding: 0;
            font-size: 0.75rem;
            opacity: 0;
            transition: opacity 0.15s;
        }

        .calendar-time-block:hover .remove-btn {
            opacity: 1;
        }

        .calendar-time-block .remove-btn:hover {
            color: #dc3545;
        }

        .calendar-task-resize-handle:hover {
            background: rgba(0, 0, 0, 0.1);
        }

        .calendar-scheduled-task.resizing {
            user-select: none;
            cursor: ns-resize;
        }

        .calendar-scheduled-task .remove-btn {
            position: absolute;
            right: 4px;
            top: 4px;
            background: none;
            border: none;
            color: #6c757d;
            opacity: 0.4;
            cursor: pointer;
            padding: 0;
            font-size: 0.7rem;
            line-height: 1;
        }

        .calendar-scheduled-task .remove-btn:hover {
            opacity: 1;
        }

        .calendar-scheduled-task:hover {
            background: #e8e8e8;
        }

        .calendar-scheduled-task.dragging {
            opacity: 0.5;
            cursor: grabbing;
        }

        /* Critical tasks use icon instead of red background */
        .calendar-scheduled-task.critical {
            /* No special background - icon indicates critical */
        }

        .calendar-critical-icon {
            color: #dc3545;
            font-size: 0.7rem;
            flex-shrink: 0;
            margin-left: auto;
            margin-top: 1.5px;
        }

        /* Drop indicator for calendar - dynamic height based on task duration */
        .hour-content.drag-over::before {
            content: '';
            position: absolute;
            left: 4px;
            right: 4px;
            height: var(--preview-height, 50%);
            background: #e9ecef;
            border: 2px dashed #6c757d;
            border-radius: 4px;
            pointer-events: none;
            z-index: 5;
        }

        .hour-content.drag-over.drag-top::before {
            top: 0;
        }

        .hour-content.drag-over.drag-bottom::before {
            top: 50%;
        }

        .hour-content.drag-over.drag-blocked::before {
            background: #fee2e2;
            border-color: #f87171;
            opacity: 0.7;
        }

        .state-group-empty {
            color: #adb5bd;
            font-size: 0.8rem;
            font-style: italic;
            padding: 0.5rem;
            text-align: center;
        }

        /* Calendar Panel - Hourly View */
        .calendar-date-header {
            display: flex;
            align-items: center;
            justify-content: flex-start;
            padding: 0.5rem 1rem;
            border-bottom: 1px solid #e9ecef;
            background: white;
        }

        .calendar-date-text {
            font-size: 0.9rem;
            font-weight: 500;
            color: #333;
        }

        .hourly-grid {
            flex: 1;
            overflow-y: auto;
        }

        .hour-row {
            display: flex;
            min-height: 60px;
            border-bottom: 1px solid #f0f0f0;
        }

        .hour-row:last-child {
            border-bottom: none;
        }

        .hour-label {
            width: 50px;
            padding: 0 0.5rem;
            font-size: 0.75rem;
            color: #6c757d;
            text-align: right;
            border-right: 1px solid #e9ecef;
            flex-shrink: 0;
            background: #fafafa;
            display: flex;
            align-items: center;
            justify-content: flex-end;
            white-space: nowrap;
        }

        .hour-content {
            flex: 1;
            padding: 0 0.5rem;
            position: relative;
            min-height: 60px;
        }

        .hour-content:hover {
            background: #fafafa;
        }

        .hour-event {
            background: #6B9080;
            color: white;
            font-size: 0.75rem;
            padding: 0.25rem 0.5rem;
            border-radius: 4px;
            margin-bottom: 0.25rem;
            cursor: pointer;
        }

        .hour-event:hover {
            background: #5a7d6e;
        }

        /* Right-click context menu */
        .task-context-menu {
            position: fixed;
            background: white;
            border-radius: 8px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.2);
            padding: 0.5rem 0;
            min-width: 180px;
            z-index: 1300;
        }

        .task-context-menu-item {
            padding: 0.5rem 1rem;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 0.75rem;
            font-size: 0.9rem;
            color: #333;
            transition: background 0.15s;
        }

        .task-context-menu-item:hover {
            background: #f0f7f4;
        }

        .task-context-menu-item i {
            width: 16px;
            text-align: center;
            color: #6c757d;
        }

        .task-context-menu-item.danger {
            color: #dc3545;
        }

        .task-context-menu-item.danger i {
            color: #dc3545;
        }

        .task-context-menu-item.save-tags-btn {
            color: #6B9080;
            border-top: 1px solid #e9ecef;
            margin-top: 0.25rem;
            padding-top: 0.6rem;
        }

        .task-context-menu-item.save-tags-btn:hover {
            background: #f0f7f4;
        }

        .task-context-menu-item.save-tags-btn i {
            color: #6B9080;
        }

        .task-context-menu-divider {
            height: 1px;
            background: #e9ecef;
            margin: 0.25rem 0;
        }

        .task-context-menu-submenu {
            position: relative;
        }

        .task-context-menu-submenu-content {
            position: absolute;
            left: 100%;
            top: -0.5rem;
            background: white;
            border-radius: 8px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.2);
            padding: 0.5rem 0;
            min-width: 150px;
            display: none;
        }

        .task-context-menu-submenu:hover .task-context-menu-submenu-content {
            display: block;
        }

        .task-context-menu-item .submenu-arrow {
            margin-left: auto;
            font-size: 0.75rem;
        }

        .context-option {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .context-option-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
        }

        .task-context-menu-item.active {
            background: #f0f7f4;
        }

        .task-context-menu-item.active::before {
            content: '';
            position: absolute;
            right: 1rem;
            font-size: 0.75rem;
            color: #6B9080;
        }
    </style>
</head>
<body>
    <!-- Sidebar icons -->
    <div class="sidebar-icons">
        <div style="position: relative;">
            <i class="bi bi-binoculars-fill sidebar-icon" id="filter-icon" title="Filter"></i>
            <span class="filter-badge" id="filter-badge" style="display: none;">0</span>
        </div>
        <i class="bi bi-gear sidebar-icon" id="settings-gear" title="Settings"></i>
    </div>

    <!-- Filter dropdown -->
    <div class="filter-dropdown" id="filter-dropdown">
        <div class="filter-section">
            <div class="filter-section-title">Group By</div>
            <label class="filter-option">
                <input type="radio" name="group-by" value="states" id="group-by-states" checked>
                States
            </label>
            <label class="filter-option">
                <input type="radio" name="group-by" value="tags" id="group-by-tags">
                Tags
            </label>
        </div>
        <div class="filter-section">
            <div class="filter-section-title">Priority</div>
            <label class="filter-option">
                <input type="checkbox" id="filter-critical">
                <i class="bi bi-exclamation-circle" style="color: #dc3545;"></i>
                Critical
            </label>
        </div>
        <div class="filter-section">
            <div class="filter-section-title">Schedule</div>
            <label class="filter-option">
                <input type="checkbox" id="filter-today">
                <i class="bi bi-brightness-high-fill" style="color: #ffc107;"></i>
                Today
            </label>
        </div>
        <div class="filter-section" id="filter-tags-section">
            <div class="filter-section-title">Filter by Tags</div>
            <input type="text" id="filter-tags-search" placeholder="Search tags..." style="width: 100%; padding: 0.35rem 0.5rem; margin-bottom: 0.5rem; border: 1px solid #dee2e6; border-radius: 4px; font-size: 0.8rem;">
            <div id="filter-tags-list">
                <!-- Tags will be populated by JavaScript -->
            </div>
        </div>
        <button class="filter-clear" id="filter-clear">Clear Filters</button>
    </div>

    <div class="container">
        <div class="page-header">
            <i class="bi bi-highlights page-icon" id="page-icon"></i>
            <h1 class="page-title">Task Manager</h1>
        </div>

        <div class="task-input-container">
            <input type="text"
                   id="new-task-input"
                   placeholder="Add a new task..."
                   autocomplete="off">
        </div>
    </div>

    <!-- Two-Panel Layout -->
    <div class="two-panel-container">
        <div class="panels-wrapper">
            <!-- Tasks Panel Wrapper (for toggle placement) -->
            <div class="tasks-panel-wrapper" id="tasks-panel-wrapper">
            <!-- Tasks Panel -->
            <div class="panel tasks-panel collapsed" id="tasks-panel">
                <div class="panel-header" id="tasks-panel-header" style="cursor: pointer;">
                    <div class="panel-header-left">
                        <i class="bi bi-check2-circle panel-header-icon"></i>
                        <span class="panel-header-title">Tasks</span>
                    </div>
                    <div class="panel-header-right">
                        <div class="panel-collapsed-metrics" id="tasks-collapsed-metrics">
                            {% for state in states %}
                            <span class="metric-pill" data-state-id="{{ state.id }}">{{ state.name }}: <span class="metric-count">0</span></span>
                            {% endfor %}
                        </div>
                        <label class="completed-toggle-inline" id="completed-toggle-inline" onclick="event.stopPropagation();">
                            <span class="toggle-label-inline" id="completed-toggle-label">Show Completed</span>
                            <input type="checkbox" id="show-completed-toggle">
                            <span class="toggle-switch"></span>
                        </label>
                        <span class="panel-expand-btn" id="tasks-expand-btn" title="Expand Tasks">
                            <i class="bi bi-arrows-angle-expand"></i>
                        </span>
                        <span class="panel-collapse-btn" id="tasks-collapse-btn" title="Collapse Tasks">
                            <i class="bi bi-chevron-down"></i>
                        </span>
                    </div>
                </div>
                <div class="panel-content" id="tasks-content">
                    <!-- States grouping (default) -->
                    <div id="states-content">
                        {% for state in states %}
                        <div class="state-group collapsed" data-state-id="{{ state.id }}">
                            <div class="state-group-header" onclick="toggleStateGroup(this)">
                                <div class="state-group-left">
                                    {% if state.bootstrap_icon %}<i class="bi {{ state.bootstrap_icon }} state-group-icon"></i>{% endif %}
                                    <span class="state-group-name">{{ state.name }}</span>
                                </div>
                                <div class="state-group-right">
                                    <span class="state-group-count" id="panel-count-{{ state.id }}">0</span>
                                    <i class="bi bi-chevron-down state-group-toggle"></i>
                                </div>
                            </div>
                            <div class="state-group-body" data-state-id="{{ state.id }}">
                                {% for task in tasks %}
                                {% if task.state == state %}
                                <div class="task-card{% if task.critical %} critical{% endif %}{% if task.calendar_start_time %} scheduled{% endif %}" data-task-id="{{ task.id }}" draggable="true">
                                    <div class="task-card-content">
                                        <div class="task-card-title">{{ task.title }}</div>
                                        {% if task.tags.all %}<div class="task-card-tags">{% for tag in task.tags.all %}<span class="task-tag-pill">{{ tag.name }}</span>{% endfor %}</div>{% endif %}
                                        {% if task.critical %}<div class="task-card-icons"><i class="bi bi-exclamation-circle-fill task-critical-icon"></i></div>{% endif %}
                                    </div>
                                </div>
                                {% endif %}
                                {% endfor %}
                            </div>
                        </div>
                        {% endfor %}
                        <!-- No State group for orphaned tasks -->
                        <div class="state-group collapsed" data-state-id="none">
                            <div class="state-group-header" onclick="toggleStateGroup(this)">
                                <div class="state-group-left">
                                    <i class="bi bi-question-circle state-group-icon"></i>
                                    <span class="state-group-name">No State</span>
                                </div>
                                <div class="state-group-right">
                                    <span class="state-group-count" id="panel-count-none">0</span>
                                    <i class="bi bi-chevron-down state-group-toggle"></i>
                                </div>
                            </div>
                            <div class="state-group-body" data-state-id="none">
                                {% for task in tasks %}
                                {% if not task.state %}
                                <div class="task-card{% if task.critical %} critical{% endif %}{% if task.calendar_start_time %} scheduled{% endif %}" data-task-id="{{ task.id }}" draggable="true">
                                    <div class="task-card-content">
                                        <div class="task-card-title">{{ task.title }}</div>
                                        {% if task.tags.all %}<div class="task-card-tags">{% for tag in task.tags.all %}<span class="task-tag-pill">{{ tag.name }}</span>{% endfor %}</div>{% endif %}
                                        {% if task.critical %}<div class="task-card-icons"><i class="bi bi-exclamation-circle-fill task-critical-icon"></i></div>{% endif %}
                                    </div>
                                </div>
                                {% endif %}
                                {% endfor %}
                            </div>
                        </div>
                    </div>
                    <!-- Tags grouping (hidden by default) -->
                    <div id="tags-content" style="display: none;"></div>
                </div>
            </div>
            </div>

            <!-- Calendar Panel -->
            <div class="panel calendar-panel collapsed" id="calendar-panel">
                <div class="panel-header" id="calendar-panel-header" style="cursor: pointer;">
                    <div class="panel-header-left">
                        <i class="bi bi-calendar-heart panel-header-icon"></i>
                        <span class="panel-header-title">Calendar</span>
                    </div>
                    <div class="panel-header-right">
                        <div class="panel-collapsed-metrics" id="calendar-collapsed-metrics">
                            <span class="metric-pill">Meetings: <span id="meetings-count">0</span></span>
                            <span class="metric-pill">Time in Meetings: <span id="meetings-time">0h</span></span>
                        </div>
                        <button class="add-event-btn" id="add-event-btn" title="Block Time">
                            <i class="bi bi-plus-lg"></i> Block Time
                        </button>
                        <span class="panel-expand-btn" id="calendar-expand-btn" title="Expand Calendar">
                            <i class="bi bi-arrows-angle-expand"></i>
                        </span>
                        <span class="panel-collapse-btn" id="calendar-collapse-btn" title="Collapse Calendar">
                            <i class="bi bi-chevron-down"></i>
                        </span>
                    </div>
                </div>
                <div class="panel-content">
                    <div class="calendar-date-header">
                        <span class="calendar-date-text" id="calendar-date-text">Today</span>
                    </div>
                    <div class="hourly-grid" id="hourly-grid">
                        <!-- Hours 7am to 6pm will be generated by JavaScript -->
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Toggle for showing/hiding completed tasks in tag view (fixed bottom right) -->
    <!-- Left slide-out Panel for Settings -->
    <div class="panel-overlay" id="context-panel-overlay"></div>
    <div class="context-panel" id="context-panel">
        <div class="panel-header">
            <span style="font-weight: 500;">Settings</span>
            <button class="panel-close" id="context-panel-close">&times;</button>
        </div>
        <div class="panel-body" style="padding: 0;">
            <!-- States Section -->
            <div class="settings-section">
                <div class="settings-section-header">States</div>
                <div class="state-input-container">
                    <input type="text" id="new-state-input" placeholder="Add new state..." autocomplete="off">
                </div>
                <ul class="state-list" id="state-list">
                    {% for state in states %}
                    <li class="state-item" data-state-id="{{ state.id }}" data-state-name="{{ state.name }}" data-order="{{ state.order }}" data-icon="{{ state.bootstrap_icon }}" draggable="true">
                        <div class="state-item-left">
                            <i class="bi bi-grip-vertical state-drag-handle"></i>
                            <span class="state-name" onclick="editStateName({{ state.id }}, this)">{{ state.name }}</span>
                        </div>
                        <div class="state-item-right">
                            <button class="state-icon-btn" onclick="openIconPicker({{ state.id }}, this)" title="Choose icon">
                                <i class="bi {% if state.bootstrap_icon %}{{ state.bootstrap_icon }}{% else %}bi-plus-circle-dotted{% endif %}"></i>
                            </button>
                            <button class="state-delete" onclick="deleteState({{ state.id }}, this)" title="Delete state">
                                <i class="bi bi-x-lg"></i>
                            </button>
                        </div>
                    </li>
                    {% empty %}
                    <li class="state-item" id="no-states" style="color: #6c757d; justify-content: center;">
                        No states yet
                    </li>
                    {% endfor %}
                </ul>
            </div>
        </div>
    </div>

    <!-- Right slide-out Panel for Task Details -->
    <div class="panel-overlay" id="panel-overlay"></div>
    <div class="slide-panel" id="slide-panel">
        <div class="panel-header">
            <span style="font-weight: 500;">Edit Task</span>
            <button class="panel-close" id="panel-close">&times;</button>
        </div>
        <div class="panel-body">
            <textarea class="panel-title-input" id="panel-title" placeholder="Task title" rows="1"></textarea>
            <div class="panel-details-header">
                <span class="panel-details-label">Details</span>
                <div class="markdown-mode-toggle">
                    <button type="button" class="markdown-mode-btn active" id="markdown-edit-btn">Edit</button>
                    <button type="button" class="markdown-mode-btn" id="markdown-view-btn">View</button>
                </div>
            </div>
            <div class="panel-details-container">
                <textarea class="panel-details-input" id="panel-details" placeholder="Markdown supported"></textarea>
                <div class="panel-details-preview" id="panel-details-preview" style="display: none;"></div>
            </div>
            <div class="critical-toggle" style="margin-top: 1rem;">
                <input type="checkbox" id="panel-critical">
                <label for="panel-critical">Critical</label>
            </div>
        </div>
        <div class="panel-footer">
            <button class="mark-done-btn" id="panel-mark-done">
                <i class="bi bi-check-circle"></i>
                <span>Task Complete!</span>
            </button>
            <button class="delete-btn" id="panel-delete" title="Delete task">
                <i class="bi bi-trash"></i>
            </button>
        </div>
    </div>

    <!-- Right slide-out Panel for Time Slot Tasks -->
    <div class="timeslot-panel-overlay" id="timeslot-panel-overlay"></div>
    <div class="timeslot-panel" id="timeslot-panel">
        <div class="panel-header">
            <span style="font-weight: 500;" id="timeslot-panel-title">Time Slot Tasks</span>
            <button class="panel-close" id="timeslot-panel-close">&times;</button>
        </div>
        <div class="timeslot-task-list" id="timeslot-task-list">
            <!-- Tasks will be populated here -->
        </div>
    </div>

    <!-- Delete State Modal -->
    <div class="modal-overlay" id="delete-state-modal">
        <div class="modal-content">
            <div class="modal-title" id="delete-state-modal-title">Delete State</div>
            <div class="modal-body" id="delete-state-modal-body">
                <!-- Content will be populated dynamically -->
            </div>
            <div id="delete-state-modal-select-container" style="display: none;">
                <select class="modal-select" id="delete-state-move-to">
                    <!-- Options will be populated dynamically -->
                </select>
            </div>
            <div class="modal-buttons">
                <button class="modal-btn modal-btn-cancel" onclick="closeDeleteStateModal()">Cancel</button>
                <button class="modal-btn modal-btn-danger" id="delete-state-confirm-btn" style="display: none;">Delete</button>
                <button class="modal-btn modal-btn-primary" id="delete-state-ok-btn" style="display: none;" onclick="closeDeleteStateModal()">OK</button>
            </div>
        </div>
    </div>

    <!-- Confirm Modal -->
    <div class="modal-overlay" id="confirm-modal">
        <div class="modal-content">
            <div class="modal-title" id="confirm-modal-title">Confirm</div>
            <div class="modal-body" id="confirm-modal-body"></div>
            <div class="modal-buttons">
                <button class="modal-btn modal-btn-cancel" id="confirm-modal-cancel">Cancel</button>
                <button class="modal-btn modal-btn-danger" id="confirm-modal-confirm">Delete</button>
            </div>
        </div>
    </div>

    <!-- Alert Modal -->
    <div class="modal-overlay" id="alert-modal">
        <div class="modal-content">
            <div class="modal-title" id="alert-modal-title">Error</div>
            <div class="modal-body" id="alert-modal-body"></div>
            <div class="modal-buttons">
                <button class="modal-btn modal-btn-primary" id="alert-modal-ok">OK</button>
            </div>
        </div>
    </div>

    <!-- Prompt Modal -->
    <div class="modal-overlay" id="prompt-modal">
        <div class="modal-content">
            <div class="modal-title" id="prompt-modal-title">Input</div>
            <div class="modal-body" id="prompt-modal-body"></div>
            <input type="text" class="modal-input" id="prompt-modal-input" placeholder="">
            <div class="modal-buttons">
                <button class="modal-btn modal-btn-cancel" id="prompt-modal-cancel">Cancel</button>
                <button class="modal-btn modal-btn-primary" id="prompt-modal-ok">OK</button>
            </div>
        </div>
    </div>

    <!-- Block Time Modal -->
    <div class="modal-overlay" id="add-event-modal">
        <div class="modal-content">
            <div class="modal-title">Block Time</div>
            <div class="modal-body">
                <div style="margin-bottom: 0.75rem;">
                    <label for="event-name-input" style="font-size: 0.8rem; color: #6c757d; display: block; margin-bottom: 0.25rem;">Name</label>
                    <input type="text" class="modal-input" id="event-name-input" placeholder="Event name" style="margin-bottom: 0;">
                </div>
                <div>
                    <label for="event-time-input" style="font-size: 0.8rem; color: #6c757d; display: block; margin-bottom: 0.25rem;">Time</label>
                    <input type="time" class="modal-input" id="event-time-input" style="margin-bottom: 0;">
                </div>
            </div>
            <div class="modal-buttons">
                <button class="modal-btn modal-btn-cancel" id="add-event-cancel">Cancel</button>
                <button class="modal-btn modal-btn-primary" id="add-event-ok">Add</button>
            </div>
        </div>
    </div>

    <script>
        const csrfToken = document.querySelector('meta[name="csrf-token"]').content;
        let currentTaskId = null;
        let saveTimeout = null;

        // Store tags locally for immediate availability
        let tagsList = [
            {% for tag in tags %}
            { id: {{ tag.id }}, name: "{{ tag.name|escapejs }}" }{% if not forloop.last %},{% endif %}
            {% endfor %}
        ];

        // Store task tags for quick lookup (task_id -> array of tag objects)
        let taskTagsMap = {};
        {% for task in tasks %}
        taskTagsMap[{{ task.id }}] = [{% for tag in task.tags.all %}{ id: {{ tag.id }}, name: "{{ tag.name|escapejs }}" }{% if not forloop.last %},{% endif %}{% endfor %}];
        {% endfor %}

        // Store task calendar_start_time for quick lookup (task_id -> ISO string or null)
        // Store task calendar start/end times for quick lookup
        let taskCalendarStartTimeMap = {};
        let taskCalendarEndTimeMap = {};
        {% for task in tasks %}
        taskCalendarStartTimeMap[{{ task.id }}] = {% if task.calendar_start_time %}"{{ task.calendar_start_time.isoformat }}"{% else %}null{% endif %};
        taskCalendarEndTimeMap[{{ task.id }}] = {% if task.calendar_end_time %}"{{ task.calendar_end_time.isoformat }}"{% else %}null{% endif %};
        {% endfor %}

        // ========== Custom Modal Functions ==========

        // Confirm modal - returns a Promise that resolves to true/false
        function showConfirmModal(message, title = 'Confirm', confirmText = 'Delete') {
            return new Promise((resolve) => {
                const modal = document.getElementById('confirm-modal');
                const titleEl = document.getElementById('confirm-modal-title');
                const bodyEl = document.getElementById('confirm-modal-body');
                const cancelBtn = document.getElementById('confirm-modal-cancel');
                const confirmBtn = document.getElementById('confirm-modal-confirm');

                titleEl.textContent = title;
                bodyEl.textContent = message;
                confirmBtn.textContent = confirmText;

                const cleanup = () => {
                    modal.classList.remove('active');
                    cancelBtn.removeEventListener('click', handleCancel);
                    confirmBtn.removeEventListener('click', handleConfirm);
                };

                const handleCancel = () => {
                    cleanup();
                    resolve(false);
                };

                const handleConfirm = () => {
                    cleanup();
                    resolve(true);
                };

                cancelBtn.addEventListener('click', handleCancel);
                confirmBtn.addEventListener('click', handleConfirm);

                modal.classList.add('active');
            });
        }

        // Alert modal - returns a Promise that resolves when closed
        function showAlertModal(message, title = 'Error') {
            return new Promise((resolve) => {
                const modal = document.getElementById('alert-modal');
                const titleEl = document.getElementById('alert-modal-title');
                const bodyEl = document.getElementById('alert-modal-body');
                const okBtn = document.getElementById('alert-modal-ok');

                titleEl.textContent = title;
                bodyEl.textContent = message;

                const handleOk = () => {
                    modal.classList.remove('active');
                    okBtn.removeEventListener('click', handleOk);
                    resolve();
                };

                okBtn.addEventListener('click', handleOk);
                modal.classList.add('active');
            });
        }

        // Prompt modal - returns a Promise that resolves to the input value or null if cancelled
        function showPromptModal(message, title = 'Input', placeholder = '') {
            return new Promise((resolve) => {
                const modal = document.getElementById('prompt-modal');
                const titleEl = document.getElementById('prompt-modal-title');
                const bodyEl = document.getElementById('prompt-modal-body');
                const inputEl = document.getElementById('prompt-modal-input');
                const cancelBtn = document.getElementById('prompt-modal-cancel');
                const okBtn = document.getElementById('prompt-modal-ok');

                titleEl.textContent = title;
                bodyEl.textContent = message;
                inputEl.placeholder = placeholder;
                inputEl.value = '';

                const cleanup = () => {
                    modal.classList.remove('active');
                    cancelBtn.removeEventListener('click', handleCancel);
                    okBtn.removeEventListener('click', handleOk);
                    inputEl.removeEventListener('keypress', handleKeypress);
                };

                const handleCancel = () => {
                    cleanup();
                    resolve(null);
                };

                const handleOk = () => {
                    const value = inputEl.value;
                    cleanup();
                    resolve(value);
                };

                const handleKeypress = (e) => {
                    if (e.key === 'Enter') {
                        handleOk();
                    }
                };

                cancelBtn.addEventListener('click', handleCancel);
                okBtn.addEventListener('click', handleOk);
                inputEl.addEventListener('keypress', handleKeypress);

                modal.classList.add('active');
                setTimeout(() => inputEl.focus(), 100);
            });
        }

        // ========== Terminal State Management ==========

        function updateStateTypeLabels() {
            // Update state groups with terminal class and delete link
            updateTerminalStateGroup();
        }

        function getTerminalStateId() {
            const stateItems = document.querySelectorAll('.state-item:not(#no-states)');
            if (stateItems.length === 0) return null;
            return parseInt(stateItems[stateItems.length - 1].dataset.stateId);
        }

        function updateTerminalStateGroup() {
            // Remove all existing delete completed links
            document.querySelectorAll('.delete-completed-link').forEach(el => el.remove());
            document.querySelectorAll('.state-group').forEach(g => g.classList.remove('terminal-state'));

            const terminalStateId = getTerminalStateId();
            if (!terminalStateId) return;

            const terminalGroup = document.querySelector(`.state-group[data-state-id="${terminalStateId}"]`);
            if (terminalGroup) {
                terminalGroup.classList.add('terminal-state');
                const body = terminalGroup.querySelector('.state-group-body');
                if (body) {
                    const deleteLink = document.createElement('div');
                    deleteLink.className = 'delete-completed-link';
                    deleteLink.textContent = 'Delete Completed Tasks';
                    deleteLink.onclick = (e) => {
                        e.stopPropagation();
                        deleteCompletedTasks(terminalStateId);
                    };
                    // Insert at the beginning of the body
                    body.insertBefore(deleteLink, body.firstChild);
                }
            }
        }

        async function deleteCompletedTasks(stateId) {
            const body = document.querySelector(`#states-content .state-group-body[data-state-id="${stateId}"]`);
            if (!body) return;

            const taskCards = body.querySelectorAll('.task-card');
            const count = taskCards.length;

            if (count === 0) {
                await showAlertModal('There are no tasks to delete.', 'No Tasks');
                return;
            }

            const confirmed = await showConfirmModal(
                `Are you sure you want to permanently delete ${count} task${count > 1 ? 's' : ''}?`,
                'Delete Completed Tasks',
                'Delete All'
            );

            if (!confirmed) return;

            // Collect task IDs to delete
            const taskIds = [];
            taskCards.forEach(card => taskIds.push(parseInt(card.dataset.taskId)));

            // Delete all tasks in the terminal state
            for (const taskId of taskIds) {
                try {
                    await fetch(`/tasks/api/${taskId}/delete/`, {
                        method: 'DELETE',
                        headers: {
                            'X-CSRFToken': csrfToken
                        }
                    });
                    // Remove from all views
                    document.querySelectorAll(`.kanban-card[data-task-id="${taskId}"], .task-card[data-task-id="${taskId}"]`).forEach(card => card.remove());
                    // Remove from tags map
                    delete taskTagsMap[taskId];
                    // Remove from calendar time map and re-render calendar
                    delete taskCalendarStartTimeMap[taskId];
                    renderScheduledTasks();
                } catch (error) {
                    console.error('Error deleting task:', error);
                }
            }

            updatePanelCounts();
            updateKanbanCounts();
        }

        // Add new task on Enter
        document.getElementById('new-task-input').addEventListener('keypress', async function(e) {
            if (e.key === 'Enter' && this.value.trim()) {
                const title = this.value.trim();
                this.value = '';

                try {
                    const response = await fetch('/tasks/api/create/', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'X-CSRFToken': csrfToken
                        },
                        body: JSON.stringify({ title })
                    });

                    const data = await response.json();
                    if (data.success) {
                        addTaskToKanban(data.task);
                    }
                } catch (error) {
                    console.error('Error creating task:', error);
                }
            }
        });

        function addTaskToKanban(task) {
            // Initialize tags map for the new task
            taskTagsMap[task.id] = task.tags || [];
            // Initialize calendar times for the new task
            taskCalendarStartTimeMap[task.id] = task.calendar_start_time || null;
            taskCalendarEndTimeMap[task.id] = task.calendar_end_time || null;

            // Helper to create a task card
            function createTaskCard(withHighlight) {
                const card = document.createElement('div');
                const isScheduled = !!taskCalendarStartTimeMap[task.id];
                card.className = 'task-card' + (task.critical ? ' critical' : '') + (isScheduled ? ' scheduled' : '') + (withHighlight ? ' highlight-new' : '');
                card.dataset.taskId = task.id;
                card.draggable = true;
                card.innerHTML = `
                    <div class="task-card-content">
                        <div class="task-card-title">${escapeHtml(task.title)}</div>
                        ${task.critical ? '<div class="task-card-icons"><i class="bi bi-exclamation-circle-fill task-critical-icon"></i></div>' : ''}
                    </div>
                `;

                // Setup drag events and context menu for the new card
                setupTaskCardDragEvents(card);
                card.addEventListener('contextmenu', function(e) {
                    e.preventDefault();
                    showContextMenu(e, parseInt(this.dataset.taskId), 'openTaskPanel');
                });

                return card;
            }

            // Expand the Tasks panel if collapsed
            const tasksPanel = document.getElementById('tasks-panel');
            if (tasksPanel && tasksPanel.classList.contains('collapsed')) {
                tasksPanel.classList.remove('collapsed');
            }

            // Always add to states-content (it's the master view)
            const firstStateGroup = document.querySelector('#states-content .state-group');
            if (firstStateGroup) {
                const stateGroupBody = firstStateGroup.querySelector('.state-group-body');
                if (stateGroupBody) {
                    const statesCard = createTaskCard(currentGroupBy === 'states');
                    stateGroupBody.insertBefore(statesCard, stateGroupBody.firstChild);

                    if (currentGroupBy === 'states') {
                        // Expand the first state group if collapsed
                        if (firstStateGroup.classList.contains('collapsed')) {
                            firstStateGroup.classList.remove('collapsed');
                        }
                        // Remove highlight class after animation
                        setTimeout(() => {
                            statesCard.classList.remove('highlight-new');
                        }, 4500);
                    }
                }
            }

            // If currently viewing by tags, also add to the Untagged group
            if (currentGroupBy === 'tags') {
                const untaggedGroup = document.querySelector('#tags-content .state-group[data-tag-id="untagged"]');
                if (untaggedGroup) {
                    const untaggedBody = untaggedGroup.querySelector('.state-group-body');
                    if (untaggedBody) {
                        const tagsCard = createTaskCard(true);
                        untaggedBody.insertBefore(tagsCard, untaggedBody.firstChild);

                        // Expand the Untagged group if collapsed
                        if (untaggedGroup.classList.contains('collapsed')) {
                            untaggedGroup.classList.remove('collapsed');
                        }
                        // Update the count
                        const countEl = untaggedGroup.querySelector('.state-group-count');
                        if (countEl) {
                            countEl.textContent = parseInt(countEl.textContent) + 1;
                        }
                        // Remove highlight class after animation
                        setTimeout(() => {
                            tagsCard.classList.remove('highlight-new');
                        }, 4500);
                    }
                }
            }

            // Update counts
            updatePanelCounts();
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }


        function closePanel() {
            document.getElementById('panel-overlay').classList.remove('active');
            document.getElementById('slide-panel').classList.remove('active');
            currentTaskId = null;
        }

        document.getElementById('panel-close').addEventListener('click', closePanel);
        document.getElementById('panel-overlay').addEventListener('click', closePanel);

        // Auto-resize title textarea
        function autoResizeTitle() {
            const titleEl = document.getElementById('panel-title');
            titleEl.style.height = 'auto';
            titleEl.style.height = titleEl.scrollHeight + 'px';
        }

        // Configure marked to open links in new tabs
        const renderer = new marked.Renderer();
        const originalLinkRenderer = renderer.link.bind(renderer);
        renderer.link = function(href, title, text) {
            const html = originalLinkRenderer(href, title, text);
            return html.replace('<a ', '<a target="_blank" rel="noopener noreferrer" ');
        };
        marked.setOptions({ renderer: renderer });

        // Markdown preview handling
        const detailsTextarea = document.getElementById('panel-details');
        const detailsPreview = document.getElementById('panel-details-preview');
        const markdownEditBtn = document.getElementById('markdown-edit-btn');
        const markdownViewBtn = document.getElementById('markdown-view-btn');

        function showMarkdownPreview() {
            const text = detailsTextarea.value.trim();
            detailsPreview.innerHTML = text ? marked.parse(text) : '';
            detailsTextarea.style.display = 'none';
            detailsPreview.style.display = 'block';
            markdownEditBtn.classList.remove('active');
            markdownViewBtn.classList.add('active');
        }

        function showMarkdownEdit() {
            detailsPreview.style.display = 'none';
            detailsTextarea.style.display = 'block';
            markdownEditBtn.classList.add('active');
            markdownViewBtn.classList.remove('active');
            detailsTextarea.focus();
        }

        // Toggle buttons
        markdownEditBtn.addEventListener('click', showMarkdownEdit);
        markdownViewBtn.addEventListener('click', showMarkdownPreview);

        // Clicking into textarea switches to edit mode
        detailsTextarea.addEventListener('focus', function() {
            markdownEditBtn.classList.add('active');
            markdownViewBtn.classList.remove('active');
        });

        // Clicking outside switches to view mode
        detailsTextarea.addEventListener('blur', function() {
            // Small delay to allow clicking the toggle buttons
            setTimeout(showMarkdownPreview, 150);
        });

        // Clicking preview switches to edit mode
        detailsPreview.addEventListener('click', showMarkdownEdit);

        // Auto-save on changes
        ['panel-title', 'panel-details', 'panel-critical'].forEach(id => {
            const el = document.getElementById(id);
            const event = (el.type === 'checkbox') ? 'change' : 'input';
            el.addEventListener(event, () => {
                if (id === 'panel-title') autoResizeTitle();
                if (saveTimeout) clearTimeout(saveTimeout);
                saveTimeout = setTimeout(saveCurrentTask, 500);
            });
        });

        async function saveCurrentTask() {
            if (!currentTaskId) return;

            const title = document.getElementById('panel-title').value.trim();
            const details = document.getElementById('panel-details').value;
            const critical = document.getElementById('panel-critical').checked;

            try {
                const response = await fetch(`/tasks/api/${currentTaskId}/update/`, {
                    method: 'PATCH',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-CSRFToken': csrfToken
                    },
                    body: JSON.stringify({ title, details, critical })
                });

                const data = await response.json();
                if (data.success) {
                    handleTaskStateChange(data.task);
                }
            } catch (error) {
                console.error('Error updating task:', error);
            }
        }

        function updateTaskInList(task) {
            const taskItem = document.querySelector(`.task-item[data-task-id="${task.id}"]`);
            if (!taskItem) return;

            taskItem.className = 'task-item' + (task.critical ? ' critical' : '');

            const titleEl = taskItem.querySelector('.task-title');
            titleEl.textContent = task.title;

            let detailsEl = taskItem.querySelector('.task-details-preview');
            if (task.details) {
                if (!detailsEl) {
                    detailsEl = document.createElement('div');
                    detailsEl.className = 'task-details-preview';
                    taskItem.querySelector('.task-content').appendChild(detailsEl);
                }
                detailsEl.textContent = task.details.substring(0, 50) + (task.details.length > 50 ? '...' : '');
            } else if (detailsEl) {
                detailsEl.remove();
            }
        }

        // Delete task
        document.getElementById('panel-delete').addEventListener('click', async () => {
            if (!currentTaskId) return;
            const confirmed = await showConfirmModal('Are you sure you want to delete this task?', 'Delete Task', 'Delete');
            if (!confirmed) return;
            await deleteTask(currentTaskId);
            closePanel();
        });

        // Mark as done button handler
        document.getElementById('panel-mark-done').addEventListener('click', async () => {
            if (!currentTaskId) return;
            const terminalStateId = getTerminalStateId();
            if (!terminalStateId) return;

            const markDoneBtn = document.getElementById('panel-mark-done');
            const isAlreadyDone = markDoneBtn.classList.contains('is-done');

            // If already done, do nothing (or could toggle back to previous state if we stored it)
            if (isAlreadyDone) return;

            try {
                const response = await fetch(`/tasks/api/${currentTaskId}/update/`, {
                    method: 'PATCH',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-CSRFToken': csrfToken
                    },
                    body: JSON.stringify({ state_id: terminalStateId })
                });

                const data = await response.json();
                if (data.success) {
                    // Update button state
                    markDoneBtn.classList.add('is-done');
                    markDoneBtn.querySelector('span').textContent = 'Task Complete!';
                    markDoneBtn.querySelector('i').className = 'bi bi-check-circle-fill';

                    // Update the UI
                    handleTaskStateChange(data.task);
                }
            } catch (error) {
                console.error('Error marking task as done:', error);
            }
        });

        async function deleteTask(taskId) {
            try {
                const response = await fetch(`/tasks/api/${taskId}/delete/`, {
                    method: 'DELETE',
                    headers: {
                        'X-CSRFToken': csrfToken
                    }
                });

                const data = await response.json();
                if (data.success) {
                    // Remove from all views
                    const allCards = document.querySelectorAll(`.kanban-card[data-task-id="${taskId}"], .task-card[data-task-id="${taskId}"]`);
                    allCards.forEach(card => {
                        card.style.opacity = '0';
                        card.style.transform = 'translateX(20px)';
                        card.style.transition = 'all 0.3s';
                        setTimeout(() => {
                            card.remove();
                        }, 300);
                    });

                    // Update counts after removal animation
                    setTimeout(() => {
                        updateKanbanCounts();
                        updatePanelCounts();
                        // Update tag group counts if in tags view
                        if (currentGroupBy === 'tags') {
                            document.querySelectorAll('#tags-content .state-group').forEach(group => {
                                const count = group.querySelectorAll('.task-card').length;
                                const countEl = group.querySelector('.state-group-count');
                                if (countEl) countEl.textContent = count;
                            });
                        }
                    }, 300);

                    // Remove from tags map
                    delete taskTagsMap[taskId];
                    // Remove from calendar time map and re-render calendar
                    delete taskCalendarStartTimeMap[taskId];
                    renderScheduledTasks();
                }
            } catch (error) {
                console.error('Error deleting task:', error);
            }
        }

        // ========== Context Panel ==========

        // Open context panel
        document.getElementById('settings-gear').addEventListener('click', () => {
            document.getElementById('context-panel-overlay').classList.add('active');
            document.getElementById('context-panel').classList.add('active');
        });

        function closeContextPanel() {
            document.getElementById('context-panel-overlay').classList.remove('active');
            document.getElementById('context-panel').classList.remove('active');
        }

        document.getElementById('context-panel-close').addEventListener('click', closeContextPanel);
        document.getElementById('context-panel-overlay').addEventListener('click', closeContextPanel);

        // Edit state name inline
        function editStateName(stateId, spanElement) {
            const currentName = spanElement.textContent.trim();
            const input = document.createElement('input');
            input.type = 'text';
            input.className = 'state-name-input';
            input.value = currentName;

            spanElement.replaceWith(input);
            input.focus();
            input.select();

            async function saveStateName() {
                const newName = input.value.trim();
                if (newName && newName !== currentName) {
                    try {
                        const response = await fetch(`/tasks/api/states/${stateId}/update/`, {
                            method: 'PATCH',
                            headers: {
                                'Content-Type': 'application/json',
                                'X-CSRFToken': csrfToken
                            },
                            body: JSON.stringify({ name: newName })
                        });

                        const data = await response.json();
                        if (data.success) {
                            // Update local list
                            const state = statesList.find(s => s.id === stateId);
                            if (state) state.name = newName;

                            // Update the state item data attribute
                            const stateItem = input.closest('.state-item');
                            if (stateItem) stateItem.dataset.stateName = newName;

                            // Update state group name in tasks panel
                            const stateGroup = document.querySelector(`.state-group[data-state-id="${stateId}"]`);
                            if (stateGroup) {
                                const nameSpan = stateGroup.querySelector('.state-group-name');
                                if (nameSpan) nameSpan.textContent = newName;
                            }

                            // Update metric pill text
                            const metricPill = document.querySelector(`.metric-pill[data-state-id="${stateId}"]`);
                            if (metricPill) {
                                const countSpan = metricPill.querySelector('.metric-count');
                                const count = countSpan ? countSpan.textContent : '0';
                                metricPill.innerHTML = `${escapeHtml(newName)}: <span class="metric-count">${count}</span>`;
                            }

                            restoreStateSpan(newName);
                        } else {
                            showAlertModal(data.error || 'Failed to rename state', 'Error');
                            restoreStateSpan(currentName);
                        }
                    } catch (error) {
                        console.error('Error renaming state:', error);
                        restoreStateSpan(currentName);
                    }
                } else {
                    restoreStateSpan(currentName);
                }
            }

            function restoreStateSpan(name) {
                const span = document.createElement('span');
                span.className = 'state-name';
                span.textContent = name;
                span.onclick = () => editStateName(stateId, span);
                input.replaceWith(span);
            }

            input.addEventListener('blur', saveStateName);
            input.addEventListener('keydown', function(e) {
                if (e.key === 'Enter') {
                    input.blur();
                } else if (e.key === 'Escape') {
                    restoreStateSpan(currentName);
                }
            });
        }

        // ========== States Management ==========

        // Store states locally
        let statesList = [
            {% for state in states %}
            { id: {{ state.id }}, name: "{{ state.name|escapejs }}", order: {{ state.order }}, bootstrap_icon: "{{ state.bootstrap_icon|escapejs }}" }{% if not forloop.last %},{% endif %}
            {% endfor %}
        ];

        // Icon picker for states
        const stateIcons = [
            'bi-inbox', 'bi-inbox-fill', 'bi-play-circle', 'bi-play-fill', 'bi-arrow-right-circle',
            'bi-hourglass-split', 'bi-clock', 'bi-clock-fill', 'bi-pause-circle', 'bi-pause-fill',
            'bi-check-circle', 'bi-check-circle-fill', 'bi-check2-circle', 'bi-check-lg',
            'bi-star', 'bi-star-fill', 'bi-flag', 'bi-flag-fill', 'bi-bookmark', 'bi-bookmark-fill',
            'bi-lightning', 'bi-lightning-fill', 'bi-fire', 'bi-rocket', 'bi-bullseye',
            'bi-eye', 'bi-eye-fill', 'bi-search', 'bi-binoculars', 'bi-crosshair',
            'bi-gear', 'bi-gear-fill', 'bi-tools', 'bi-wrench', 'bi-hammer',
            'bi-pencil', 'bi-pencil-fill', 'bi-brush', 'bi-palette', 'bi-vector-pen',
            'bi-chat', 'bi-chat-fill', 'bi-chat-dots', 'bi-chat-dots-fill', 'bi-megaphone',
            'bi-people', 'bi-people-fill', 'bi-person', 'bi-person-fill', 'bi-person-check',
            'bi-folder', 'bi-folder-fill', 'bi-file-earmark', 'bi-file-text', 'bi-journal',
            'bi-calendar', 'bi-calendar-event', 'bi-calendar-check', 'bi-alarm', 'bi-bell',
            'bi-heart', 'bi-heart-fill', 'bi-emoji-smile', 'bi-hand-thumbs-up', 'bi-trophy',
            'bi-shield-check', 'bi-lock', 'bi-unlock', 'bi-key', 'bi-safe',
            'bi-code-slash', 'bi-terminal', 'bi-bug', 'bi-cpu', 'bi-database',
            'bi-cart', 'bi-bag', 'bi-gift', 'bi-currency-dollar', 'bi-credit-card'
        ];

        let currentIconPickerStateId = null;
        let iconPickerElement = null;

        function openIconPicker(stateId, btnElement) {
            closeIconPicker();

            currentIconPickerStateId = stateId;
            const stateItem = btnElement.closest('.state-item');
            const currentIcon = stateItem.dataset.icon || '';

            const picker = document.createElement('div');
            picker.className = 'icon-picker-popup';
            picker.id = 'icon-picker-popup';

            // Custom icon input
            let html = '<div class="icon-picker-custom">';
            html += '<input type="text" id="custom-icon-input" placeholder="bi-icon-name" value="' + escapeHtml(currentIcon) + '">';
            html += '<button onclick="applyCustomIcon()">Apply</button>';
            html += '</div>';

            // Icon grid
            html += '<div class="icon-picker-grid">';
            stateIcons.forEach(icon => {
                const isSelected = icon === currentIcon ? ' selected' : '';
                html += `<button class="icon-picker-item${isSelected}" data-icon="${icon}" onclick="selectStateIcon('${icon}')"><i class="bi ${icon}"></i></button>`;
            });
            html += '</div>';
            html += '<button class="icon-picker-clear" onclick="selectStateIcon(\'\')">Remove icon</button>';

            picker.innerHTML = html;

            // Position near the button
            const rect = btnElement.getBoundingClientRect();
            picker.style.left = Math.min(rect.left, window.innerWidth - 300) + 'px';
            picker.style.top = (rect.bottom + 5) + 'px';

            document.body.appendChild(picker);
            iconPickerElement = picker;

            // Close on outside click
            setTimeout(() => {
                document.addEventListener('click', handleIconPickerOutsideClick);
            }, 0);
        }

        function handleIconPickerOutsideClick(e) {
            const picker = document.getElementById('icon-picker-popup');
            if (picker && !picker.contains(e.target) && !e.target.closest('.state-icon-btn')) {
                closeIconPicker();
            }
        }

        function closeIconPicker() {
            const picker = document.getElementById('icon-picker-popup');
            if (picker) {
                picker.remove();
            }
            document.removeEventListener('click', handleIconPickerOutsideClick);
            currentIconPickerStateId = null;
            iconPickerElement = null;
        }

        function applyCustomIcon() {
            const input = document.getElementById('custom-icon-input');
            if (input) {
                let icon = input.value.trim();
                // Add bi- prefix if not present
                if (icon && !icon.startsWith('bi-')) {
                    icon = 'bi-' + icon;
                }
                selectStateIcon(icon);
            }
        }

        async function selectStateIcon(icon) {
            if (currentIconPickerStateId === null) return;

            const stateId = currentIconPickerStateId;

            try {
                const response = await fetch(`/tasks/api/states/${stateId}/update/`, {
                    method: 'PATCH',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-CSRFToken': csrfToken
                    },
                    body: JSON.stringify({ bootstrap_icon: icon })
                });

                const data = await response.json();
                if (data.success) {
                    // Update the state item in settings
                    const stateItem = document.querySelector(`.state-item[data-state-id="${stateId}"]`);
                    if (stateItem) {
                        stateItem.dataset.icon = icon;
                        const iconBtn = stateItem.querySelector('.state-icon-btn i');
                        iconBtn.className = 'bi ' + (icon || 'bi-plus-circle-dotted');
                        if (!icon) {
                            iconBtn.classList.add('bi-plus-circle-dotted');
                        }
                    }

                    // Update state group icon in tasks panel
                    const stateGroup = document.querySelector(`.state-group[data-state-id="${stateId}"]`);
                    if (stateGroup) {
                        const leftDiv = stateGroup.querySelector('.state-group-left');
                        if (leftDiv) {
                            // Remove existing icon if present
                            const existingIcon = leftDiv.querySelector('.state-group-icon');
                            if (existingIcon) existingIcon.remove();

                            // Add new icon if provided
                            if (icon) {
                                const newIcon = document.createElement('i');
                                newIcon.className = `bi ${icon} state-group-icon`;
                                leftDiv.insertBefore(newIcon, leftDiv.firstChild);
                            }
                        }
                    }

                    // Update local states list
                    const state = statesList.find(s => s.id === stateId);
                    if (state) state.bootstrap_icon = icon;

                    closeIconPicker();
                } else {
                    showAlertModal(data.error || 'Failed to update icon', 'Error');
                }
            } catch (error) {
                console.error('Error updating state icon:', error);
            }
        }

        // Add new state on Enter
        document.getElementById('new-state-input').addEventListener('keypress', async function(e) {
            if (e.key === 'Enter' && this.value.trim()) {
                const name = this.value.trim();
                this.value = '';

                try {
                    const response = await fetch('/tasks/api/states/create/', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'X-CSRFToken': csrfToken
                        },
                        body: JSON.stringify({ name })
                    });

                    const data = await response.json();
                    if (data.success) {
                        addStateToList(data.state);
                        statesList.push(data.state);
                    } else {
                        showAlertModal(data.error || 'Failed to create state', 'Error');
                    }
                } catch (error) {
                    console.error('Error creating state:', error);
                }
            }
        });

        function addStateToList(state) {
            // Remove "no states" message if present
            const noStates = document.getElementById('no-states');
            if (noStates) {
                noStates.remove();
            }

            const li = document.createElement('li');
            li.className = 'state-item';
            li.dataset.stateId = state.id;
            li.dataset.stateName = state.name;
            li.dataset.order = state.order;
            li.dataset.icon = state.bootstrap_icon || '';
            li.draggable = true;
            li.innerHTML = `
                <div class="state-item-left">
                    <i class="bi bi-grip-vertical state-drag-handle"></i>
                    <span class="state-name" onclick="editStateName(${state.id}, this)">${escapeHtml(state.name)}</span>
                </div>
                <div class="state-item-right">
                    <button class="state-icon-btn" onclick="openIconPicker(${state.id}, this)" title="Choose icon">
                        <i class="bi bi-plus-circle-dotted"></i>
                    </button>
                    <button class="state-delete" onclick="deleteState(${state.id}, this)" title="Delete state">
                        <i class="bi bi-x-lg"></i>
                    </button>
                </div>
            `;

            // Append to end of list in settings panel
            const stateList = document.getElementById('state-list');
            stateList.appendChild(li);

            // Setup drag events for new item
            setupDragEvents(li);

            // Add state group to tasks panel
            const tasksContent = document.getElementById('tasks-content');
            if (tasksContent) {
                const stateGroup = document.createElement('div');
                stateGroup.className = 'state-group collapsed';
                stateGroup.dataset.stateId = state.id;
                stateGroup.innerHTML = `
                    <div class="state-group-header" onclick="toggleStateGroup(this)">
                        <div class="state-group-left">
                            ${state.bootstrap_icon ? `<i class="bi ${state.bootstrap_icon} state-group-icon"></i>` : ''}
                            <span class="state-group-name">${escapeHtml(state.name)}</span>
                        </div>
                        <div class="state-group-right">
                            <span class="state-group-count" id="panel-count-${state.id}">0</span>
                            <i class="bi bi-chevron-down state-group-toggle"></i>
                        </div>
                    </div>
                    <div class="state-group-body" data-state-id="${state.id}"></div>
                `;
                tasksContent.appendChild(stateGroup);

                // Setup drag-drop handlers for the new state group
                setupStateGroupDragHandlers(stateGroup);
            }

            // Add metric pill to collapsed header
            const metricsContainer = document.getElementById('tasks-collapsed-metrics');
            if (metricsContainer) {
                const pill = document.createElement('span');
                pill.className = 'metric-pill';
                pill.dataset.stateId = state.id;
                pill.innerHTML = `${escapeHtml(state.name)}: <span class="metric-count">0</span>`;
                metricsContainer.appendChild(pill);
            }

            // Update inbox/terminal labels
            updateStateTypeLabels();
        }

        let deleteStateId = null;
        let deleteStateButton = null;

        async function deleteState(stateId, button) {
            deleteStateId = stateId;
            deleteStateButton = button;

            try {
                // Get state info including task count
                const response = await fetch(`/tasks/api/states/${stateId}/info/`);
                const data = await response.json();

                if (!data.success) {
                    showAlertModal(data.error || 'Failed to get state info', 'Error');
                    return;
                }

                const { state, total_states } = data;
                const modal = document.getElementById('delete-state-modal');
                const modalTitle = document.getElementById('delete-state-modal-title');
                const modalBody = document.getElementById('delete-state-modal-body');
                const selectContainer = document.getElementById('delete-state-modal-select-container');
                const select = document.getElementById('delete-state-move-to');
                const confirmBtn = document.getElementById('delete-state-confirm-btn');
                const okBtn = document.getElementById('delete-state-ok-btn');

                // Reset modal state
                selectContainer.style.display = 'none';
                confirmBtn.style.display = 'none';
                okBtn.style.display = 'none';

                // Check if this is the last state
                if (total_states <= 1) {
                    modalTitle.textContent = 'Cannot Delete State';
                    modalBody.textContent = 'You must have at least one state. Create another state before deleting this one.';
                    okBtn.style.display = 'inline-block';
                    modal.classList.add('active');
                    return;
                }

                // Check if state has tasks
                if (state.task_count > 0) {
                    modalTitle.textContent = 'Delete State';
                    modalBody.innerHTML = `The state "<strong>${escapeHtml(state.name)}</strong>" contains <strong>${state.task_count} task${state.task_count > 1 ? 's' : ''}</strong>. Select a state to move these tasks to:`;

                    // Populate select with other states
                    select.innerHTML = '';
                    statesList.filter(s => s.id !== stateId).forEach(s => {
                        const option = document.createElement('option');
                        option.value = s.id;
                        option.textContent = s.name;
                        select.appendChild(option);
                    });

                    selectContainer.style.display = 'block';
                    confirmBtn.style.display = 'inline-block';
                    confirmBtn.onclick = () => confirmDeleteState(true);
                } else {
                    modalTitle.textContent = 'Delete State';
                    modalBody.innerHTML = `Are you sure you want to delete the state "<strong>${escapeHtml(state.name)}</strong>"?`;
                    confirmBtn.style.display = 'inline-block';
                    confirmBtn.onclick = () => confirmDeleteState(false);
                }

                modal.classList.add('active');
            } catch (error) {
                console.error('Error getting state info:', error);
            }
        }

        function closeDeleteStateModal() {
            document.getElementById('delete-state-modal').classList.remove('active');
            deleteStateId = null;
            deleteStateButton = null;
        }

        async function confirmDeleteState(moveTasks) {
            if (!deleteStateId) return;

            try {
                const moveToStateId = moveTasks ? document.getElementById('delete-state-move-to').value : null;

                const response = await fetch(`/tasks/api/states/${deleteStateId}/delete/`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-CSRFToken': csrfToken
                    },
                    body: JSON.stringify({ move_to_state_id: moveToStateId ? parseInt(moveToStateId) : null })
                });

                const data = await response.json();
                if (data.success) {
                    // If tasks were moved, update the UI
                    if (moveTasks && moveToStateId) {
                        // Move task cards in the UI
                        const sourceBody = document.querySelector(`.state-group-body[data-state-id="${deleteStateId}"]`);
                        const targetBody = document.querySelector(`.state-group-body[data-state-id="${moveToStateId}"]`);
                        if (sourceBody && targetBody) {
                            const cards = sourceBody.querySelectorAll('.task-card');
                            cards.forEach(card => targetBody.appendChild(card));
                        }
                    }

                    // Remove from state list in settings panel
                    if (deleteStateButton) {
                        const stateItem = deleteStateButton.closest('.state-item');
                        if (stateItem) stateItem.remove();
                    }

                    // Remove state group from tasks panel
                    const stateGroup = document.querySelector(`.state-group[data-state-id="${deleteStateId}"]`);
                    if (stateGroup) stateGroup.remove();

                    // Remove metric pill
                    const metricPill = document.querySelector(`.metric-pill[data-state-id="${deleteStateId}"]`);
                    if (metricPill) metricPill.remove();

                    // Update local list
                    statesList = statesList.filter(s => s.id !== deleteStateId);

                    // Update counts
                    updateStateCounts();

                    // Update inbox/terminal labels
                    updateStateTypeLabels();

                    closeDeleteStateModal();
                } else {
                    showAlertModal(data.error || 'Failed to delete state', 'Error');
                }
            } catch (error) {
                console.error('Error deleting state:', error);
            }
        }

        function updateStateCounts() {
            document.querySelectorAll('.state-group').forEach(group => {
                const stateId = group.dataset.stateId;
                const body = group.querySelector('.state-group-body');
                const count = body ? body.querySelectorAll('.task-card').length : 0;
                const countEl = document.getElementById(`panel-count-${stateId}`);
                if (countEl) countEl.textContent = count;

                // Update metric pill
                const metricPill = document.querySelector(`.metric-pill[data-state-id="${stateId}"] .metric-count`);
                if (metricPill) metricPill.textContent = count;
            });
        }

        // ========== Drag and Drop for States ==========

        let draggedItem = null;

        function setupDragEvents(item) {
            item.addEventListener('dragstart', handleDragStart);
            item.addEventListener('dragend', handleDragEnd);
            item.addEventListener('dragover', handleDragOver);
            item.addEventListener('dragleave', handleDragLeave);
            item.addEventListener('drop', handleDrop);
        }

        function handleDragStart(e) {
            draggedItem = this;
            this.classList.add('dragging');
            e.dataTransfer.effectAllowed = 'move';
        }

        function handleDragEnd(e) {
            this.classList.remove('dragging');
            document.querySelectorAll('.state-item').forEach(item => {
                item.classList.remove('drag-over-top', 'drag-over-bottom');
            });
            document.getElementById('state-list').classList.remove('drag-over-bottom');
            draggedItem = null;
        }

        function handleDragOver(e) {
            e.preventDefault();
            if (this === draggedItem) return;

            const rect = this.getBoundingClientRect();
            const midpoint = rect.top + rect.height / 2;

            // Clear all indicators first
            document.querySelectorAll('.state-item').forEach(item => {
                item.classList.remove('drag-over-top', 'drag-over-bottom');
            });

            // Show indicator on top or bottom half
            if (e.clientY < midpoint) {
                this.classList.add('drag-over-top');
            } else {
                this.classList.add('drag-over-bottom');
            }
        }

        function handleDragLeave(e) {
            this.classList.remove('drag-over-top', 'drag-over-bottom');
        }

        function handleDrop(e) {
            e.preventDefault();
            this.classList.remove('drag-over-top', 'drag-over-bottom');

            if (this === draggedItem) return;

            const stateList = document.getElementById('state-list');
            const rect = this.getBoundingClientRect();
            const midpoint = rect.top + rect.height / 2;
            const dropOnTop = e.clientY < midpoint;

            if (dropOnTop) {
                // Insert before this item
                stateList.insertBefore(draggedItem, this);
            } else {
                // Insert after this item
                if (this.nextSibling) {
                    stateList.insertBefore(draggedItem, this.nextSibling);
                } else {
                    stateList.appendChild(draggedItem);
                }
            }

            // Save new order
            saveStateOrder();
        }

        // Allow dropping at the end of the list by handling drops on the container
        const stateListContainer = document.getElementById('state-list');
        stateListContainer.addEventListener('dragover', function(e) {
            e.preventDefault();
            // Only show bottom indicator if cursor is below all items
            const items = [...this.querySelectorAll('.state-item:not(#no-states):not(.dragging)')];
            if (items.length > 0) {
                const lastItem = items[items.length - 1];
                const lastItemRect = lastItem.getBoundingClientRect();
                if (e.clientY > lastItemRect.bottom) {
                    this.classList.add('drag-over-bottom');
                } else {
                    this.classList.remove('drag-over-bottom');
                }
            }
        });

        stateListContainer.addEventListener('dragleave', function(e) {
            this.classList.remove('drag-over-bottom');
        });

        stateListContainer.addEventListener('drop', function(e) {
            if (!draggedItem) return;

            // Check if we're dropping at the bottom (not on a specific item)
            const items = [...this.querySelectorAll('.state-item:not(#no-states):not(.dragging)')];
            if (items.length > 0) {
                const lastItem = items[items.length - 1];
                const lastItemRect = lastItem.getBoundingClientRect();
                if (e.clientY > lastItemRect.bottom) {
                    e.preventDefault();
                    this.classList.remove('drag-over-bottom');
                    this.appendChild(draggedItem);
                    saveStateOrder();
                }
            }
        });

        async function saveStateOrder() {
            const stateList = document.getElementById('state-list');
            const items = [...stateList.querySelectorAll('.state-item:not(#no-states)')];
            const order = items.map(item => parseInt(item.dataset.stateId));

            try {
                const response = await fetch('/tasks/api/states/reorder/', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-CSRFToken': csrfToken
                    },
                    body: JSON.stringify({ order })
                });

                const data = await response.json();
                if (data.success) {
                    // Update local order values
                    items.forEach((item, index) => {
                        item.dataset.order = index;
                        const state = statesList.find(s => s.id === parseInt(item.dataset.stateId));
                        if (state) state.order = index;
                    });

                    // Reorder the state groups in the Tasks panel to match
                    const tasksContent = document.getElementById('tasks-content');
                    if (tasksContent) {
                        const stateGroups = [...tasksContent.querySelectorAll('.state-group')];
                        order.forEach(stateId => {
                            const group = stateGroups.find(g => parseInt(g.dataset.stateId) === stateId);
                            if (group) {
                                tasksContent.appendChild(group);
                            }
                        });
                    }

                    // Reorder the metric pills in the collapsed Tasks header
                    const metricsContainer = document.getElementById('tasks-collapsed-metrics');
                    if (metricsContainer) {
                        const pills = [...metricsContainer.querySelectorAll('.metric-pill')];
                        order.forEach(stateId => {
                            const pill = pills.find(p => parseInt(p.dataset.stateId) === stateId);
                            if (pill) {
                                metricsContainer.appendChild(pill);
                            }
                        });
                    }

                    // Update inbox/terminal labels
                    updateStateTypeLabels();
                }
            } catch (error) {
                console.error('Error saving state order:', error);
            }
        }

        // Initialize drag events for existing items
        document.querySelectorAll('.state-item:not(#no-states)').forEach(item => {
            setupDragEvents(item);
        });

        // ========== Kanban Board ==========

        // Update column counts
        function updateKanbanCounts() {
            document.querySelectorAll('.kanban-column-body').forEach(body => {
                const stateId = body.dataset.stateId;
                const count = body.querySelectorAll('.kanban-card').length;
                const countEl = document.getElementById(`count-state-${stateId}`);
                if (countEl) countEl.textContent = count;
            });
        }

        // Initialize counts on load
        updateKanbanCounts();

        // Make kanban cards clickable
        document.querySelectorAll('.kanban-card').forEach(card => {
            card.addEventListener('click', function(e) {
                if (e.target.closest('.kanban-card')) {
                    openKanbanPanel(this.dataset.taskId);
                }
            });
        });

        async function fetchAndOpenPanel(taskId) {
            currentTaskId = taskId;

            // Fetch task details from server
            try {
                const response = await fetch(`/tasks/api/${taskId}/`);
                const data = await response.json();

                if (data.success) {
                    document.getElementById('panel-title').value = data.task.title;
                    document.getElementById('panel-details').value = data.task.details || '';
                    document.getElementById('panel-critical').checked = data.task.critical;

                    // Update "Mark as done" button state
                    const markDoneBtn = document.getElementById('panel-mark-done');
                    const terminalStateId = getTerminalStateId();
                    const isAlreadyDone = data.task.state_id === terminalStateId;
                    markDoneBtn.dataset.stateId = data.task.state_id || '';

                    if (isAlreadyDone) {
                        markDoneBtn.classList.add('is-done');
                        markDoneBtn.querySelector('span').textContent = 'Task Complete!';
                        markDoneBtn.querySelector('i').className = 'bi bi-check-circle-fill';
                    } else {
                        markDoneBtn.classList.remove('is-done');
                        markDoneBtn.querySelector('span').textContent = 'Task Complete!';
                        markDoneBtn.querySelector('i').className = 'bi bi-check-circle';
                    }

                    // Show markdown preview if there's content, otherwise show edit mode
                    if (data.task.details && data.task.details.trim()) {
                        detailsPreview.innerHTML = marked.parse(data.task.details);
                        detailsTextarea.style.display = 'none';
                        detailsPreview.style.display = 'block';
                        markdownEditBtn.classList.remove('active');
                        markdownViewBtn.classList.add('active');
                    } else {
                        detailsPreview.style.display = 'none';
                        detailsTextarea.style.display = 'block';
                        markdownEditBtn.classList.add('active');
                        markdownViewBtn.classList.remove('active');
                    }
                }
            } catch (error) {
                console.error('Error fetching task:', error);
            }

            document.getElementById('panel-overlay').classList.add('active');
            document.getElementById('slide-panel').classList.add('active');
            setTimeout(autoResizeTitle, 10);
        }

        async function openKanbanPanel(taskId) {
            await fetchAndOpenPanel(taskId);
        }

        async function openTaskPanel(taskId) {
            const card = document.querySelector(`.task-card[data-task-id="${taskId}"]`);
            if (!card) return;
            await fetchAndOpenPanel(taskId);
        }

        // Kanban drag and drop
        let draggedKanbanCard = null;
        let dropIndicator = null;

        // Create drop indicator element
        function createDropIndicator() {
            const indicator = document.createElement('div');
            indicator.className = 'kanban-drop-indicator';
            indicator.style.cssText = 'height: 3px; background: #6B9080; border-radius: 2px; margin: 0.25rem 0;';
            return indicator;
        }

        function setupKanbanCardDrag(card) {
            card.addEventListener('dragstart', function(e) {
                draggedKanbanCard = this;
                this.classList.add('dragging');
                e.dataTransfer.effectAllowed = 'move';
                e.dataTransfer.setData('text/plain', this.dataset.taskId);
                // Delay to allow drag image to be captured
                setTimeout(() => {
                    this.style.opacity = '0.4';
                }, 0);
            });

            card.addEventListener('dragend', function(e) {
                this.classList.remove('dragging');
                this.style.opacity = '1';
                document.querySelectorAll('.kanban-column-body').forEach(body => {
                    body.classList.remove('drag-over');
                });
                // Remove any drop indicator
                if (dropIndicator && dropIndicator.parentElement) {
                    dropIndicator.remove();
                }
                dropIndicator = null;
                draggedKanbanCard = null;
            });
        }

        // Get drop position within column
        function getDropPosition(columnBody, y) {
            const cards = [...columnBody.querySelectorAll('.kanban-card:not(.dragging)')];

            for (const card of cards) {
                const rect = card.getBoundingClientRect();
                const midpoint = rect.top + rect.height / 2;
                if (y < midpoint) {
                    return { element: card, position: 'before' };
                }
            }
            return { element: null, position: 'end' };
        }

        // Setup drag events for existing kanban cards
        document.querySelectorAll('.kanban-card').forEach(card => {
            setupKanbanCardDrag(card);
        });

        // Setup drop zones on column bodies
        document.querySelectorAll('.kanban-column-body').forEach(body => {
            body.addEventListener('dragover', function(e) {
                e.preventDefault();
                if (!draggedKanbanCard) return;

                this.classList.add('drag-over');

                // Show drop indicator
                const { element, position } = getDropPosition(this, e.clientY);

                if (!dropIndicator) {
                    dropIndicator = createDropIndicator();
                }

                if (position === 'end') {
                    this.appendChild(dropIndicator);
                } else if (element) {
                    element.parentElement.insertBefore(dropIndicator, element);
                }
            });

            body.addEventListener('dragleave', function(e) {
                if (!this.contains(e.relatedTarget)) {
                    this.classList.remove('drag-over');
                    if (dropIndicator && dropIndicator.parentElement === this) {
                        dropIndicator.remove();
                    }
                }
            });

            body.addEventListener('drop', async function(e) {
                e.preventDefault();
                this.classList.remove('drag-over');

                if (!draggedKanbanCard) return;

                const newStateId = parseInt(this.dataset.stateId);
                const taskId = parseInt(draggedKanbanCard.dataset.taskId);
                const oldBody = draggedKanbanCard.parentElement;
                const changedColumn = (oldBody !== this);

                // Get drop position
                const { element, position } = getDropPosition(this, e.clientY);

                // Remove drop indicator
                if (dropIndicator && dropIndicator.parentElement) {
                    dropIndicator.remove();
                }

                // Move card to new position
                if (position === 'end') {
                    this.appendChild(draggedKanbanCard);
                } else if (element) {
                    element.parentElement.insertBefore(draggedKanbanCard, element);
                }

                updateKanbanCounts();

                // Get new order of all cards in this column
                const cardIds = [...this.querySelectorAll('.kanban-card')].map(c => parseInt(c.dataset.taskId));

                // Update state if changed columns
                if (changedColumn) {
                    try {
                        const response = await fetch(`/tasks/api/${taskId}/update/`, {
                            method: 'PATCH',
                            headers: {
                                'Content-Type': 'application/json',
                                'X-CSRFToken': csrfToken
                            },
                            body: JSON.stringify({ state_id: newStateId })
                        });

                        const data = await response.json();
                        if (!data.success) {
                            console.error('Failed to update task state');
                            oldBody.appendChild(draggedKanbanCard);
                            updateKanbanCounts();
                            return;
                        }
                    } catch (error) {
                        console.error('Error updating task state:', error);
                        oldBody.appendChild(draggedKanbanCard);
                        updateKanbanCounts();
                        return;
                    }
                }

                // Save new order
                try {
                    await fetch('/tasks/api/tasks/reorder/', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'X-CSRFToken': csrfToken
                        },
                        body: JSON.stringify({ task_ids: cardIds })
                    });
                } catch (error) {
                    console.error('Error saving task order:', error);
                }
            });
        });

        function handleTaskStateChange(task) {
            const kanbanCard = document.querySelector(`.kanban-card[data-task-id="${task.id}"]`);

            if (task.state_id) {
                const targetColumn = document.querySelector(`.kanban-column-body[data-state-id="${task.state_id}"]`);
                if (targetColumn) {
                    if (kanbanCard) {
                        // Move to correct column if needed
                        if (kanbanCard.parentElement !== targetColumn) {
                            targetColumn.appendChild(kanbanCard);
                        }
                        // Update card content
                        updateKanbanCard(kanbanCard, task);
                    } else {
                        // Create new kanban card
                        const card = createKanbanCard(task);
                        targetColumn.appendChild(card);
                    }
                }
            }
            updateKanbanCounts();

            // Update task cards in states view
            const statesTaskCard = document.querySelector(`#states-content .task-card[data-task-id="${task.id}"]`);
            if (statesTaskCard) {
                // Update title
                const titleEl = statesTaskCard.querySelector('.task-card-title');
                if (titleEl) titleEl.textContent = task.title;
                // Update critical class
                statesTaskCard.classList.toggle('critical', task.critical);
                // Move to correct state group if state changed
                const targetStateId = task.state_id || 'none';
                const targetBody = document.querySelector(`#states-content .state-group-body[data-state-id="${targetStateId}"]`);
                if (targetBody && statesTaskCard.parentElement !== targetBody) {
                    targetBody.appendChild(statesTaskCard);
                    updatePanelCounts();
                }
            }

            // Update task cards in tags view
            document.querySelectorAll(`#tags-content .task-card[data-task-id="${task.id}"]`).forEach(card => {
                const titleEl = card.querySelector('.task-card-title');
                if (titleEl) titleEl.textContent = task.title;
                card.classList.toggle('critical', task.critical);
            });
        }

        function createKanbanCard(task) {
            const card = document.createElement('div');
            card.className = 'kanban-card' + (task.critical ? ' critical' : '');
            card.dataset.taskId = task.id;
            card.draggable = true;

            // Build tags HTML
            const tags = task.tags || taskTagsMap[task.id] || [];
            const tagsHtml = tags.length > 0
                ? `<div class="task-card-tags">${tags.map(t => `<span class="task-tag-pill">${escapeHtml(t.name)}</span>`).join('')}</div>`
                : '';

            card.innerHTML = `
                <div class="kanban-card-title" title="${escapeHtml(task.title)}">${escapeHtml(task.title)}</div>
                ${tagsHtml}
            `;
            card.addEventListener('click', function() {
                openKanbanPanel(task.id);
            });
            setupKanbanCardDrag(card);
            setupKanbanCardContextMenu(card);
            return card;
        }

        function updateKanbanCard(card, task) {
            card.className = 'kanban-card' + (task.critical ? ' critical' : '');

            // Update title
            const title = card.querySelector('.kanban-card-title');
            title.textContent = task.title;
            title.title = task.title;

            // Update tags
            const tags = task.tags || taskTagsMap[task.id] || [];
            updateTaskCardTags(task.id, tags);

            // Update critical class
            if (task.critical) {
                card.classList.add('critical');
            } else {
                card.classList.remove('critical');
            }
        }

        // ========== Right-Click Context Menu ==========

        let contextMenuTaskId = null;
        let pendingTagChanges = { toAdd: [], toRemove: [] };

        function showContextMenu(e, taskId, openPanelFn) {
            e.preventDefault();
            contextMenuTaskId = taskId;
            pendingTagChanges = { toAdd: [], toRemove: [] };  // Reset pending changes

            // Remove any existing menu
            closeContextMenu();

            // Find the card (could be kanban-card or task-card)
            let card = document.querySelector(`.kanban-card[data-task-id="${taskId}"]`);
            if (!card) {
                card = document.querySelector(`.task-card[data-task-id="${taskId}"]`);
            }
            const isCritical = card ? card.classList.contains('critical') : false;
            const isScheduled = !!taskCalendarStartTimeMap[taskId];
            const taskTags = taskTagsMap[taskId] || [];

            // Build menu HTML
            let menuHtml = `
                <div class="task-context-menu-item" onclick="${openPanelFn}(${taskId}); closeContextMenu();">
                    <i class="bi bi-pencil"></i>
                    Edit Task
                </div>
                <div class="task-context-menu-divider"></div>
                <div class="task-context-menu-item" onclick="toggleTaskCritical(${taskId})">
                    <i class="bi bi-exclamation-circle${isCritical ? '-fill' : ''}"></i>
                    ${isCritical ? 'Unmark Critical' : 'Mark Critical'}
                </div>
                ${isScheduled ? `
                <div class="task-context-menu-item" onclick="removeFromCalendar(${taskId})">
                    <i class="bi bi-calendar-x"></i>
                    Remove from Calendar
                </div>
                ` : ''}
                <div class="task-context-menu-divider"></div>
                <div class="task-context-menu-submenu">
                    <div class="task-context-menu-item">
                        <i class="bi bi-tags"></i>
                        Tags
                        <span class="submenu-arrow"><i class="bi bi-chevron-right"></i></span>
                    </div>
                    <div class="task-context-menu-submenu-content">
                        <div class="task-context-menu-item" onclick="event.stopPropagation(); promptNewTag(${taskId});">
                            <i class="bi bi-plus-circle"></i>
                            Create New Tag...
                        </div>
                        <div class="task-context-menu-divider"></div>
            `;

            // Show existing tags with checkmarks for assigned ones
            if (tagsList.length === 0) {
                menuHtml += `<div class="task-context-menu-item" style="color: #999; font-style: italic;">No tags yet</div>`;
            } else {
                tagsList.forEach(tag => {
                    const hasTag = taskTags.some(t => t.id === tag.id);
                    menuHtml += `
                        <div class="task-context-menu-item tag-toggle-item${hasTag ? ' active' : ''}" data-tag-id="${tag.id}" data-has-tag="${hasTag}" onclick="event.stopPropagation(); toggleTagLocally(this, ${tag.id})">
                            <i class="bi bi-${hasTag ? 'check-square-fill' : 'square'}"></i>
                            ${escapeHtml(tag.name)}
                        </div>
                    `;
                });
            }

            menuHtml += `
                        <div class="task-context-menu-divider"></div>
                        <div class="task-context-menu-item save-tags-btn" onclick="event.stopPropagation(); savePendingTags(${taskId});">
                            <i class="bi bi-check2"></i>
                            Save Tags
                        </div>
                    </div>
                </div>
                <div class="task-context-menu-divider"></div>
                <div class="task-context-menu-item danger" onclick="deleteTaskFromMenu(${taskId})">
                    <i class="bi bi-trash"></i>
                    Delete Task
                </div>
            `;

            const menu = document.createElement('div');
            menu.className = 'task-context-menu';
            menu.id = 'task-context-menu';
            menu.innerHTML = menuHtml;

            // Position the menu
            document.body.appendChild(menu);

            // Adjust position to keep menu in viewport
            const menuRect = menu.getBoundingClientRect();
            let x = e.clientX;
            let y = e.clientY;

            if (x + menuRect.width > window.innerWidth) {
                x = window.innerWidth - menuRect.width - 10;
            }
            if (y + menuRect.height > window.innerHeight) {
                y = window.innerHeight - menuRect.height - 10;
            }

            menu.style.left = x + 'px';
            menu.style.top = y + 'px';

            // Close on outside click
            setTimeout(() => {
                document.addEventListener('click', closeContextMenu);
                document.addEventListener('contextmenu', closeContextMenu);
            }, 0);
        }

        function closeContextMenu() {
            const menu = document.getElementById('task-context-menu');
            if (menu) {
                menu.remove();
            }
            document.removeEventListener('click', closeContextMenu);
            document.removeEventListener('contextmenu', closeContextMenu);
            contextMenuTaskId = null;
        }

        function toggleTagLocally(element, tagId) {
            const currentlyHasTag = element.dataset.hasTag === 'true';
            const newHasTag = !currentlyHasTag;

            // Update visual state
            element.dataset.hasTag = newHasTag.toString();
            element.classList.toggle('active', newHasTag);
            const icon = element.querySelector('i');
            icon.className = `bi bi-${newHasTag ? 'check-square-fill' : 'square'}`;

            // Track the change
            if (newHasTag) {
                // Adding tag - remove from toRemove if present, add to toAdd
                pendingTagChanges.toRemove = pendingTagChanges.toRemove.filter(id => id !== tagId);
                if (!pendingTagChanges.toAdd.includes(tagId)) {
                    pendingTagChanges.toAdd.push(tagId);
                }
            } else {
                // Removing tag - remove from toAdd if present, add to toRemove
                pendingTagChanges.toAdd = pendingTagChanges.toAdd.filter(id => id !== tagId);
                if (!pendingTagChanges.toRemove.includes(tagId)) {
                    pendingTagChanges.toRemove.push(tagId);
                }
            }
        }

        async function savePendingTags(taskId) {
            const originalTags = taskTagsMap[taskId] || [];
            const originalTagIds = originalTags.map(t => t.id);

            // Calculate final tag state
            let finalTagIds = [...originalTagIds];

            // Remove tags
            pendingTagChanges.toRemove.forEach(tagId => {
                finalTagIds = finalTagIds.filter(id => id !== tagId);
            });

            // Add tags
            pendingTagChanges.toAdd.forEach(tagId => {
                if (!finalTagIds.includes(tagId)) {
                    finalTagIds.push(tagId);
                }
            });

            // Apply all changes
            try {
                // Remove tags first
                for (const tagId of pendingTagChanges.toRemove) {
                    if (originalTagIds.includes(tagId)) {
                        await fetch(`/tasks/api/${taskId}/tags/remove/`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json', 'X-CSRFToken': csrfToken },
                            body: JSON.stringify({ tag_id: tagId })
                        });
                    }
                }

                // Add new tags
                for (const tagId of pendingTagChanges.toAdd) {
                    if (!originalTagIds.includes(tagId)) {
                        await fetch(`/tasks/api/${taskId}/tags/add/`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json', 'X-CSRFToken': csrfToken },
                            body: JSON.stringify({ tag_id: tagId })
                        });
                    }
                }

                // Build final tags array
                const finalTags = tagsList.filter(t => finalTagIds.includes(t.id));
                taskTagsMap[taskId] = finalTags;
                updateTaskCardTags(taskId, finalTags);

            } catch (error) {
                console.error('Error saving tags:', error);
            }

            closeContextMenu();
        }

        function updateTaskCardTags(taskId, tags) {
            // Update both task-card and kanban-card in states view
            const taskCard = document.querySelector(`#states-content .task-card[data-task-id="${taskId}"]`);
            const kanbanCard = document.querySelector(`.kanban-card[data-task-id="${taskId}"]`);

            [taskCard, kanbanCard].forEach(card => {
                if (!card) return;

                // Remove existing tags container
                let tagsContainer = card.querySelector('.task-card-tags');
                if (tagsContainer) tagsContainer.remove();

                // Add new tags if any
                if (tags && tags.length > 0) {
                    tagsContainer = document.createElement('div');
                    tagsContainer.className = 'task-card-tags';
                    tags.forEach(tag => {
                        const pill = document.createElement('span');
                        pill.className = 'task-tag-pill';
                        pill.textContent = tag.name;
                        tagsContainer.appendChild(pill);
                    });
                    card.appendChild(tagsContainer);
                }
            });

            // Rebuild tag groups if currently viewing by tags (with highlight on the affected task)
            if (currentGroupBy === 'tags') {
                buildTagGroups(taskId);
            }
        }

        async function toggleTaskTag(taskId, tagId, hasTag) {
            try {
                const url = hasTag
                    ? `/tasks/api/${taskId}/tags/remove/`
                    : `/tasks/api/${taskId}/tags/add/`;
                const response = await fetch(url, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-CSRFToken': csrfToken
                    },
                    body: JSON.stringify({ tag_id: tagId })
                });

                const data = await response.json();
                if (data.success) {
                    taskTagsMap[taskId] = data.task_tags;
                    updateTaskCardTags(taskId, data.task_tags);
                }
            } catch (error) {
                console.error('Error toggling task tag:', error);
            }
            closeContextMenu();
        }

        async function promptNewTag(taskId) {
            closeContextMenu();
            const name = await showPromptModal('Enter the name for the new tag:', 'New Tag', 'Tag name');
            if (!name || !name.trim()) return;

            try {
                const response = await fetch(`/tasks/api/${taskId}/tags/add/`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-CSRFToken': csrfToken
                    },
                    body: JSON.stringify({ name: name.trim() })
                });

                const data = await response.json();
                if (data.success) {
                    taskTagsMap[taskId] = data.task_tags;
                    updateTaskCardTags(taskId, data.task_tags);
                    // Also add to tagsList if it's a new tag
                    const newTag = data.task_tags.find(t => t.name === name.trim());
                    if (newTag && !tagsList.some(t => t.id === newTag.id)) {
                        tagsList.push(newTag);
                    }
                }
            } catch (error) {
                console.error('Error adding tag:', error);
            }
        }

        async function toggleTaskCritical(taskId) {
            closeContextMenu();

            // Find the card (could be kanban-card or task-card)
            let card = document.querySelector(`.kanban-card[data-task-id="${taskId}"]`);
            let taskCard = document.querySelector(`.task-card[data-task-id="${taskId}"]`);
            const isCritical = (card && card.classList.contains('critical')) || (taskCard && taskCard.classList.contains('critical'));

            try {
                const response = await fetch(`/tasks/api/${taskId}/update/`, {
                    method: 'PATCH',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-CSRFToken': csrfToken
                    },
                    body: JSON.stringify({ critical: !isCritical })
                });

                const data = await response.json();
                if (data.success) {
                    // Update the kanban card
                    if (card) {
                        updateKanbanCard(card, data.task);
                    }
                    // Update the task card
                    if (taskCard) {
                        if (data.task.critical) {
                            taskCard.classList.add('critical');
                        } else {
                            taskCard.classList.remove('critical');
                        }
                    }
                }
            } catch (error) {
                console.error('Error toggling task critical:', error);
            }
        }

        async function deleteTaskFromMenu(taskId) {
            closeContextMenu();
            const confirmed = await showConfirmModal('Are you sure you want to delete this task?', 'Delete Task', 'Delete');
            if (!confirmed) return;
            await deleteTask(taskId);
        }

        // Add right-click handler to kanban cards
        function setupKanbanCardContextMenu(card) {
            card.addEventListener('contextmenu', function(e) {
                showContextMenu(e, parseInt(this.dataset.taskId), 'openKanbanPanel');
            });
        }

        // Setup for existing cards
        document.querySelectorAll('.kanban-card').forEach(card => {
            setupKanbanCardContextMenu(card);
        });

        // ========== Filter Functionality ==========

        // ========== Cookie Helpers ==========
        function setCookie(name, value, days = 365) {
            const expires = new Date(Date.now() + days * 864e5).toUTCString();
            document.cookie = name + '=' + encodeURIComponent(JSON.stringify(value)) + '; expires=' + expires + '; path=/';
        }

        function getCookie(name) {
            const value = document.cookie.split('; ').find(row => row.startsWith(name + '='));
            if (value) {
                try {
                    return JSON.parse(decodeURIComponent(value.split('=')[1]));
                } catch (e) {
                    return null;
                }
            }
            return null;
        }

        let showCompletedTasks = false;  // Default to hiding completed tasks

        function saveFilterSettings() {
            setCookie('taskFilters', {
                critical: activeFilters.critical,
                today: activeFilters.today,
                tags: activeFilters.tags,
                groupBy: currentGroupBy,
                showCompleted: showCompletedTasks
            });
        }

        const filterIcon = document.getElementById('filter-icon');
        const filterDropdown = document.getElementById('filter-dropdown');
        const filterBadge = document.getElementById('filter-badge');
        const filterCritical = document.getElementById('filter-critical');
        const filterClear = document.getElementById('filter-clear');
        const filterTagsList = document.getElementById('filter-tags-list');
        const filterTagsSearch = document.getElementById('filter-tags-search');

        let activeFilters = {
            critical: false,
            today: false,
            tags: []  // Array of tag IDs to filter by
        };

        // Get tag counts from taskTagsMap
        function getTagCounts() {
            const counts = {};
            Object.values(taskTagsMap).forEach(tags => {
                tags.forEach(tag => {
                    counts[tag.id] = (counts[tag.id] || 0) + 1;
                });
            });
            return counts;
        }

        // Populate filter tags list (top 5 by count + search)
        function populateFilterTags(searchTerm = '') {
            const tagCounts = getTagCounts();
            const searchLower = searchTerm.toLowerCase();

            // Sort tags by count (descending), then by name
            const sortedTags = [...tagsList].sort((a, b) => {
                const countDiff = (tagCounts[b.id] || 0) - (tagCounts[a.id] || 0);
                if (countDiff !== 0) return countDiff;
                return a.name.localeCompare(b.name);
            });

            // Filter tags based on search term
            let tagsToShow;
            if (searchTerm) {
                // Show all matching tags when searching
                tagsToShow = sortedTags.filter(tag =>
                    tag.name.toLowerCase().includes(searchLower)
                );
            } else {
                // Show top 5 tags by count
                tagsToShow = sortedTags.slice(0, 5);
            }

            // Build HTML
            filterTagsList.innerHTML = '';

            if (tagsToShow.length === 0) {
                filterTagsList.innerHTML = '<div style="color: #6c757d; font-size: 0.8rem; padding: 0.25rem 0;">No matching tags</div>';
                return;
            }

            tagsToShow.forEach(tag => {
                const count = tagCounts[tag.id] || 0;
                const isChecked = activeFilters.tags.includes(tag.id);
                const label = document.createElement('label');
                label.className = 'filter-option';
                label.innerHTML = `
                    <input type="checkbox" class="filter-tag-checkbox" data-tag-id="${tag.id}" ${isChecked ? 'checked' : ''}>
                    <span class="task-tag-pill" style="font-size: 0.75rem;">${tag.name}</span>
                    <span style="color: #6c757d; font-size: 0.7rem; margin-left: auto;">(${count})</span>
                `;
                filterTagsList.appendChild(label);

                // Add event listener
                const checkbox = label.querySelector('.filter-tag-checkbox');
                checkbox.addEventListener('change', function() {
                    const tagId = parseInt(this.dataset.tagId);
                    if (this.checked) {
                        if (!activeFilters.tags.includes(tagId)) {
                            activeFilters.tags.push(tagId);
                        }
                    } else {
                        activeFilters.tags = activeFilters.tags.filter(id => id !== tagId);
                    }
                    applyFilters();
                    saveFilterSettings();
                });
            });

            // Show hint if more tags exist and not searching
            if (!searchTerm && sortedTags.length > 5) {
                const hint = document.createElement('div');
                hint.style.cssText = 'color: #6c757d; font-size: 0.75rem; padding: 0.25rem 0; text-align: center;';
                hint.textContent = `+ ${sortedTags.length - 5} more tags (use search)`;
                filterTagsList.appendChild(hint);
            }
        }

        // Search tags
        filterTagsSearch.addEventListener('input', function() {
            populateFilterTags(this.value.trim());
        });

        // Initial population
        populateFilterTags();

        // Toggle filter dropdown
        filterIcon.addEventListener('click', function(e) {
            e.stopPropagation();
            filterDropdown.classList.toggle('active');
            filterIcon.classList.toggle('active', filterDropdown.classList.contains('active'));
        });

        // Close filter dropdown on outside click
        document.addEventListener('click', function(e) {
            if (!filterDropdown.contains(e.target) && e.target !== filterIcon) {
                filterDropdown.classList.remove('active');
                filterIcon.classList.remove('active');
            }
        });

        // Handle critical filter change
        filterCritical.addEventListener('change', function() {
            activeFilters.critical = this.checked;
            applyFilters();
            saveFilterSettings();
        });

        const filterToday = document.getElementById('filter-today');
        filterToday.addEventListener('change', function() {
            activeFilters.today = this.checked;
            applyFilters();
            saveFilterSettings();
        });

        // Tag filter changes are handled dynamically in populateFilterTags()

        // Clear all filters
        filterClear.addEventListener('click', function() {
            activeFilters.critical = false;
            activeFilters.today = false;
            activeFilters.tags = [];
            filterCritical.checked = false;
            filterToday.checked = false;
            filterTagsSearch.value = '';
            populateFilterTags();  // Repopulate to uncheck all
            applyFilters();
            saveFilterSettings();
        });

        // ========== Group By Functionality ==========
        let currentGroupBy = 'states';  // 'states' or 'tags'

        document.querySelectorAll('input[name="group-by"]').forEach(radio => {
            radio.addEventListener('change', function() {
                currentGroupBy = this.value;
                switchGroupBy(currentGroupBy);
                saveFilterSettings();
            });
        });

        function switchGroupBy(groupBy) {
            const statesContent = document.getElementById('states-content');
            const tagsContent = document.getElementById('tags-content');
            const tasksCollapsedMetrics = document.getElementById('tasks-collapsed-metrics');

            if (groupBy === 'states') {
                statesContent.style.display = '';
                tagsContent.style.display = 'none';
                // Show state-based metrics in collapsed view
                updateCollapsedMetricsForStates();
            } else {
                statesContent.style.display = 'none';
                tagsContent.style.display = '';
                buildTagGroups();
                // Show tag-based metrics in collapsed view
                updateCollapsedMetricsForTags();
            }
            updatePanelCounts();
            updateCompletedToggleVisibility();
        }

        // Update collapsed metrics to show states
        function updateCollapsedMetricsForStates() {
            const tasksCollapsedMetrics = document.getElementById('tasks-collapsed-metrics');
            // Rebuild with state metrics
            let html = '';
            {% for state in states %}
            html += '<span class="metric-pill" data-state-id="{{ state.id }}">{{ state.name }}: <span class="metric-count">0</span></span>';
            {% endfor %}
            tasksCollapsedMetrics.innerHTML = html;
            updatePanelCounts();
        }

        // Update collapsed metrics to show top 3 tags
        function updateCollapsedMetricsForTags() {
            const tasksCollapsedMetrics = document.getElementById('tasks-collapsed-metrics');

            // Count tasks per tag
            const tagCounts = {};
            Object.entries(taskTagsMap).forEach(([taskId, tags]) => {
                tags.forEach(tag => {
                    tagCounts[tag.id] = tagCounts[tag.id] || { name: tag.name, count: 0 };
                    tagCounts[tag.id].count++;
                });
            });

            // Sort by count and take top 3
            const topTags = Object.entries(tagCounts)
                .sort((a, b) => b[1].count - a[1].count)
                .slice(0, 3);

            let html = '';
            topTags.forEach(([tagId, tag]) => {
                html += `<span class="metric-pill" data-tag-id="${tagId}">${escapeHtml(tag.name)}: <span class="metric-count">${tag.count}</span></span>`;
            });

            tasksCollapsedMetrics.innerHTML = html || '<span class="metric-pill">No tags</span>';
        }

        // Update completed toggle visibility based on group-by mode and panel state
        function updateCompletedToggleVisibility() {
            const toggle = document.getElementById('completed-toggle-inline');
            const tasksPanel = document.getElementById('tasks-panel');
            const isTagsView = currentGroupBy === 'tags';
            const isExpanded = !tasksPanel.classList.contains('collapsed');

            if (isTagsView && isExpanded) {
                toggle.classList.add('visible');
            } else {
                toggle.classList.remove('visible');
            }
        }

        // Toggle for showing/hiding completed tasks in tag view
        document.getElementById('show-completed-toggle').addEventListener('change', function() {
            showCompletedTasks = this.checked;
            if (currentGroupBy === 'tags') {
                buildTagGroups();
            }
            saveFilterSettings();
        });

        // Load saved filter settings from cookies on page load
        (function loadFilterSettings() {
            const saved = getCookie('taskFilters');
            if (saved) {
                // Restore critical filter
                if (saved.critical) {
                    activeFilters.critical = true;
                    filterCritical.checked = true;
                }

                // Restore today filter
                if (saved.today) {
                    activeFilters.today = true;
                    filterToday.checked = true;
                }

                // Restore tag filters
                if (saved.tags && saved.tags.length > 0) {
                    activeFilters.tags = saved.tags;
                    populateFilterTags();  // Re-populate to reflect saved checked states
                }

                // Restore group by
                if (saved.groupBy) {
                    currentGroupBy = saved.groupBy;
                    const radio = document.querySelector(`input[name="group-by"][value="${saved.groupBy}"]`);
                    if (radio) {
                        radio.checked = true;
                    }
                }

                // Restore show completed toggle
                if (saved.showCompleted !== undefined) {
                    showCompletedTasks = saved.showCompleted;
                    const toggle = document.getElementById('show-completed-toggle');
                    toggle.checked = saved.showCompleted;
                }

                // Switch to tags view if needed (after showCompleted is set)
                if (saved.groupBy === 'tags') {
                    switchGroupBy('tags');
                }

                // Apply the restored filters
                applyFilters();
            }
        })();

        function buildTagGroups(highlightTaskId = null) {
            const tagsContent = document.getElementById('tags-content');

            // Remember which groups were expanded before rebuilding
            const expandedTagIds = [];
            tagsContent.querySelectorAll('.state-group:not(.collapsed)').forEach(group => {
                expandedTagIds.push(group.dataset.tagId);
            });

            tagsContent.innerHTML = '';

            // Get the terminal state ID to filter completed tasks
            const terminalStateId = getTerminalStateId();

            // Get all tasks from the state groups
            const allTasks = [];
            document.querySelectorAll('#states-content .task-card').forEach(card => {
                const taskId = parseInt(card.dataset.taskId);
                const title = card.querySelector('.task-card-title').textContent;
                const isCritical = card.classList.contains('critical');
                const tags = taskTagsMap[taskId] || [];

                // Check if task is in terminal state
                const stateGroup = card.closest('.state-group');
                const rawStateId = stateGroup ? stateGroup.dataset.stateId : null;
                const taskStateId = rawStateId === 'none' ? null : (rawStateId ? parseInt(rawStateId) : null);
                const isCompleted = taskStateId === terminalStateId;

                // Skip completed tasks if showCompletedTasks is false
                if (!showCompletedTasks && isCompleted) {
                    return;
                }

                allTasks.push({ id: taskId, title, isCritical, isCompleted, tags, element: card });
            });

            // Group tasks by tag
            const tagGroups = {};
            const untaggedTasks = [];

            allTasks.forEach(task => {
                if (task.tags.length === 0) {
                    untaggedTasks.push(task);
                } else {
                    task.tags.forEach(tag => {
                        if (!tagGroups[tag.id]) {
                            tagGroups[tag.id] = { name: tag.name, tasks: [] };
                        }
                        tagGroups[tag.id].tasks.push(task);
                    });
                }
            });

            // Create tag group elements (sorted by tag name)
            const sortedTagIds = Object.keys(tagGroups).sort((a, b) =>
                tagGroups[a].name.localeCompare(tagGroups[b].name)
            );

            sortedTagIds.forEach(tagId => {
                const group = tagGroups[tagId];
                // If highlighting a task, put it at the top of each group it belongs to
                if (highlightTaskId) {
                    group.tasks.sort((a, b) => {
                        if (a.id === highlightTaskId) return -1;
                        if (b.id === highlightTaskId) return 1;
                        return 0;
                    });
                }
                const groupEl = createTagGroup(tagId, group.name, group.tasks);
                tagsContent.appendChild(groupEl);
            });

            // Create Untagged group at the bottom (also sort highlighted task to top)
            if (highlightTaskId) {
                untaggedTasks.sort((a, b) => {
                    if (a.id === highlightTaskId) return -1;
                    if (b.id === highlightTaskId) return 1;
                    return 0;
                });
            }
            const untaggedGroup = createTagGroup('untagged', 'Untagged', untaggedTasks);
            tagsContent.appendChild(untaggedGroup);

            // Restore previously expanded groups
            expandedTagIds.forEach(tagId => {
                const group = tagsContent.querySelector(`.state-group[data-tag-id="${tagId}"]`);
                if (group) {
                    group.classList.remove('collapsed');
                }
            });

            // If highlighting a task, expand its groups and apply visual feedback
            if (highlightTaskId) {
                const taskCards = tagsContent.querySelectorAll(`.task-card[data-task-id="${highlightTaskId}"]`);
                taskCards.forEach(card => {
                    // Expand the parent group (if not already expanded)
                    const group = card.closest('.state-group');
                    if (group) {
                        group.classList.remove('collapsed');
                    }
                    // Apply highlight animation (same as new task highlight)
                    card.classList.add('highlight-new');
                    setTimeout(() => {
                        card.classList.remove('highlight-new');
                    }, 4500);
                });
            }
        }

        function createTagGroup(tagId, tagName, tasks) {
            const group = document.createElement('div');
            group.className = 'state-group collapsed';
            group.dataset.tagId = tagId;

            group.innerHTML = `
                <div class="state-group-header" onclick="toggleStateGroup(this)">
                    <div class="state-group-left">
                        <i class="bi bi-tag state-group-icon"></i>
                        <span class="state-group-name">${escapeHtml(tagName)}</span>
                    </div>
                    <div class="state-group-right">
                        <span class="state-group-count">${tasks.length}</span>
                        <i class="bi bi-chevron-down state-group-toggle"></i>
                    </div>
                </div>
                <div class="state-group-body" data-tag-id="${tagId}"></div>
            `;

            const body = group.querySelector('.state-group-body');
            tasks.forEach(task => {
                const card = document.createElement('div');
                const calendarTime = taskCalendarStartTimeMap[task.id];
                const isScheduled = !!calendarTime;
                const isToday = isScheduled && isScheduledForToday(calendarTime);
                card.className = 'task-card' + (task.isCritical ? ' critical' : '') + (isScheduled ? ' scheduled' : '') + (task.isCompleted ? ' completed' : '');
                card.dataset.taskId = task.id;
                card.draggable = true;

                // Only show tag pills if task has multiple tags
                const tagsHtml = task.tags.length > 1
                    ? `<div class="task-card-tags">${task.tags.map(t => `<span class="task-tag-pill">${escapeHtml(t.name)}</span>`).join('')}</div>`
                    : '';

                const todayIconHtml = isToday ? '<i class="bi bi-brightness-high-fill task-card-today-icon"></i>' : '';
                const criticalIconHtml = task.isCritical ? '<i class="bi bi-exclamation-circle-fill task-critical-icon"></i>' : '';
                const hasIcons = isToday || task.isCritical;
                const iconsHtml = hasIcons ? `<div class="task-card-icons">${todayIconHtml}${criticalIconHtml}</div>` : '';

                card.innerHTML = `
                    <div class="task-card-content">
                        <div class="task-card-title">${escapeHtml(task.title)}</div>
                        ${tagsHtml}
                        ${iconsHtml}
                    </div>
                `;

                // Setup event handlers
                setupTaskCardDragEvents(card);
                card.addEventListener('contextmenu', function(e) {
                    e.preventDefault();
                    showContextMenu(e, parseInt(this.dataset.taskId), 'openTaskPanel');
                });
                body.appendChild(card);
            });

            // Setup drag-drop for tag group body
            setupTagGroupDragDrop(body, tagId, tagName);

            // Also setup drag-drop for the header (for dropping on collapsed groups)
            const header = group.querySelector('.state-group-header');
            setupTagGroupHeaderDragDrop(header, group, tagId, tagName);

            return group;
        }

        // Setup drag-drop handlers for tag group headers
        function setupTagGroupHeaderDragDrop(header, group, tagId, tagName) {
            header.addEventListener('dragover', function(e) {
                e.preventDefault();
                if (!draggedTaskCard) return;
                e.dataTransfer.dropEffect = 'move';
                this.classList.add('drag-over');
            });

            header.addEventListener('dragleave', function(e) {
                this.classList.remove('drag-over');
            });

            header.addEventListener('drop', async function(e) {
                e.preventDefault();
                e.stopPropagation();
                this.classList.remove('drag-over');
                if (!draggedTaskCard) return;

                const taskId = parseInt(draggedTaskCard.dataset.taskId);
                const currentTags = taskTagsMap[taskId] || [];

                if (tagId === 'untagged') {
                    // Dropping into Untagged - remove all tags
                    for (const tag of currentTags) {
                        try {
                            await fetch(`/tasks/api/${taskId}/tags/remove/`, {
                                method: 'POST',
                                headers: {
                                    'Content-Type': 'application/json',
                                    'X-CSRFToken': csrfToken
                                },
                                body: JSON.stringify({ tag_id: tag.id })
                            });
                        } catch (error) {
                            console.error('Error removing tag:', error);
                        }
                    }
                    taskTagsMap[taskId] = [];
                } else {
                    // Dropping into a tag group - add this tag if not already present
                    const numericTagId = parseInt(tagId);
                    const hasTag = currentTags.some(t => t.id === numericTagId);
                    if (!hasTag) {
                        try {
                            const response = await fetch(`/tasks/api/${taskId}/tags/add/`, {
                                method: 'POST',
                                headers: {
                                    'Content-Type': 'application/json',
                                    'X-CSRFToken': csrfToken
                                },
                                body: JSON.stringify({ tag_id: numericTagId })
                            });
                            const data = await response.json();
                            if (data.success) {
                                taskTagsMap[taskId] = data.task_tags;
                            }
                        } catch (error) {
                            console.error('Error adding tag:', error);
                        }
                    }
                }

                // Rebuild tag groups to reflect changes
                buildTagGroups();
            });
        }

        // Setup drag-drop handlers for tag groups
        function setupTagGroupDragDrop(body, tagId, tagName) {
            body.addEventListener('dragover', function(e) {
                e.preventDefault();
                if (!draggedTaskCard) return;
                e.dataTransfer.dropEffect = 'move';
                this.classList.add('drag-over');
            });

            body.addEventListener('dragleave', function(e) {
                if (!this.contains(e.relatedTarget)) {
                    this.classList.remove('drag-over');
                }
            });

            body.addEventListener('drop', async function(e) {
                e.preventDefault();
                this.classList.remove('drag-over');
                if (!draggedTaskCard) return;

                const taskId = parseInt(draggedTaskCard.dataset.taskId);
                const currentTags = taskTagsMap[taskId] || [];

                if (tagId === 'untagged') {
                    // Dropping into Untagged - remove all tags
                    for (const tag of currentTags) {
                        try {
                            await fetch(`/tasks/api/${taskId}/tags/remove/`, {
                                method: 'POST',
                                headers: {
                                    'Content-Type': 'application/json',
                                    'X-CSRFToken': csrfToken
                                },
                                body: JSON.stringify({ tag_id: tag.id })
                            });
                        } catch (error) {
                            console.error('Error removing tag:', error);
                        }
                    }
                    taskTagsMap[taskId] = [];
                } else {
                    // Dropping into a tag group - add this tag if not already present
                    const numericTagId = parseInt(tagId);
                    const hasTag = currentTags.some(t => t.id === numericTagId);
                    if (!hasTag) {
                        try {
                            const response = await fetch(`/tasks/api/${taskId}/tags/add/`, {
                                method: 'POST',
                                headers: {
                                    'Content-Type': 'application/json',
                                    'X-CSRFToken': csrfToken
                                },
                                body: JSON.stringify({ tag_id: numericTagId })
                            });
                            const data = await response.json();
                            if (data.success) {
                                taskTagsMap[taskId] = data.task_tags;
                            }
                        } catch (error) {
                            console.error('Error adding tag:', error);
                        }
                    }
                }

                // Rebuild tag groups to reflect changes
                buildTagGroups();
            });
        }

        function applyFilters() {
            // Filter both kanban cards and task cards in the new panel layout
            const allCards = document.querySelectorAll('.kanban-card, .task-card');
            let visibleCount = 0;

            allCards.forEach(card => {
                let show = true;
                const taskId = parseInt(card.dataset.taskId);

                // Filter by critical
                if (activeFilters.critical && !card.classList.contains('critical')) {
                    show = false;
                }

                // Filter by today (only show tasks scheduled for today)
                if (show && activeFilters.today) {
                    const calendarTime = taskCalendarStartTimeMap[taskId];
                    if (!calendarTime || !isScheduledForToday(calendarTime)) {
                        show = false;
                    }
                }

                // Filter by tags (task must have at least one of the selected tags)
                if (show && activeFilters.tags.length > 0) {
                    const taskTags = taskTagsMap[taskId] || [];
                    const taskTagIds = taskTags.map(t => t.id);
                    const hasMatchingTag = activeFilters.tags.some(tagId => taskTagIds.includes(tagId));
                    if (!hasMatchingTag) {
                        show = false;
                    }
                }

                card.style.display = show ? '' : 'none';
                if (show) visibleCount++;
            });

            // Update filter badge
            const filterCount = (activeFilters.critical ? 1 : 0) + (activeFilters.today ? 1 : 0);
            if (filterCount > 0) {
                filterBadge.textContent = filterCount;
                filterBadge.style.display = 'flex';
                filterIcon.classList.add('active');
            } else {
                filterBadge.style.display = 'none';
                if (!filterDropdown.classList.contains('active')) {
                    filterIcon.classList.remove('active');
                }
            }

            // Update counts for both layouts
            updateKanbanCounts();
            if (typeof updatePanelCounts === 'function') {
                updatePanelCounts();
            }
        }

        // Helper function to check if a calendar time is today
        function isScheduledForToday(calendarTimeStr) {
            if (!calendarTimeStr) return false;
            const calendarDate = new Date(calendarTimeStr);
            const today = new Date();
            return calendarDate.getFullYear() === today.getFullYear() &&
                   calendarDate.getMonth() === today.getMonth() &&
                   calendarDate.getDate() === today.getDate();
        }

        // Override updateKanbanCounts to respect filters
        const originalUpdateKanbanCounts = updateKanbanCounts;
        updateKanbanCounts = function() {
            document.querySelectorAll('.kanban-column-body').forEach(body => {
                const stateId = body.dataset.stateId;
                const count = body.querySelectorAll('.kanban-card:not([style*="display: none"])').length;
                const countEl = document.getElementById(`count-state-${stateId}`);
                if (countEl) countEl.textContent = count;
            });
        };

        // ========== Two-Panel Layout ==========

        // Panel collapse/expand
        const tasksPanel = document.getElementById('tasks-panel');
        const calendarPanel = document.getElementById('calendar-panel');
        const tasksPanelHeader = document.getElementById('tasks-panel-header');
        const calendarPanelHeader = document.getElementById('calendar-panel-header');
        const tasksPanelWrapper = document.getElementById('tasks-panel-wrapper');

        // Sync wrapper class with tasks panel collapsed state
        function updateTasksPanelWrapperState() {
            if (tasksPanelWrapper) {
                const isCollapsed = tasksPanel.classList.contains('collapsed');
                const isMinimized = tasksPanel.classList.contains('minimized');
                tasksPanelWrapper.classList.toggle('panel-collapsed', isCollapsed);
                tasksPanelWrapper.classList.toggle('panel-minimized', isMinimized);
            }
            updateCompletedToggleVisibility();
        }

        // Sync vertical collapse/expand between Tasks and Calendar
        function toggleBothPanelsCollapsed() {
            const isTasksCollapsed = tasksPanel.classList.contains('collapsed');
            // Toggle both panels together
            if (isTasksCollapsed) {
                tasksPanel.classList.remove('collapsed');
                calendarPanel.classList.remove('collapsed');
            } else {
                tasksPanel.classList.add('collapsed');
                calendarPanel.classList.add('collapsed');
            }
            updateTasksPanelWrapperState();
        }

        if (tasksPanelHeader) {
            tasksPanelHeader.addEventListener('click', function(e) {
                // Don't toggle collapsed if clicking expand button or completed toggle
                if (e.target.closest('.panel-expand-btn')) return;
                if (e.target.closest('.completed-toggle-inline')) return;
                // Don't toggle vertical collapse if panel is horizontally minimized or expanded
                if (tasksPanel.classList.contains('minimized')) return;
                if (tasksPanel.classList.contains('expanded')) return;
                toggleBothPanelsCollapsed();
            });
        }

        if (calendarPanelHeader) {
            calendarPanelHeader.addEventListener('click', function(e) {
                // Don't toggle collapsed if clicking expand button
                if (e.target.closest('.panel-expand-btn')) return;
                // Don't toggle vertical collapse if panel is horizontally minimized or expanded
                if (calendarPanel.classList.contains('minimized')) return;
                if (calendarPanel.classList.contains('expanded')) return;
                toggleBothPanelsCollapsed();
            });
        }

        // Panel expand/minimize (horizontal)
        const tasksExpandBtn = document.getElementById('tasks-expand-btn');
        const calendarExpandBtn = document.getElementById('calendar-expand-btn');

        function togglePanelExpand(expandPanel, minimizePanel) {
            const isExpanded = expandPanel.classList.contains('expanded');
            const isMinimized = expandPanel.classList.contains('minimized');

            if (isExpanded || isMinimized) {
                // Either panel in expanded/minimized state - return both to normal 50/50 state
                expandPanel.classList.remove('collapsed', 'minimized', 'expanded');
                minimizePanel.classList.remove('collapsed', 'minimized', 'expanded');
            } else {
                // Normal state - expand this panel, minimize the other
                expandPanel.classList.add('expanded');
                expandPanel.classList.remove('collapsed', 'minimized');
                minimizePanel.classList.add('minimized');
                minimizePanel.classList.remove('collapsed', 'expanded');
            }
        }

        if (tasksExpandBtn) {
            tasksExpandBtn.addEventListener('click', function(e) {
                e.stopPropagation();
                togglePanelExpand(tasksPanel, calendarPanel);
                updateTasksPanelWrapperState();
            });
        }

        if (calendarExpandBtn) {
            calendarExpandBtn.addEventListener('click', function(e) {
                e.stopPropagation();
                togglePanelExpand(calendarPanel, tasksPanel);
                updateTasksPanelWrapperState();
            });
        }

        // Click anywhere on minimized panel to expand it back to normal
        tasksPanel.addEventListener('click', function(e) {
            if (this.classList.contains('minimized')) {
                // Return both panels to normal 50/50 state
                tasksPanel.classList.remove('collapsed', 'minimized', 'expanded');
                calendarPanel.classList.remove('collapsed', 'minimized', 'expanded');
                updateTasksPanelWrapperState();
            }
        });

        calendarPanel.addEventListener('click', function(e) {
            if (this.classList.contains('minimized')) {
                // Return both panels to normal 50/50 state
                tasksPanel.classList.remove('collapsed', 'minimized', 'expanded');
                calendarPanel.classList.remove('collapsed', 'minimized', 'expanded');
                updateTasksPanelWrapperState();
            }
        });

        // Initialize wrapper state on page load
        updateTasksPanelWrapperState();

        // State group collapse/expand
        function toggleStateGroup(header) {
            const group = header.closest('.state-group');
            group.classList.toggle('collapsed');
        }

        // Generate hourly calendar (7am to 6pm)
        function generateHourlyCalendar() {
            const grid = document.getElementById('hourly-grid');
            if (!grid) return;

            grid.innerHTML = '';

            for (let hour = 7; hour <= 18; hour++) {
                const hourRow = document.createElement('div');
                hourRow.className = 'hour-row';
                hourRow.dataset.hour = hour;

                const ampm = hour >= 12 ? 'PM' : 'AM';
                const displayHour = hour > 12 ? hour - 12 : hour;

                hourRow.innerHTML = `
                    <div class="hour-label">${displayHour}${ampm}</div>
                    <div class="hour-content" data-hour="${hour}"></div>
                `;

                grid.appendChild(hourRow);
            }
        }

        // Set today's date in calendar header
        function setCalendarDate() {
            const dateEl = document.getElementById('calendar-date-text');
            if (!dateEl) return;

            const today = new Date();
            const options = { weekday: 'long', month: 'long', day: 'numeric' };
            dateEl.textContent = today.toLocaleDateString('en-US', options);
        }

        // Calendar events from database (UTC ISO timestamps)
        const calendarEvents = {{ calendar_events|safe }};

        // Time blocks from database (UTC ISO timestamps)
        let timeBlocks = {{ time_blocks|safe }};

        // Render calendar events on the hourly grid (using browser's local timezone)
        function renderCalendarEvents() {
            if (!calendarEvents || calendarEvents.length === 0) return;

            // Get today's date boundaries in local timezone
            const now = new Date();
            const todayStart = new Date(now.getFullYear(), now.getMonth(), now.getDate());
            const todayEnd = new Date(todayStart.getTime() + 24 * 60 * 60 * 1000);

            calendarEvents.forEach(event => {
                // Skip all-day events for now (could add a separate section)
                if (event.is_all_day) return;

                // Parse UTC timestamps and convert to local time
                const startDate = new Date(event.start);
                const endDate = new Date(event.end);

                // Skip events that don't overlap with today (in local timezone)
                if (endDate <= todayStart || startDate >= todayEnd) return;

                // Get local hours and minutes
                const startHourLocal = startDate.getHours();
                const startMinuteLocal = startDate.getMinutes();
                const endHourLocal = endDate.getHours();
                const endMinuteLocal = endDate.getMinutes();

                // Find the starting hour row (clamp to visible range 7-18)
                const startHour = Math.max(7, Math.min(18, startHourLocal));
                const endHour = Math.max(7, Math.min(19, endHourLocal + (endMinuteLocal > 0 ? 1 : 0)));

                // Skip events that end before 7am or start after 6pm
                if (endHourLocal < 7 || startHourLocal > 18) return;

                const hourContent = document.querySelector(`.hour-content[data-hour="${startHour}"]`);
                if (!hourContent) return;

                // Calculate position and height
                const minuteOffset = startHourLocal >= 7 ? startMinuteLocal : 0;
                const topPercent = (minuteOffset / 60) * 100;

                // Calculate duration in hours (for height)
                const startMinutes = startHourLocal * 60 + startMinuteLocal;
                const endMinutes = endHourLocal * 60 + endMinuteLocal;
                let durationMinutes = endMinutes - startMinutes;

                // Clamp to visible range
                const visibleStartMinutes = Math.max(7 * 60, startMinutes);
                const visibleEndMinutes = Math.min(19 * 60, endMinutes);
                durationMinutes = visibleEndMinutes - visibleStartMinutes;

                // Minimum 30 minutes to ensure text isn't cut off
                durationMinutes = Math.max(30, durationMinutes);

                const durationHours = durationMinutes / 60;
                const heightPx = durationHours * 60; // 60px per hour

                // Create event element
                const eventEl = document.createElement('div');
                eventEl.className = 'hour-event';
                eventEl.style.position = 'absolute';
                eventEl.style.top = `${topPercent}%`;
                eventEl.style.left = '4px';
                eventEl.style.right = '4px';
                eventEl.style.height = `${heightPx - 4}px`;
                eventEl.style.zIndex = '1';
                eventEl.style.borderRadius = '4px';
                eventEl.style.overflow = 'hidden';

                // Format time in local timezone
                const startAmPm = startHourLocal >= 12 ? 'PM' : 'AM';
                const startDisplayHour = startHourLocal > 12 ? startHourLocal - 12 : (startHourLocal === 0 ? 12 : startHourLocal);
                const startMinuteStr = startMinuteLocal.toString().padStart(2, '0');

                eventEl.innerHTML = `
                    <div style="display: flex; align-items: center; gap: 4px; white-space: nowrap; overflow: hidden;">
                        <span style="font-weight: 500; overflow: hidden; text-overflow: ellipsis;">${event.subject}</span>
                    </div>
                    <div style="font-size: 0.65rem; opacity: 0.9;">${startDisplayHour}:${startMinuteStr} ${startAmPm}${event.location ? '  ' + event.location : ''}</div>
                `;

                eventEl.title = `${event.subject}${event.location ? '\n' + event.location : ''}`;

                hourContent.appendChild(eventEl);
            });
        }

        // ========== Time Blocks on Calendar ==========

        // State for time block resize
        let timeBlockResizeState = null;

        // Render time blocks on the calendar
        function renderTimeBlocks() {
            // Remove existing time block elements
            document.querySelectorAll('.calendar-time-block').forEach(el => el.remove());

            if (!timeBlocks || timeBlocks.length === 0) return;

            // Get today's date boundaries in local timezone
            const now = new Date();
            const todayStart = new Date(now.getFullYear(), now.getMonth(), now.getDate());
            const todayEnd = new Date(todayStart.getTime() + 24 * 60 * 60 * 1000);

            timeBlocks.forEach(block => {
                const startDate = new Date(block.start);
                const endDate = new Date(block.end);

                // Skip blocks not for today
                if (endDate <= todayStart || startDate >= todayEnd) return;

                const startHour = startDate.getHours();
                const startMinute = startDate.getMinutes();

                // Skip if outside visible range (7am-6pm)
                if (startHour < 7 || startHour > 18) return;

                const hourContent = document.querySelector(`.hour-content[data-hour="${startHour}"]`);
                if (!hourContent) return;

                // Calculate duration and height
                const durationMinutes = (endDate - startDate) / (1000 * 60);
                const heightPercent = (durationMinutes / 60) * 100;

                // Create time block element
                const blockEl = document.createElement('div');
                blockEl.className = 'calendar-time-block';
                blockEl.dataset.blockId = block.id;
                blockEl.title = block.name;

                // Create content wrapper
                const contentWrapper = document.createElement('div');
                contentWrapper.className = 'time-block-content';

                // Add title text (click to edit)
                const titleSpan = document.createElement('span');
                titleSpan.className = 'time-block-title';
                titleSpan.textContent = block.name;
                titleSpan.addEventListener('click', function(e) {
                    e.stopPropagation();
                    startTimeBlockInlineEdit(blockEl, block.id, titleSpan);
                });
                contentWrapper.appendChild(titleSpan);

                blockEl.appendChild(contentWrapper);

                // Add remove button
                const removeBtn = document.createElement('button');
                removeBtn.className = 'remove-btn';
                removeBtn.innerHTML = '<i class="bi bi-x"></i>';
                removeBtn.title = 'Remove event';
                removeBtn.addEventListener('click', async function(e) {
                    e.stopPropagation();
                    await deleteTimeBlock(block.id);
                });
                blockEl.appendChild(removeBtn);

                // Add resize handle
                const resizeHandle = document.createElement('div');
                resizeHandle.className = 'time-block-resize-handle';
                resizeHandle.addEventListener('mousedown', function(e) {
                    e.stopPropagation();
                    e.preventDefault();
                    startTimeBlockResize(blockEl, block.id, startDate);
                });
                blockEl.appendChild(resizeHandle);

                // Position based on minute within the hour
                const topPercent = (startMinute / 60) * 100;
                blockEl.style.top = `${topPercent}%`;
                blockEl.style.height = `${heightPercent}%`;
                blockEl.style.minHeight = '28px';

                hourContent.appendChild(blockEl);
            });
        }

        // Start resizing a time block
        function startTimeBlockResize(blockEl, blockId, startDate) {
            const block = timeBlocks.find(b => b.id === blockId);
            if (!block) return;

            timeBlockResizeState = {
                blockEl,
                blockId,
                startDate,
                initialHeight: parseFloat(blockEl.style.height) || 50,
                startY: event.clientY
            };

            blockEl.classList.add('resizing');
            document.addEventListener('mousemove', handleTimeBlockResize);
            document.addEventListener('mouseup', endTimeBlockResize);
        }

        function handleTimeBlockResize(e) {
            if (!timeBlockResizeState) return;

            const { blockEl, startY, initialHeight } = timeBlockResizeState;
            const deltaY = e.clientY - startY;
            const hourHeight = 60; // pixels per hour
            const deltaPercent = (deltaY / hourHeight) * 100;

            // Minimum 30 minutes (50%)
            const newHeight = Math.max(50, initialHeight + deltaPercent);
            blockEl.style.height = `${newHeight}%`;
        }

        async function endTimeBlockResize() {
            if (!timeBlockResizeState) return;

            const { blockEl, blockId, startDate } = timeBlockResizeState;
            const heightPercent = parseFloat(blockEl.style.height) || 50;

            // Calculate new end time based on height
            const durationMinutes = (heightPercent / 100) * 60;
            const endDate = new Date(startDate.getTime() + durationMinutes * 60 * 1000);
            const endTimeUTC = endDate.toISOString();

            blockEl.classList.remove('resizing');

            // Update on server
            try {
                const response = await fetch(`/tasks/api/time-blocks/${blockId}/update/`, {
                    method: 'PATCH',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-CSRFToken': csrfToken
                    },
                    body: JSON.stringify({ end_time: endTimeUTC })
                });

                const data = await response.json();
                if (data.success) {
                    // Update local data
                    const block = timeBlocks.find(b => b.id === blockId);
                    if (block) {
                        block.end = data.time_block.end;
                    }
                }
            } catch (error) {
                console.error('Error updating time block:', error);
            }

            document.removeEventListener('mousemove', handleTimeBlockResize);
            document.removeEventListener('mouseup', endTimeBlockResize);
            timeBlockResizeState = null;
        }

        // Delete a time block
        async function deleteTimeBlock(blockId) {
            try {
                const response = await fetch(`/tasks/api/time-blocks/${blockId}/delete/`, {
                    method: 'DELETE',
                    headers: {
                        'X-CSRFToken': csrfToken
                    }
                });

                const data = await response.json();
                if (data.success) {
                    // Remove from local array
                    timeBlocks = timeBlocks.filter(b => b.id !== blockId);
                    // Re-render
                    renderTimeBlocks();
                }
            } catch (error) {
                console.error('Error deleting time block:', error);
            }
        }

        // Inline edit a time block name
        function startTimeBlockInlineEdit(blockEl, blockId, titleSpan) {
            // Don't start another edit if already editing
            if (titleSpan.querySelector('input')) return;

            const currentName = titleSpan.textContent;
            const input = document.createElement('input');
            input.type = 'text';
            input.className = 'time-block-inline-input';
            input.value = currentName;

            // Replace title with input
            titleSpan.textContent = '';
            titleSpan.appendChild(input);
            input.focus();
            input.select();

            // Save on blur or Enter
            async function saveEdit() {
                const newName = input.value.trim();
                if (newName && newName !== currentName) {
                    try {
                        const response = await fetch(`/tasks/api/time-blocks/${blockId}/update/`, {
                            method: 'PATCH',
                            headers: {
                                'Content-Type': 'application/json',
                                'X-CSRFToken': csrfToken
                            },
                            body: JSON.stringify({ name: newName })
                        });

                        const data = await response.json();
                        if (data.success) {
                            // Update local data
                            const block = timeBlocks.find(b => b.id === blockId);
                            if (block) {
                                block.name = data.time_block.name;
                            }
                            titleSpan.textContent = newName;
                            blockEl.title = newName;
                        } else {
                            titleSpan.textContent = currentName;
                        }
                    } catch (error) {
                        console.error('Error updating time block name:', error);
                        titleSpan.textContent = currentName;
                    }
                } else {
                    titleSpan.textContent = currentName || newName;
                }
            }

            input.addEventListener('blur', saveEdit);
            input.addEventListener('keydown', function(e) {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    input.blur();
                } else if (e.key === 'Escape') {
                    e.preventDefault();
                    titleSpan.textContent = currentName;
                }
            });
        }

        // ========== Block Time Modal ==========

        const addEventBtn = document.getElementById('add-event-btn');
        const addEventModal = document.getElementById('add-event-modal');
        const eventNameInput = document.getElementById('event-name-input');
        const eventTimeInput = document.getElementById('event-time-input');
        const addEventOk = document.getElementById('add-event-ok');
        const addEventCancel = document.getElementById('add-event-cancel');

        if (addEventBtn) {
            addEventBtn.addEventListener('click', function(e) {
                e.stopPropagation();
                // Set default time to next hour
                const now = new Date();
                const nextHour = new Date(now.getTime() + 60 * 60 * 1000);
                nextHour.setMinutes(0, 0, 0);
                const hours = nextHour.getHours().toString().padStart(2, '0');
                const minutes = nextHour.getMinutes().toString().padStart(2, '0');
                eventTimeInput.value = `${hours}:${minutes}`;
                eventNameInput.value = '';
                addEventModal.classList.add('active');
                eventNameInput.focus();
            });
        }

        if (addEventCancel) {
            addEventCancel.addEventListener('click', function() {
                addEventModal.classList.remove('active');
            });
        }

        if (addEventModal) {
            addEventModal.addEventListener('click', function(e) {
                if (e.target === addEventModal) {
                    addEventModal.classList.remove('active');
                }
            });
        }

        if (addEventOk) {
            addEventOk.addEventListener('click', async function() {
                const name = eventNameInput.value.trim();
                const time = eventTimeInput.value;

                if (!name) {
                    eventNameInput.focus();
                    return;
                }

                if (!time) {
                    eventTimeInput.focus();
                    return;
                }

                // Create start time in local timezone, then convert to UTC
                const [hours, minutes] = time.split(':').map(Number);
                const now = new Date();
                const startLocal = new Date(now.getFullYear(), now.getMonth(), now.getDate(), hours, minutes);
                const startUTC = startLocal.toISOString();

                try {
                    const response = await fetch('/tasks/api/time-blocks/create/', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'X-CSRFToken': csrfToken
                        },
                        body: JSON.stringify({
                            name: name,
                            start_time: startUTC
                        })
                    });

                    const data = await response.json();
                    if (data.success) {
                        // Add to local array
                        timeBlocks.push(data.time_block);
                        // Re-render
                        renderTimeBlocks();
                        // Close modal
                        addEventModal.classList.remove('active');
                    } else {
                        alert(data.error || 'Failed to create event');
                    }
                } catch (error) {
                    console.error('Error creating time block:', error);
                    alert('Failed to create event');
                }
            });
        }

        // Handle Enter key in modal inputs
        if (eventNameInput) {
            eventNameInput.addEventListener('keydown', function(e) {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    addEventOk.click();
                }
            });
        }

        if (eventTimeInput) {
            eventTimeInput.addEventListener('keydown', function(e) {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    addEventOk.click();
                }
            });
        }

        // ========== Scheduled Tasks on Calendar ==========

        // Render scheduled tasks on the calendar
        function renderScheduledTasks() {
            // Remove existing scheduled task elements
            document.querySelectorAll('.calendar-scheduled-task').forEach(el => el.remove());

            // Get today's date boundaries in local timezone
            const now = new Date();
            const todayStart = new Date(now.getFullYear(), now.getMonth(), now.getDate());
            const todayEnd = new Date(todayStart.getTime() + 24 * 60 * 60 * 1000);

            // Iterate through tasks with calendar_start_time
            Object.entries(taskCalendarStartTimeMap).forEach(([taskId, calendarStartTime]) => {
                if (!calendarStartTime) return;

                const startDate = new Date(calendarStartTime);

                // Skip tasks not scheduled for today
                if (startDate < todayStart || startDate >= todayEnd) return;

                const hour = startDate.getHours();
                const minute = startDate.getMinutes();

                // Skip if outside visible range (7am-6pm)
                if (hour < 7 || hour > 18) return;

                const hourContent = document.querySelector(`.hour-content[data-hour="${hour}"]`);
                if (!hourContent) return;

                // Get task info from the task card
                const taskCard = document.querySelector(`.task-card[data-task-id="${taskId}"]`);
                if (!taskCard) return;

                const titleEl = taskCard.querySelector('.task-card-title');
                const title = titleEl ? titleEl.textContent : 'Task';

                // Calculate duration in minutes (default to 30 if no end time)
                let durationMinutes = 30;
                const calendarEndTime = taskCalendarEndTimeMap[taskId];
                if (calendarEndTime) {
                    const endDate = new Date(calendarEndTime);
                    durationMinutes = Math.max(15, (endDate - startDate) / (1000 * 60));
                }

                // Create scheduled task element
                const taskEl = document.createElement('div');
                taskEl.className = 'calendar-scheduled-task';
                taskEl.dataset.taskId = taskId;
                taskEl.draggable = true;
                taskEl.title = title;

                // Create content wrapper
                const contentWrapper = document.createElement('div');
                contentWrapper.className = 'calendar-task-content';

                // Add task icon
                const taskIcon = document.createElement('i');
                taskIcon.className = 'bi bi-check2-circle calendar-task-icon';
                contentWrapper.appendChild(taskIcon);

                // Add title text
                const titleSpan = document.createElement('span');
                titleSpan.className = 'calendar-task-title';
                titleSpan.textContent = title;
                contentWrapper.appendChild(titleSpan);

                taskEl.appendChild(contentWrapper);

                // Add remove button
                const removeBtn = document.createElement('button');
                removeBtn.className = 'remove-btn';
                removeBtn.innerHTML = '<i class="bi bi-x"></i>';
                removeBtn.title = 'Remove from calendar';
                removeBtn.addEventListener('click', async function(e) {
                    e.stopPropagation();
                    await removeFromCalendar(parseInt(taskId));
                });
                taskEl.appendChild(removeBtn);

                // Add resize handle at bottom
                const resizeHandle = document.createElement('div');
                resizeHandle.className = 'calendar-task-resize-handle';
                resizeHandle.addEventListener('mousedown', function(e) {
                    e.stopPropagation();
                    e.preventDefault();
                    startTaskResize(taskEl, taskId, startDate);
                });
                taskEl.appendChild(resizeHandle);

                // Position based on minute within the hour (absolute positioning)
                const topPercent = (minute / 60) * 100;
                taskEl.style.top = `${topPercent}%`;

                // Calculate height based on duration (each hour content is 100%)
                // Duration in minutes / 60 * 100 = percent of hour
                const heightPercent = (durationMinutes / 60) * 100;
                taskEl.style.height = `${heightPercent}%`;

                // Setup drag events for scheduled task
                setupScheduledTaskDragEvents(taskEl);

                // Right-click context menu for calendar tasks
                taskEl.addEventListener('contextmenu', function(e) {
                    e.preventDefault();
                    e.stopPropagation();
                    showContextMenu(e, parseInt(this.dataset.taskId), 'openTaskPanel');
                });

                hourContent.appendChild(taskEl);
            });
        }

        // Handle task resize by dragging bottom edge
        let resizeState = null;

        function startTaskResize(taskEl, taskId, startDate) {
            const hourContent = taskEl.closest('.hour-content');
            const hourlyGrid = document.getElementById('hourly-grid');

            resizeState = {
                taskEl,
                taskId,
                startDate,
                initialHeight: taskEl.offsetHeight,
                hourContentHeight: hourContent.offsetHeight
            };

            document.addEventListener('mousemove', handleTaskResize);
            document.addEventListener('mouseup', endTaskResize);
            taskEl.classList.add('resizing');
        }

        function handleTaskResize(e) {
            if (!resizeState) return;

            const { taskEl, hourContentHeight } = resizeState;
            const hourContent = taskEl.closest('.hour-content');
            const rect = hourContent.getBoundingClientRect();
            const taskTop = parseFloat(taskEl.style.top) || 0;

            // Calculate new height based on mouse position relative to hour content
            const relativeY = e.clientY - rect.top;
            const newHeightPercent = Math.max(25, relativeY - (taskTop / 100 * rect.height)) / rect.height * 100;

            // Snap to 15-minute increments (25% of hour)
            const snappedHeight = Math.round(newHeightPercent / 25) * 25;
            const finalHeight = Math.max(25, Math.min(300, snappedHeight)); // Min 15 min, max 3 hours

            taskEl.style.height = `${finalHeight}%`;
        }

        async function endTaskResize() {
            if (!resizeState) return;

            const { taskEl, taskId, startDate } = resizeState;
            const heightPercent = parseFloat(taskEl.style.height) || 50;

            // Calculate new end time based on height
            const durationMinutes = (heightPercent / 100) * 60;
            const endDate = new Date(startDate.getTime() + durationMinutes * 60 * 1000);
            const endTimeUTC = localToUTC(endDate);

            taskEl.classList.remove('resizing');

            // Update on server
            await updateTaskCalendarEndTime(taskId, endTimeUTC);

            document.removeEventListener('mousemove', handleTaskResize);
            document.removeEventListener('mouseup', endTaskResize);
            resizeState = null;
        }

        // Setup drag events for scheduled tasks on the calendar
        function setupScheduledTaskDragEvents(taskEl) {
            taskEl.addEventListener('dragstart', function(e) {
                this.classList.add('dragging');
                currentDragTaskId = this.dataset.taskId;
                e.dataTransfer.effectAllowed = 'move';
                e.dataTransfer.setData('text/plain', this.dataset.taskId);
                e.dataTransfer.setData('application/x-scheduled-task', 'true');
            });

            taskEl.addEventListener('dragend', function() {
                this.classList.remove('dragging');
                currentDragTaskId = null;
                document.querySelectorAll('.hour-content.drag-over').forEach(el => {
                    el.classList.remove('drag-over', 'drag-top', 'drag-bottom', 'drag-blocked');
                    el.style.removeProperty('--preview-height');
                });
            });
        }

        // Convert local datetime to UTC ISO string
        function localToUTC(localDate) {
            return localDate.toISOString();
        }

        // Update a task's calendar times on the server
        async function updateTaskCalendarTime(taskId, startTimeUTC, endTimeUTC = undefined) {
            try {
                const body = { calendar_start_time: startTimeUTC };
                // If endTimeUTC is explicitly provided (including null), include it
                if (endTimeUTC !== undefined) {
                    body.calendar_end_time = endTimeUTC;
                }

                const response = await fetch(`/tasks/api/${taskId}/update/`, {
                    method: 'PATCH',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-CSRFToken': csrfToken
                    },
                    body: JSON.stringify(body)
                });

                const data = await response.json();
                if (data.success) {
                    // Update local maps
                    taskCalendarStartTimeMap[taskId] = startTimeUTC;
                    if (endTimeUTC !== undefined) {
                        taskCalendarEndTimeMap[taskId] = endTimeUTC;
                    }

                    // Update task card scheduled class
                    updateTaskScheduledClass(taskId);

                    return true;
                }
            } catch (error) {
                console.error('Error updating calendar time:', error);
            }
            return false;
        }

        // Update only the end time of a task
        async function updateTaskCalendarEndTime(taskId, endTimeUTC) {
            try {
                const response = await fetch(`/tasks/api/${taskId}/update/`, {
                    method: 'PATCH',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-CSRFToken': csrfToken
                    },
                    body: JSON.stringify({ calendar_end_time: endTimeUTC })
                });

                const data = await response.json();
                if (data.success) {
                    // Update local map
                    taskCalendarEndTimeMap[taskId] = endTimeUTC;
                    return true;
                }
            } catch (error) {
                console.error('Error updating calendar end time:', error);
            }
            return false;
        }

        // Update the scheduled class on a task card
        function updateTaskScheduledClass(taskId) {
            const cards = document.querySelectorAll(`.task-card[data-task-id="${taskId}"]`);
            const calendarTime = taskCalendarStartTimeMap[taskId];
            const isScheduled = !!calendarTime;
            const isToday = isScheduled && isScheduledForToday(calendarTime);

            cards.forEach(card => {
                card.classList.toggle('scheduled', isScheduled);

                // Add or remove today sun icon
                let todayIcon = card.querySelector('.task-card-today-icon');
                if (isToday) {
                    if (!todayIcon) {
                        todayIcon = document.createElement('i');
                        todayIcon.className = 'bi bi-brightness-high-fill task-card-today-icon';
                        // Insert into icons container or create one
                        const content = card.querySelector('.task-card-content');
                        if (content) {
                            let iconsContainer = content.querySelector('.task-card-icons');
                            if (!iconsContainer) {
                                iconsContainer = document.createElement('div');
                                iconsContainer.className = 'task-card-icons';
                                content.appendChild(iconsContainer);
                            }
                            // Insert today icon at the start (before critical icon)
                            iconsContainer.insertBefore(todayIcon, iconsContainer.firstChild);
                        }
                    }
                } else if (todayIcon) {
                    todayIcon.remove();
                    // Remove icons container if empty
                    const iconsContainer = card.querySelector('.task-card-icons');
                    if (iconsContainer && iconsContainer.children.length === 0) {
                        iconsContainer.remove();
                    }
                }
            });
        }

        // Remove a task from the calendar (via context menu or remove button)
        async function removeFromCalendar(taskId) {
            closeContextMenu();

            const success = await updateTaskCalendarTime(taskId, null, null);

            if (success) {
                renderScheduledTasks();
            }
        }

        // Check if there's an overlapping task or event at the given time
        function hasOverlappingItem(newStart, newEnd, excludeTaskId) {
            // Check existing scheduled tasks
            for (const [taskId, calendarStartTime] of Object.entries(taskCalendarStartTimeMap)) {
                if (!calendarStartTime) continue;
                if (taskId === excludeTaskId || taskId === String(excludeTaskId)) continue;

                const taskStart = new Date(calendarStartTime);
                const calendarEndTime = taskCalendarEndTimeMap[taskId];
                const taskEnd = calendarEndTime ? new Date(calendarEndTime) : new Date(taskStart.getTime() + 30 * 60 * 1000);

                // Check for overlap: (newStart < taskEnd) && (newEnd > taskStart)
                if (newStart < taskEnd && newEnd > taskStart) {
                    return true;
                }
            }

            // Check calendar events
            if (calendarEvents && calendarEvents.length > 0) {
                for (const event of calendarEvents) {
                    if (event.is_all_day) continue;

                    const eventStart = new Date(event.start);
                    const eventEnd = new Date(event.end);

                    // Check for overlap
                    if (newStart < eventEnd && newEnd > eventStart) {
                        return true;
                    }
                }
            }

            // Check time blocks
            if (timeBlocks && timeBlocks.length > 0) {
                for (const block of timeBlocks) {
                    const blockStart = new Date(block.start);
                    const blockEnd = new Date(block.end);

                    // Check for overlap
                    if (newStart < blockEnd && newEnd > blockStart) {
                        return true;
                    }
                }
            }

            return false;
        }

        // Setup drop zones on calendar hour rows
        function setupCalendarDropZones() {
            document.querySelectorAll('.hour-content').forEach(hourContent => {
                hourContent.addEventListener('dragover', function(e) {
                    e.preventDefault();
                    this.classList.add('drag-over');

                    // Use currentDragTaskId which works for both task cards and calendar items
                    const taskId = currentDragTaskId;

                    // Use existing duration if task has one, otherwise 30 minutes
                    let durationMs = 30 * 60 * 1000;
                    if (taskId) {
                        const existingStartTime = taskCalendarStartTimeMap[taskId];
                        const existingEndTime = taskCalendarEndTimeMap[taskId];
                        if (existingStartTime && existingEndTime) {
                            const existingStart = new Date(existingStartTime);
                            const existingEnd = new Date(existingEndTime);
                            durationMs = existingEnd - existingStart;
                        }
                    }
                    const durationMinutes = durationMs / (60 * 1000);

                    // Calculate preview height as percentage of hour (60px per hour)
                    const previewHeightPercent = (durationMinutes / 60) * 100;
                    this.style.setProperty('--preview-height', `${previewHeightPercent}%`);

                    // Determine drop position (top or bottom half of hour)
                    const rect = this.getBoundingClientRect();
                    const relativeY = e.clientY - rect.top;
                    const isTopHalf = relativeY < rect.height / 2;
                    this.classList.toggle('drag-top', isTopHalf);
                    this.classList.toggle('drag-bottom', !isTopHalf);

                    // Check for overlap and show blocked indicator
                    const hour = parseInt(this.dataset.hour);
                    const clampedMinute = isTopHalf ? 0 : 30;
                    const now = new Date();
                    const startLocal = new Date(now.getFullYear(), now.getMonth(), now.getDate(), hour, clampedMinute);
                    const endLocal = new Date(startLocal.getTime() + durationMs);

                    const isBlocked = taskId && hasOverlappingItem(startLocal, endLocal, taskId);
                    this.classList.toggle('drag-blocked', isBlocked);
                    e.dataTransfer.dropEffect = isBlocked ? 'none' : 'move';
                });

                hourContent.addEventListener('dragleave', function(e) {
                    if (!this.contains(e.relatedTarget)) {
                        this.classList.remove('drag-over', 'drag-top', 'drag-bottom', 'drag-blocked');
                        this.style.removeProperty('--preview-height');
                    }
                });

                hourContent.addEventListener('drop', async function(e) {
                    e.preventDefault();
                    this.classList.remove('drag-over', 'drag-top', 'drag-bottom', 'drag-blocked');
                    this.style.removeProperty('--preview-height');

                    const taskId = e.dataTransfer.getData('text/plain');
                    if (!taskId) return;

                    const hour = parseInt(this.dataset.hour);

                    // Calculate minute based on drop position within the hour
                    const rect = this.getBoundingClientRect();
                    const relativeY = e.clientY - rect.top;
                    const percentY = relativeY / rect.height;
                    // Round to nearest 30 minutes (0 or 30)
                    const clampedMinute = percentY < 0.5 ? 0 : 30;

                    // Create the scheduled start time in local timezone
                    const now = new Date();
                    const startLocal = new Date(now.getFullYear(), now.getMonth(), now.getDate(), hour, clampedMinute);

                    // Preserve existing duration if task already has one, otherwise default to 30 minutes
                    let durationMs = 30 * 60 * 1000; // 30 minutes default
                    const existingStartTime = taskCalendarStartTimeMap[taskId];
                    const existingEndTime = taskCalendarEndTimeMap[taskId];
                    if (existingStartTime && existingEndTime) {
                        const existingStart = new Date(existingStartTime);
                        const existingEnd = new Date(existingEndTime);
                        durationMs = existingEnd - existingStart;
                    }

                    const endLocal = new Date(startLocal.getTime() + durationMs);

                    // Check for overlapping tasks or events before allowing drop
                    if (hasOverlappingItem(startLocal, endLocal, taskId)) {
                        // Don't drop - there's already something at this time
                        return;
                    }

                    const startUTC = localToUTC(startLocal);
                    const endUTC = localToUTC(endLocal);

                    // Update on server with both start and end times
                    const success = await updateTaskCalendarTime(taskId, startUTC, endUTC);

                    if (success) {
                        // Re-render scheduled tasks on calendar
                        renderScheduledTasks();
                    }
                });
            });
        }

        // Setup task cards to be draggable to calendar and tasks panel as drop target for removing from calendar
        function setupTaskToCalendarDrag() {
            // Task cards can already be dragged (setupTaskCardDragEvents handles this)
            // We just need to make sure the calendar drop zones accept them

            // Also set up the tasks panel as a drop target for removing calendar times
            const tasksPanel = document.getElementById('tasks-panel');
            if (tasksPanel) {
                tasksPanel.addEventListener('dragover', function(e) {
                    // Only show drop indicator if dragging a scheduled task from calendar
                    if (e.dataTransfer.types.includes('application/x-scheduled-task')) {
                        e.preventDefault();
                        e.dataTransfer.dropEffect = 'move';
                    }
                });

                tasksPanel.addEventListener('drop', async function(e) {
                    // Only handle if dragging a scheduled task from calendar
                    if (!e.dataTransfer.types.includes('application/x-scheduled-task')) return;

                    e.preventDefault();
                    const taskId = e.dataTransfer.getData('text/plain');
                    if (!taskId) return;

                    // Remove calendar times (both start and end)
                    const success = await updateTaskCalendarTime(taskId, null, null);

                    if (success) {
                        // Re-render scheduled tasks (will remove the element)
                        renderScheduledTasks();
                    }
                });
            }
        }

        // Initialize scheduled task indicators on existing cards
        function initScheduledTaskIndicators() {
            Object.entries(taskCalendarStartTimeMap).forEach(([taskId, calendarTime]) => {
                if (calendarTime) {
                    updateTaskScheduledClass(taskId);
                }
            });
        }

        // Update task counts in the panel layout
        function updatePanelCounts() {
            // Update state group counts (in states-content)
            document.querySelectorAll('#states-content .state-group').forEach(group => {
                const stateId = group.dataset.stateId;
                const body = group.querySelector('.state-group-body');
                if (!body) return;

                const visibleCards = body.querySelectorAll('.task-card:not([style*="display: none"])').length;
                const countEl = document.getElementById(`panel-count-${stateId}`);
                if (countEl) countEl.textContent = visibleCards;

                // Update collapsed metrics pill
                const metricPill = document.querySelector(`.panel-collapsed-metrics .metric-pill[data-state-id="${stateId}"] .metric-count`);
                if (metricPill) metricPill.textContent = visibleCards;

                // Show/hide empty message (always hide "No State" group when empty)
                let emptyMsg = body.querySelector('.state-group-empty');
                if (visibleCards === 0) {
                    if (stateId === 'none') {
                        // Hide "No State" group when empty
                        group.style.display = 'none';
                    } else {
                        group.style.display = '';
                        if (!emptyMsg) {
                            emptyMsg = document.createElement('div');
                            emptyMsg.className = 'state-group-empty';
                            emptyMsg.textContent = 'No tasks';
                            body.appendChild(emptyMsg);
                        }
                    }
                } else {
                    group.style.display = '';
                    if (emptyMsg) {
                        emptyMsg.remove();
                    }
                }
            });

            // Update tag group counts (in tags-content)
            document.querySelectorAll('#tags-content .state-group').forEach(group => {
                const body = group.querySelector('.state-group-body');
                if (!body) return;

                const visibleCards = body.querySelectorAll('.task-card:not([style*="display: none"])').length;
                const countEl = group.querySelector('.state-group-count');
                if (countEl) countEl.textContent = visibleCards;

                // Show empty message when no visible tasks
                let emptyMsg = body.querySelector('.state-group-empty');
                if (visibleCards === 0) {
                    group.style.display = '';
                    if (!emptyMsg) {
                        emptyMsg = document.createElement('div');
                        emptyMsg.className = 'state-group-empty';
                        emptyMsg.textContent = 'No tasks';
                        body.appendChild(emptyMsg);
                    }
                } else {
                    group.style.display = '';
                    if (emptyMsg) {
                        emptyMsg.remove();
                    }
                }
            });
        }

        // Update calendar metrics in collapsed view
        function updateCalendarMetrics() {
            if (!calendarEvents || calendarEvents.length === 0) {
                document.getElementById('meetings-count').textContent = '0';
                document.getElementById('meetings-time').textContent = '0h';
                return;
            }

            // Get today's date boundaries in local timezone
            const now = new Date();
            const todayStart = new Date(now.getFullYear(), now.getMonth(), now.getDate());
            const todayEnd = new Date(todayStart.getTime() + 24 * 60 * 60 * 1000);

            // Filter to today's events and count non-all-day events as meetings
            const todaysEvents = calendarEvents.filter(event => {
                if (event.is_all_day) return false;
                const startDate = new Date(event.start);
                const endDate = new Date(event.end);
                // Event overlaps with today
                return endDate > todayStart && startDate < todayEnd;
            });

            const meetingCount = todaysEvents.length;

            // Calculate total time in meetings (in minutes)
            let totalMinutes = 0;
            todaysEvents.forEach(event => {
                const startDate = new Date(event.start);
                const endDate = new Date(event.end);
                const durationMs = endDate - startDate;
                totalMinutes += Math.round(durationMs / 60000);
            });

            // Format time
            const hours = Math.floor(totalMinutes / 60);
            const mins = totalMinutes % 60;
            let timeStr;
            if (hours > 0 && mins > 0) {
                timeStr = `${hours}h ${mins}m`;
            } else if (hours > 0) {
                timeStr = `${hours}h`;
            } else {
                timeStr = `${mins}m`;
            }

            document.getElementById('meetings-count').textContent = meetingCount;
            document.getElementById('meetings-time').textContent = timeStr;
        }

        // ========== Task Card Drag and Drop ==========

        let draggedTaskCard = null;
        let taskDropIndicator = null;
        let currentDragTaskId = null; // Track dragged task ID for both task cards and calendar items

        // Create drop indicator element for task cards
        function createTaskDropIndicator() {
            const indicator = document.createElement('div');
            indicator.className = 'task-drop-indicator';
            indicator.style.cssText = 'height: 3px; background: #6B9080; border-radius: 2px; margin: 0.35rem 0;';
            return indicator;
        }

        // Get drop position within state-group-body
        function getTaskDropPosition(container, y) {
            const cards = [...container.querySelectorAll('.task-card:not(.dragging)')];

            for (const card of cards) {
                const rect = card.getBoundingClientRect();
                const midpoint = rect.top + rect.height / 2;
                if (y < midpoint) {
                    return { element: card, position: 'before' };
                }
            }
            return { element: null, position: 'end' };
        }

        // Setup drag events for task cards
        function setupTaskCardDragEvents(card) {
            card.addEventListener('dragstart', function(e) {
                draggedTaskCard = this;
                currentDragTaskId = this.dataset.taskId;
                this.classList.add('dragging');
                e.dataTransfer.effectAllowed = 'move';
                e.dataTransfer.setData('text/plain', this.dataset.taskId);
                setTimeout(() => {
                    this.style.opacity = '0.4';
                }, 0);
            });

            card.addEventListener('dragend', function() {
                this.classList.remove('dragging');
                this.style.opacity = '1';
                draggedTaskCard = null;
                currentDragTaskId = null;
                // Remove all drag-over classes and drop indicator
                document.querySelectorAll('.drag-over').forEach(el => el.classList.remove('drag-over'));
                if (taskDropIndicator && taskDropIndicator.parentElement) {
                    taskDropIndicator.remove();
                }
                taskDropIndicator = null;
            });

            // Right-click to show context menu (only way to open task panel)
            card.addEventListener('contextmenu', function(e) {
                showContextMenu(e, parseInt(this.dataset.taskId), 'openTaskPanel');
            });
        }

        // Setup drop zones (state-group-body elements)
        function setupDropZones() {
            document.querySelectorAll('.state-group-body').forEach(dropZone => {
                dropZone.addEventListener('dragover', function(e) {
                    e.preventDefault();
                    if (!draggedTaskCard) return;

                    e.dataTransfer.dropEffect = 'move';
                    this.classList.add('drag-over');

                    // Show drop indicator at correct position
                    const { element, position } = getTaskDropPosition(this, e.clientY);

                    if (!taskDropIndicator) {
                        taskDropIndicator = createTaskDropIndicator();
                    }

                    if (position === 'end') {
                        this.appendChild(taskDropIndicator);
                    } else if (element) {
                        element.parentElement.insertBefore(taskDropIndicator, element);
                    }
                });

                dropZone.addEventListener('dragleave', function(e) {
                    // Only remove if we're actually leaving the drop zone
                    if (!this.contains(e.relatedTarget)) {
                        this.classList.remove('drag-over');
                        if (taskDropIndicator && taskDropIndicator.parentElement === this) {
                            taskDropIndicator.remove();
                        }
                    }
                });

                dropZone.addEventListener('drop', async function(e) {
                    e.preventDefault();
                    this.classList.remove('drag-over');

                    if (!draggedTaskCard) return;

                    const taskId = parseInt(draggedTaskCard.dataset.taskId);
                    const rawNewStateId = this.dataset.stateId;
                    const newStateId = rawNewStateId === 'none' ? null : parseInt(rawNewStateId);
                    const oldBody = draggedTaskCard.parentElement;
                    const rawOldStateId = draggedTaskCard.closest('.state-group').dataset.stateId;
                    const oldStateId = rawOldStateId === 'none' ? null : parseInt(rawOldStateId);
                    const changedState = (newStateId !== oldStateId);

                    // Get drop position
                    const { element, position } = getTaskDropPosition(this, e.clientY);

                    // Remove drop indicator
                    if (taskDropIndicator && taskDropIndicator.parentElement) {
                        taskDropIndicator.remove();
                    }

                    // Move card to new position
                    if (position === 'end') {
                        this.appendChild(draggedTaskCard);
                    } else if (element) {
                        element.parentElement.insertBefore(draggedTaskCard, element);
                    }

                    // Update counts
                    updatePanelCounts();

                    // Get new order of all cards in this state
                    const cardIds = [...this.querySelectorAll('.task-card')].map(c => parseInt(c.dataset.taskId));

                    // If state changed, update state on server
                    if (changedState) {
                        try {
                            await fetch(`/tasks/api/${taskId}/update/`, {
                                method: 'PATCH',
                                headers: {
                                    'Content-Type': 'application/json',
                                    'X-CSRFToken': csrfToken
                                },
                                body: JSON.stringify({ state_id: newStateId })
                            });
                        } catch (error) {
                            console.error('Error updating task state:', error);
                        }
                    }

                    // Always update order (for both same-state reorder and cross-state moves)
                    try {
                        await fetch('/tasks/api/tasks/reorder/', {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                                'X-CSRFToken': csrfToken
                            },
                            body: JSON.stringify({ task_ids: cardIds })
                        });
                    } catch (error) {
                        console.error('Error updating task order:', error);
                    }

                    // If we moved to a different state, also reorder the old state
                    if (changedState && oldBody) {
                        const oldCardIds = [...oldBody.querySelectorAll('.task-card')].map(c => parseInt(c.dataset.taskId));
                        try {
                            await fetch('/tasks/api/tasks/reorder/', {
                                method: 'POST',
                                headers: {
                                    'Content-Type': 'application/json',
                                    'X-CSRFToken': csrfToken
                                },
                                body: JSON.stringify({ task_ids: oldCardIds })
                            });
                        } catch (error) {
                            console.error('Error updating old state order:', error);
                        }
                    }
                });
            });
        }

        // Initialize drag and drop for existing cards
        document.querySelectorAll('.task-card').forEach(card => {
            setupTaskCardDragEvents(card);
        });
        setupDropZones();

        // Setup drag handlers for a single state group (used when adding new states)
        function setupStateGroupDragHandlers(stateGroup) {
            const dropZone = stateGroup.querySelector('.state-group-body');
            const header = stateGroup.querySelector('.state-group-header');

            if (dropZone) {
                dropZone.addEventListener('dragover', function(e) {
                    e.preventDefault();
                    if (!draggedTaskCard) return;

                    e.dataTransfer.dropEffect = 'move';
                    this.classList.add('drag-over');

                    const { element, position } = getTaskDropPosition(this, e.clientY);

                    if (!taskDropIndicator) {
                        taskDropIndicator = createTaskDropIndicator();
                    }

                    if (position === 'end') {
                        this.appendChild(taskDropIndicator);
                    } else if (element) {
                        element.parentElement.insertBefore(taskDropIndicator, element);
                    }
                });

                dropZone.addEventListener('dragleave', function(e) {
                    if (!this.contains(e.relatedTarget)) {
                        this.classList.remove('drag-over');
                        if (taskDropIndicator && taskDropIndicator.parentElement === this) {
                            taskDropIndicator.remove();
                        }
                    }
                });

                dropZone.addEventListener('drop', async function(e) {
                    e.preventDefault();
                    this.classList.remove('drag-over');

                    if (!draggedTaskCard) return;

                    const taskId = parseInt(draggedTaskCard.dataset.taskId);
                    const rawNewStateId = this.dataset.stateId;
                    const newStateId = rawNewStateId === 'none' ? null : parseInt(rawNewStateId);
                    const rawOldStateId = draggedTaskCard.closest('.state-group').dataset.stateId;
                    const oldStateId = rawOldStateId === 'none' ? null : parseInt(rawOldStateId);
                    const changedState = (newStateId !== oldStateId);

                    const { element, position } = getTaskDropPosition(this, e.clientY);

                    if (taskDropIndicator && taskDropIndicator.parentElement) {
                        taskDropIndicator.remove();
                    }

                    if (position === 'end') {
                        this.appendChild(draggedTaskCard);
                    } else if (element) {
                        element.parentElement.insertBefore(draggedTaskCard, element);
                    }

                    updatePanelCounts();

                    const cardIds = [...this.querySelectorAll('.task-card')].map(c => parseInt(c.dataset.taskId));

                    if (changedState) {
                        try {
                            await fetch(`/tasks/api/${taskId}/update/`, {
                                method: 'PATCH',
                                headers: {
                                    'Content-Type': 'application/json',
                                    'X-CSRFToken': csrfToken
                                },
                                body: JSON.stringify({ state_id: newStateId })
                            });
                        } catch (error) {
                            console.error('Error updating task state:', error);
                        }
                    }

                    try {
                        await fetch('/tasks/api/tasks/reorder/', {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                                'X-CSRFToken': csrfToken
                            },
                            body: JSON.stringify({ task_ids: cardIds })
                        });
                    } catch (error) {
                        console.error('Error reordering tasks:', error);
                    }
                });
            }

            if (header) {
                header.addEventListener('dragover', function(e) {
                    if (!draggedTaskCard) return;
                    e.preventDefault();
                    e.dataTransfer.dropEffect = 'move';

                    // Add visual feedback for both expanded and collapsed headers
                    this.classList.add('drag-hover');

                    const sg = this.closest('.state-group');
                    if (sg && sg.classList.contains('collapsed')) {
                        // Don't auto-expand terminal state
                        const stateId = parseInt(sg.dataset.stateId);
                        const isTerminal = stateId === getTerminalStateId();
                        if (isTerminal) return;

                        // Auto-expand collapsed state after delay
                        if (!expandTimeout) {
                            expandTimeout = setTimeout(() => {
                                sg.classList.remove('collapsed');
                            }, 400);
                        }
                    }
                });

                header.addEventListener('dragleave', function(e) {
                    this.classList.remove('drag-hover');
                    if (expandTimeout) {
                        clearTimeout(expandTimeout);
                        expandTimeout = null;
                    }
                });

                header.addEventListener('drop', async function(e) {
                    e.preventDefault();
                    this.classList.remove('drag-hover');
                    if (expandTimeout) {
                        clearTimeout(expandTimeout);
                        expandTimeout = null;
                    }

                    if (!draggedTaskCard) return;

                    const stateGroup = this.closest('.state-group');
                    const body = stateGroup.querySelector('.state-group-body');
                    if (!body) return;

                    const taskId = parseInt(draggedTaskCard.dataset.taskId);
                    const newStateId = parseInt(body.dataset.stateId);
                    const oldStateGroup = draggedTaskCard.closest('.state-group');
                    const oldBody = oldStateGroup ? oldStateGroup.querySelector('.state-group-body') : null;
                    const oldStateId = oldBody ? parseInt(oldBody.dataset.stateId) : null;
                    const changedState = (newStateId !== oldStateId);

                    // Expand the state if collapsed (except for terminal state)
                    const isTerminalState = newStateId === getTerminalStateId();
                    if (!isTerminalState) {
                        stateGroup.classList.remove('collapsed');
                    }

                    // Move the task card to the top of the body
                    if (body.firstChild) {
                        body.insertBefore(draggedTaskCard, body.firstChild);
                    } else {
                        body.appendChild(draggedTaskCard);
                    }

                    updatePanelCounts();

                    // Update task order in the new state
                    const cardIds = [...body.querySelectorAll('.task-card')].map(c => parseInt(c.dataset.taskId));

                    if (changedState) {
                        // Update task state in database
                        try {
                            await fetch(`/tasks/api/${taskId}/update/`, {
                                method: 'PATCH',
                                headers: {
                                    'Content-Type': 'application/json',
                                    'X-CSRFToken': csrfToken
                                },
                                body: JSON.stringify({ state_id: newStateId })
                            });
                        } catch (error) {
                            console.error('Error updating task state:', error);
                        }

                        // Update order in old state
                        if (oldBody) {
                            const oldCardIds = [...oldBody.querySelectorAll('.task-card')].map(c => parseInt(c.dataset.taskId));
                            try {
                                await fetch('/tasks/api/tasks/reorder/', {
                                    method: 'POST',
                                    headers: {
                                        'Content-Type': 'application/json',
                                        'X-CSRFToken': csrfToken
                                    },
                                    body: JSON.stringify({ task_ids: oldCardIds })
                                });
                            } catch (error) {
                                console.error('Error updating old state order:', error);
                            }
                        }
                    }

                    // Update order in new state
                    try {
                        await fetch('/tasks/api/tasks/reorder/', {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                                'X-CSRFToken': csrfToken
                            },
                            body: JSON.stringify({ task_ids: cardIds })
                        });
                    } catch (error) {
                        console.error('Error reordering tasks:', error);
                    }
                });
            }
        }

        // Setup drag-over handlers for state group headers
        // When dragging over a header, allow dropping to move task into that state
        let expandTimeout = null;
        document.querySelectorAll('.state-group-header').forEach(header => {
            header.addEventListener('dragover', function(e) {
                if (!draggedTaskCard) return;
                e.preventDefault();
                e.dataTransfer.dropEffect = 'move';

                // Add visual feedback for both expanded and collapsed headers
                this.classList.add('drag-hover');

                const stateGroup = this.closest('.state-group');
                if (stateGroup && stateGroup.classList.contains('collapsed')) {
                    // Don't auto-expand terminal state
                    const stateId = parseInt(stateGroup.dataset.stateId);
                    const isTerminal = stateId === getTerminalStateId();
                    if (isTerminal) return;

                    // Auto-expand collapsed state after delay
                    if (!expandTimeout) {
                        expandTimeout = setTimeout(() => {
                            stateGroup.classList.remove('collapsed');
                        }, 400);
                    }
                }
            });

            header.addEventListener('dragleave', function(e) {
                this.classList.remove('drag-hover');
                if (expandTimeout) {
                    clearTimeout(expandTimeout);
                    expandTimeout = null;
                }
            });

            header.addEventListener('drop', async function(e) {
                e.preventDefault();
                this.classList.remove('drag-hover');
                if (expandTimeout) {
                    clearTimeout(expandTimeout);
                    expandTimeout = null;
                }

                if (!draggedTaskCard) return;

                const stateGroup = this.closest('.state-group');
                const body = stateGroup.querySelector('.state-group-body');
                if (!body) return;

                const taskId = parseInt(draggedTaskCard.dataset.taskId);
                const newStateId = parseInt(body.dataset.stateId);
                const oldStateGroup = draggedTaskCard.closest('.state-group');
                const oldBody = oldStateGroup ? oldStateGroup.querySelector('.state-group-body') : null;
                const oldStateId = oldBody ? parseInt(oldBody.dataset.stateId) : null;
                const changedState = (newStateId !== oldStateId);

                // Expand the state if collapsed (except for terminal state)
                const isTerminalState = newStateId === getTerminalStateId();
                if (!isTerminalState) {
                    stateGroup.classList.remove('collapsed');
                }

                // Move the task card to the top of the body
                if (body.firstChild) {
                    body.insertBefore(draggedTaskCard, body.firstChild);
                } else {
                    body.appendChild(draggedTaskCard);
                }

                updatePanelCounts();

                // Update task order in the new state
                const cardIds = [...body.querySelectorAll('.task-card')].map(c => parseInt(c.dataset.taskId));

                if (changedState) {
                    // Update task state in database
                    try {
                        await fetch(`/tasks/api/${taskId}/update/`, {
                            method: 'PATCH',
                            headers: {
                                'Content-Type': 'application/json',
                                'X-CSRFToken': csrfToken
                            },
                            body: JSON.stringify({ state_id: newStateId })
                        });
                    } catch (error) {
                        console.error('Error updating task state:', error);
                    }

                    // Update order in old state
                    if (oldBody) {
                        const oldCardIds = [...oldBody.querySelectorAll('.task-card')].map(c => parseInt(c.dataset.taskId));
                        try {
                            await fetch('/tasks/api/tasks/reorder/', {
                                method: 'POST',
                                headers: {
                                    'Content-Type': 'application/json',
                                    'X-CSRFToken': csrfToken
                                },
                                body: JSON.stringify({ task_ids: oldCardIds })
                            });
                        } catch (error) {
                            console.error('Error updating old state order:', error);
                        }
                    }
                }

                // Update order in new state
                try {
                    await fetch('/tasks/api/tasks/reorder/', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'X-CSRFToken': csrfToken
                        },
                        body: JSON.stringify({ task_ids: cardIds })
                    });
                } catch (error) {
                    console.error('Error reordering tasks:', error);
                }
            });
        });

        // Initialize two-panel layout
        generateHourlyCalendar();
        setCalendarDate();
        renderCalendarEvents();
        renderTimeBlocks();
        setupCalendarDropZones();
        renderScheduledTasks();
        initScheduledTaskIndicators();
        setupTaskToCalendarDrag();
        updatePanelCounts();
        updateCalendarMetrics();
        updateStateTypeLabels();

        // Subtle icon color animation
        (function() {
            const icon = document.getElementById('page-icon');
            const baseColor = { r: 51, g: 51, b: 51 }; // #333
            const accentColor = { r: 107, g: 144, b: 128 }; // #6B9080 (Sage)
            let animationFrame;
            let startTime;
            let duration;
            let direction = 1; // 1 = to accent, -1 = to base

            function lerp(a, b, t) {
                return a + (b - a) * t;
            }

            function getRandomDuration() {
                return 3000 + Math.random() * 4000; // 3-7 seconds
            }

            function animate(timestamp) {
                if (!startTime) {
                    startTime = timestamp;
                    duration = getRandomDuration();
                }

                const elapsed = timestamp - startTime;
                const progress = Math.min(elapsed / duration, 1);

                // Ease in-out
                const eased = progress < 0.5
                    ? 2 * progress * progress
                    : 1 - Math.pow(-2 * progress + 2, 2) / 2;

                const t = direction === 1 ? eased : 1 - eased;

                const r = Math.round(lerp(baseColor.r, accentColor.r, t));
                const g = Math.round(lerp(baseColor.g, accentColor.g, t));
                const b = Math.round(lerp(baseColor.b, accentColor.b, t));

                icon.style.color = `rgb(${r}, ${g}, ${b})`;

                if (progress >= 1) {
                    direction *= -1;
                    startTime = null;
                }

                animationFrame = requestAnimationFrame(animate);
            }

            animationFrame = requestAnimationFrame(animate);
        })();

        // ========== Calendar Drag and Drop ==========

        // Setup calendar sections as drop zones
        document.querySelectorAll('.calendar-section').forEach(section => {
            section.addEventListener('dragover', function(e) {
                e.preventDefault();
                if (!draggedKanbanCard) return;
                this.classList.add('drag-over');
            });

            section.addEventListener('dragleave', function(e) {
                this.classList.remove('drag-over');
            });

            section.addEventListener('drop', async function(e) {
                e.preventDefault();
                this.classList.remove('drag-over');

                if (!draggedKanbanCard) return;

                const taskId = parseInt(draggedKanbanCard.dataset.taskId);

                // Get time period from parent calendar box
                const calendarBox = this.closest('.calendar-box');
                const timePeriod = calendarBox.dataset.timePeriod;
                const sectionNumber = parseInt(this.dataset.section);

                // Check if card is already in a calendar section
                const wasInCalendar = draggedKanbanCard.closest('.calendar-section');

                // Get the content div to append to
                const contentDiv = this.querySelector('.calendar-section-content');

                let cardToAdd;
                if (wasInCalendar) {
                    // Move the card from one calendar section to another
                    cardToAdd = draggedKanbanCard;
                    cardToAdd.classList.remove('dragging');
                    cardToAdd.style.opacity = '1';
                    cardToAdd.style.display = 'flex';
                    contentDiv.appendChild(cardToAdd);
                } else {
                    // Clone the card from kanban board
                    cardToAdd = draggedKanbanCard.cloneNode(true);
                    cardToAdd.draggable = true;
                    cardToAdd.classList.remove('dragging');
                    cardToAdd.style.opacity = '1';
                    cardToAdd.style.display = 'flex';
                    contentDiv.appendChild(cardToAdd);

                    // Setup drag for cloned card
                    setupCalendarCardDrag(cardToAdd);
                }

                // Update today field to true with time_period and section_number
                try {
                    await fetch(`/tasks/api/tasks/${taskId}/set-today/`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'X-CSRFToken': csrfToken
                        },
                        body: JSON.stringify({
                            today: true,
                            time_period: timePeriod,
                            section_number: sectionNumber
                        })
                    });
                } catch (error) {
                    console.error('Error updating today field:', error);
                }

                // Update calendar display after DOM updates
                setTimeout(() => {
                    processCalendarSections();
                }, 0);

                draggedKanbanCard = null;
            });
        });

        // Setup drag for calendar cards (to drag back to kanban)
        function setupCalendarCardDrag(card) {
            card.addEventListener('dragstart', function(e) {
                draggedKanbanCard = this;
                this.classList.add('dragging');
                e.dataTransfer.effectAllowed = 'move';
                e.dataTransfer.setData('text/plain', this.dataset.taskId);
                setTimeout(() => {
                    this.style.opacity = '0.4';
                }, 0);
            });

            card.addEventListener('dragend', function(e) {
                this.classList.remove('dragging');
                this.style.opacity = '1';
                draggedKanbanCard = null;
            });

            // Add click handler
            card.addEventListener('click', function() {
                openKanbanPanel(parseInt(this.dataset.taskId));
            });

            // Add context menu
            setupKanbanCardContextMenu(card);
        }

        // Setup drag for existing calendar cards
        document.querySelectorAll('.calendar-section .kanban-card').forEach(card => {
            setupCalendarCardDrag(card);
        });

        // Enhance kanban column drop to remove from calendar when dropped back
        const originalKanbanDropHandler = document.querySelectorAll('.kanban-column-body');
        originalKanbanDropHandler.forEach(body => {
            body.addEventListener('drop', async function(e) {
                if (!draggedKanbanCard) return;

                const taskId = parseInt(draggedKanbanCard.dataset.taskId);
                const wasInCalendar = draggedKanbanCard.closest('.calendar-section');

                if (wasInCalendar) {
                    // Remove from calendar
                    draggedKanbanCard.remove();

                    // Update today field to false
                    try {
                        await fetch(`/tasks/api/tasks/${taskId}/set-today/`, {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                                'X-CSRFToken': csrfToken
                            },
                            body: JSON.stringify({ today: false })
                        });
                    } catch (error) {
                        console.error('Error updating today field:', error);
                    }

                    // Update calendar display after DOM updates
                    setTimeout(() => {
                        processCalendarSections();
                    }, 0);
                }
            });
        });

        // ===== TIME SLOT PANEL FUNCTIONALITY =====

        let currentTimeslotSection = null;
        let draggedTimeslotTask = null;

        // Process calendar sections to show task counts
        function processCalendarSections() {
            document.querySelectorAll('.calendar-section').forEach(section => {
                const content = section.querySelector('.calendar-section-content');
                if (!content) return;

                const tasks = content.querySelectorAll('.kanban-card');
                const taskCount = tasks.length;

                // Remove any existing count display
                const existingCount = content.querySelector('.calendar-task-count');
                if (existingCount) {
                    existingCount.remove();
                }

                if (taskCount > 1) {
                    // Hide individual tasks
                    tasks.forEach(task => task.style.display = 'none');

                    // Create and show count summary
                    const countDiv = document.createElement('div');
                    countDiv.className = 'calendar-task-count';
                    countDiv.textContent = `${taskCount} tasks`;
                    countDiv.dataset.sectionId = section.dataset.section;

                    const calendarBox = section.closest('.calendar-box');
                    if (calendarBox) {
                        countDiv.dataset.timePeriod = calendarBox.dataset.timePeriod;
                    }

                    countDiv.addEventListener('click', function() {
                        openTimeslotPanel(section);
                    });

                    content.appendChild(countDiv);
                } else if (taskCount === 1) {
                    // Show single task normally
                    tasks[0].style.display = 'flex';
                }
            });
        }

        // Open time slot panel
        function openTimeslotPanel(section) {
            currentTimeslotSection = section;
            const content = section.querySelector('.calendar-section-content');
            if (!content) return;

            const tasks = Array.from(content.querySelectorAll('.kanban-card'));
            const calendarBox = section.closest('.calendar-box');
            if (!calendarBox) return;

            // Find the time label by section number
            const sectionNumber = parseInt(section.dataset.section);
            const labelColumn = calendarBox.querySelector('.calendar-label-column');
            if (!labelColumn) return;

            const timeLabels = labelColumn.querySelectorAll('.calendar-time-label');
            const timeLabelEl = timeLabels[sectionNumber - 1]; // section numbers are 1-indexed
            if (!timeLabelEl) return;

            const timeLabel = timeLabelEl.textContent;
            const timePeriod = calendarBox.dataset.timePeriod;

            // Set panel title
            document.getElementById('timeslot-panel-title').textContent =
                `${timePeriod.charAt(0).toUpperCase() + timePeriod.slice(1)} - ${timeLabel}`;

            // Populate task list
            const taskList = document.getElementById('timeslot-task-list');
            taskList.innerHTML = '';

            tasks.forEach(task => {
                const taskItem = createTimeslotTaskItem(task);
                taskList.appendChild(taskItem);
            });

            // Setup drag and drop for reordering
            setupTimeslotDragAndDrop();

            // Show panel
            document.getElementById('timeslot-panel-overlay').classList.add('active');
            document.getElementById('timeslot-panel').classList.add('active');
        }

        // Create task item for timeslot panel
        function createTimeslotTaskItem(task) {
            const item = document.createElement('div');
            item.className = 'timeslot-task-item';
            item.draggable = true;
            item.dataset.taskId = task.dataset.taskId;

            const title = document.createElement('div');
            title.className = 'timeslot-task-title';
            title.textContent = task.querySelector('.kanban-card-title').textContent;

            const meta = document.createElement('div');
            meta.className = 'timeslot-task-meta';

            const contextBadge = task.querySelector('.kanban-card-context');
            if (contextBadge) {
                const badge = document.createElement('span');
                badge.className = 'timeslot-task-context';
                badge.textContent = contextBadge.textContent;
                badge.style.background = contextBadge.style.background;
                meta.appendChild(badge);
            }

            item.appendChild(title);
            item.appendChild(meta);

            return item;
        }

        // Setup drag and drop for timeslot panel
        function setupTimeslotDragAndDrop() {
            const items = document.querySelectorAll('.timeslot-task-item');

            items.forEach(item => {
                item.addEventListener('dragstart', function(e) {
                    draggedTimeslotTask = this;
                    this.classList.add('dragging');
                    e.dataTransfer.effectAllowed = 'move';
                });

                item.addEventListener('dragend', function() {
                    this.classList.remove('dragging');
                    draggedTimeslotTask = null;
                });

                item.addEventListener('dragover', function(e) {
                    e.preventDefault();
                    if (draggedTimeslotTask === this) return;

                    const rect = this.getBoundingClientRect();
                    const midpoint = rect.top + rect.height / 2;

                    if (e.clientY < midpoint) {
                        this.parentNode.insertBefore(draggedTimeslotTask, this);
                    } else {
                        this.parentNode.insertBefore(draggedTimeslotTask, this.nextSibling);
                    }
                });
            });

            // Save order on drop
            document.getElementById('timeslot-task-list').addEventListener('drop', async function() {
                await saveTimeslotTaskOrder();
            });
        }

        // Save task order
        async function saveTimeslotTaskOrder() {
            const taskList = document.getElementById('timeslot-task-list');
            const taskIds = Array.from(taskList.querySelectorAll('.timeslot-task-item'))
                .map(item => parseInt(item.dataset.taskId));

            try {
                const response = await fetch('/tasks/api/tasks/reorder/', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-CSRFToken': csrfToken
                    },
                    body: JSON.stringify({ task_ids: taskIds })
                });

                if (response.ok) {
                    // Update order in the calendar section
                    if (currentTimeslotSection) {
                        const content = currentTimeslotSection.querySelector('.calendar-section-content');
                        const tasks = Array.from(content.querySelectorAll('.kanban-card'));

                        taskIds.forEach((taskId, index) => {
                            const task = tasks.find(t => parseInt(t.dataset.taskId) === taskId);
                            if (task) {
                                task.style.order = index;
                            }
                        });
                    }
                }
            } catch (error) {
                console.error('Error saving task order:', error);
            }
        }

        // Close timeslot panel
        function closeTimeslotPanel() {
            document.getElementById('timeslot-panel-overlay').classList.remove('active');
            document.getElementById('timeslot-panel').classList.remove('active');
            currentTimeslotSection = null;
        }

        // Event listeners for timeslot panel
        document.getElementById('timeslot-panel-close').addEventListener('click', closeTimeslotPanel);
        document.getElementById('timeslot-panel-overlay').addEventListener('click', closeTimeslotPanel);

        // Process calendar sections on page load
        processCalendarSections();

        // Also process after a task is moved to/from calendar
        const originalDropHandler = document.querySelectorAll('.calendar-section');
        originalDropHandler.forEach(section => {
            section.addEventListener('drop', function() {
                setTimeout(processCalendarSections, 100);
            });
        });

    </script>
</body>
</html>
